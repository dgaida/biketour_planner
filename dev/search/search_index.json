{"config":{"lang":["de","en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Bike Tour Planner","text":""},{"location":"#ubersicht","title":"\u00dcbersicht","text":"<p>Bike Tour Planner ist eine Python-basierte Toolchain zur Planung von Langstrecken-Radtouren durch die Kombination von:</p> <ul> <li>realen Unterkunftsdaten (Booking.com &amp; Airbnb HTML-Best\u00e4tigungen),</li> <li>existierenden GPX-Tracks Ihrer geplanten oder gefahrenen Tour,</li> <li>Offline-Fahrrad-Routing mit BRouter,</li> <li>Entdeckung von Touristenattraktionen \u00fcber die Geoapify-API,</li> <li>und automatischer Passerkennung.</li> </ul> <p>Das Hauptziel besteht darin, GPX-Routen automatisch zu erweitern und zu verbinden, sodass sie pr\u00e4zise zu den gebuchten Unterk\u00fcnften f\u00fchren, w\u00e4hrend gleichzeitig n\u00fctzliche Tourstatistiken wie Distanz, H\u00f6hengewinn und h\u00f6chster Punkt gesammelt werden. Der Planer generiert professionelle PDF-Berichte mit H\u00f6henprofilen, anklickbaren Karten und umfassenden Tourinformationen.</p>"},{"location":"#hauptmerkmale","title":"Hauptmerkmale","text":"<ul> <li>\ud83d\udcc4 Parsing von Booking.com &amp; Airbnb Best\u00e4tigungen (HTML)</li> <li>\ud83c\udf0d Intelligente Geokodierung</li> <li>\ud83d\uddfa\ufe0f Erweitertes GPX-Routenmanagement</li> <li>\ud83d\udeb4 Offline-Fahrrad-Routing mit BRouter</li> <li>\ud83c\udfd4\ufe0f Integration von Gebirgsp\u00e4ssen</li> <li>\ud83c\udfaf Entdeckung von Sehensw\u00fcrdigkeiten</li> <li>\ud83d\udcca Professionelle Exportoptionen</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Siehe Installation und Erste Schritte.</p>"},{"location":"#typischer-workflow","title":"Typischer Workflow","text":""},{"location":"#1-daten-vorbereiten","title":"1. Daten vorbereiten","text":"<pre><code>biketour_planner/\n\u251c\u2500\u2500 booking/                    # Booking.com/Airbnb HTML-Dateien hier ablegen\n\u251c\u2500\u2500 gpx/                        # GPX-Routendateien hier ablegen\n</code></pre>"},{"location":"#2-konfiguration","title":"2. Konfiguration","text":"<p>Siehe Konfiguration.</p>"},{"location":"#3-planer-ausfuhren","title":"3. Planer ausf\u00fchren","text":"<pre><code>python main.py\n</code></pre>"},{"location":"#dokumentation","title":"Dokumentation","text":"<ul> <li>Architektur</li> <li>API-Referenz</li> <li>Tests</li> <li>Fehlerbehebung</li> </ul>"},{"location":"#lizenz","title":"Lizenz","text":"<p>Dieses Projekt ist unter der MIT-Lizenz lizenziert. Siehe <code>LICENSE</code> f\u00fcr Details.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#unreleased","title":"[unreleased]","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Resolve test failures in brouter and excel export</li> <li>Resolve BRouter connectivity issues by using config and robust health checks</li> <li>Add pytest to docs workflow and use python -m pytest</li> <li>Documentation workflow permissions and type hints</li> <li>Add root index.html and update CI to avoid 404 on GH Pages</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Implement complete MkDocs documentation ecosystem</li> <li>Implement auto-versioning and fix PDF day representation</li> <li>Implement auto-versioning and fix missing Excel info in PDF</li> <li>Implement auto-versioning and fix missing Excel info in PDF</li> <li>Implement auto-versioning and fix missing Excel info in PDF</li> </ul>"},{"location":"changelog/#miscellaneous-tasks","title":"Miscellaneous Tasks","text":"<ul> <li>Bump version</li> </ul>"},{"location":"configuration/","title":"Konfiguration","text":"<p>Die Konfiguration erfolgt \u00fcber eine <code>config.yaml</code>-Datei im Projektstamm. Wenn keine Datei vorhanden ist, werden Standardwerte verwendet.</p>"},{"location":"configuration/#beispiel-configyaml","title":"Beispiel <code>config.yaml</code>","text":"<pre><code>directories:\n  booking: \"../2026_Kroatien/booking\"\n  gpx: \"../2026_Kroatien/gpx\"\n  output: \"../2026_Kroatien/output\"\n\nrouting:\n  brouter_url: \"http://localhost:17777\"\n  max_connection_distance_m: 1000\n  max_chain_length: 20\n  start_search_radius_km: 3.0\n  target_search_radius_km: 10.0\n\npasses:\n  hotel_radius_km: 5.0\n  pass_radius_km: 5.0\n  passes_file: \"Paesse.json\"\n\ngeoapify:\n  search_radius_m: 5000\n  max_pois: 2\n\nexport:\n  title: \"Kroatien Radtour 2026\"\n  excel_info_file: \"Reiseplanung_Fahrrad.xlsx\"\n\nlogging:\n  level: \"INFO\"\n  file: \"logs/app.log\"\n</code></pre>"},{"location":"configuration/#konfigurations-optionen","title":"Konfigurations-Optionen","text":""},{"location":"configuration/#verzeichnisse-directories","title":"Verzeichnisse (<code>directories</code>)","text":"<ul> <li><code>booking</code>: Pfad zu den HTML-Buchungsbest\u00e4tigungen.</li> <li><code>gpx</code>: Pfad zu den urspr\u00fcnglichen GPX-Tracks.</li> <li><code>output</code>: Pfad f\u00fcr generierte Dateien (PDF, merged GPX).</li> </ul>"},{"location":"configuration/#routing-routing","title":"Routing (<code>routing</code>)","text":"<ul> <li><code>brouter_url</code>: URL des BRouter-Servers.</li> <li><code>max_connection_distance_m</code>: Maximale Distanz zwischen zwei Tracks, um sie automatisch zu verbinden.</li> <li><code>max_chain_length</code>: Maximale Anzahl an Tracks, die f\u00fcr eine Tagesroute verkettet werden.</li> <li><code>start_search_radius_km</code>: Suchradius um den Startpunkt, um den ersten Track zu finden.</li> <li><code>target_search_radius_km</code>: Suchradius um die Unterkunft, um den Ziel-Track zu finden.</li> </ul>"},{"location":"configuration/#passe-passes","title":"P\u00e4sse (<code>passes</code>)","text":"<ul> <li><code>hotel_radius_km</code>: Suchradius um Hotels f\u00fcr P\u00e4sse.</li> <li><code>pass_radius_km</code>: Suchradius um den Pass-Gipfel.</li> <li><code>passes_file</code>: Name der JSON-Datei mit den P\u00e4ssen im GPX-Verzeichnis.</li> </ul>"},{"location":"configuration/#geoapify-geoapify","title":"Geoapify (<code>geoapify</code>)","text":"<ul> <li><code>search_radius_m</code>: Suchradius f\u00fcr Sehensw\u00fcrdigkeiten in Metern.</li> <li><code>max_pois</code>: Maximale Anzahl an Sehensw\u00fcrdigkeiten pro Unterkunft.</li> </ul>"},{"location":"configuration/#export-export","title":"Export (<code>export</code>)","text":"<ul> <li><code>title</code>: Titel des PDF-Berichts.</li> <li><code>excel_info_file</code>: Name einer optionalen Excel-Datei mit Zusatzinformationen.</li> </ul>"},{"location":"configuration/#geheimnisse-secretsenv","title":"Geheimnisse (<code>secrets.env</code>)","text":"<p>F\u00fcr API-Schl\u00fcssel erstellen Sie eine <code>secrets.env</code>-Datei:</p> <pre><code>GEOAPIFY_API_KEY=ihr_api_schl\u00fcssel_hier\n</code></pre>"},{"location":"getting-started/","title":"Schnelleinstieg (5 Minuten)","text":""},{"location":"getting-started/#1-installation","title":"1\ufe0f\u20e3 Installation","text":"<pre><code>git clone https://github.com/dgaida/biketour_planner.git\ncd biketour_planner\npip install -e .\n</code></pre>"},{"location":"getting-started/#2-brouter-starten","title":"2\ufe0f\u20e3 BRouter starten","text":"<pre><code># Lade Routing-Daten f\u00fcr deine Region (z.B. Europa) herunter\nmkdir -p brouter_data\ncd brouter_data\nwget https://brouter.de/brouter/segments4/E10_N45.rd5  # Beispiel: Alpen\n\n# BRouter starten\ndocker run -d -p 17777:17777 \\\n  -v $(pwd):/segments4 \\\n  --name brouter \\\n  brouter/brouter:latest\n</code></pre> <p>Es gibt auch die Datei <code>start_brouter.bat</code>, die den Docker-Container unter Windows startet. Docker muss daf\u00fcr vorher gestartet sein.</p>"},{"location":"getting-started/#3-beispiel-tour-ausfuhren","title":"3\ufe0f\u20e3 Beispiel-Tour ausf\u00fchren","text":"<pre><code># Verzeichnisstruktur erstellen\nmkdir -p my_tour/booking my_tour/gpx\n\n# Legen Sie Ihre Booking.com HTML-Best\u00e4tigungen in my_tour/booking/ ab\n# Legen Sie Ihre GPX-Tracks in my_tour/gpx/ ab\n\n# Planer ausf\u00fchren\npython main.py \\\n  --booking-dir my_tour/booking \\\n  --gpx-dir my_tour/gpx \\\n  --output-dir my_tour/output\n\n# Generiertes PDF \u00f6ffnen\nopen my_tour/output/Reiseplanung_*.pdf\n</code></pre>"},{"location":"getting-started/#nachste-schritte","title":"\ud83c\udfaf N\u00e4chste Schritte","text":"<ul> <li>P\u00e4sse hinzuf\u00fcgen: Erstellen Sie <code>my_tour/gpx/Paesse.json</code> mit Pass-Namen.</li> <li>Sehensw\u00fcrdigkeiten: F\u00fcgen Sie <code>GEOAPIFY_API_KEY</code> zu <code>secrets.env</code> hinzu.</li> <li>Zusatzinfos: Erstellen Sie <code>my_tour/booking/Reiseplanung_Fahrrad.xlsx</code>.</li> </ul> <p>Siehe Workflow-Dokumentation f\u00fcr Details.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#option-1-pip","title":"Option 1: pip","text":"<pre><code># Repository klonen\ngit clone https://github.com/dgaida/biketour_planner.git\ncd biketour_planner\n\n# Abh\u00e4ngigkeiten installieren\npip install -r requirements.txt\n\n# Paket im bearbeitbaren Modus installieren\npip install -e .\n</code></pre>"},{"location":"installation/#option-2-conda-mamba","title":"Option 2: Conda / Mamba","text":"<pre><code># Repository klonen\ngit clone https://github.com/dgaida/biketour_planner.git\ncd biketour_planner\n\n# Umgebung erstellen und aktivieren\nconda env create -f environment.yml\nconda activate biketour_planner\n</code></pre>"},{"location":"installation/#anforderungen","title":"Anforderungen","text":"<p>Python 3.9 oder neuer ist erforderlich.</p>"},{"location":"installation/#optional-entdeckung-von-sehenswurdigkeiten-aktivieren","title":"Optional: Entdeckung von Sehensw\u00fcrdigkeiten aktivieren","text":"<p>Um die Geoapify-Integration f\u00fcr die Suche nach Touristenattraktionen zu nutzen:</p> <ol> <li>Erstellen Sie ein kostenloses Konto unter https://www.geoapify.com</li> <li>Holen Sie sich Ihren API-Schl\u00fcssel (kostenloses Kontingent: 3.000 Anfragen/Tag)</li> <li>Erstellen Sie eine <code>secrets.env</code>-Datei im Projektstamm:</li> </ol> <pre><code>GEOAPIFY_API_KEY=ihr_api_schl\u00fcssel_hier\n</code></pre>"},{"location":"installation/#brouter-setup-erforderlich","title":"BRouter Setup (Erforderlich)","text":"<p>Der Bike Tour Planner verl\u00e4sst sich auf BRouter f\u00fcr das Offline-Fahrrad-Routing.</p> <p>BRouter ist eine Open-Source-Routing-Engine, die von Arne Brenschede entwickelt wurde: \ud83d\udc49 https://github.com/abrensch/brouter</p>"},{"location":"installation/#1-routing-daten-herunterladen-rd5-dateien","title":"1. Routing-Daten herunterladen (<code>.rd5</code>-Dateien)","text":"<p>BRouter verwendet vorverarbeitete OpenStreetMap-Daten, die in 5\u00b0 \u00d7 5\u00b0 Kacheln unterteilt sind.</p> <p>Laden Sie die ben\u00f6tigten <code>.rd5</code>-Dateien herunter von:</p> <pre><code>https://brouter.de/brouter/segments4/\n</code></pre> <p>Legen Sie diese in einem lokalen Verzeichnis ab, zum Beispiel:</p> <pre><code>C:/brouter/segments4/\n</code></pre> <p>Stellen Sie sicher, dass Sie alle Kacheln herunterladen, die Ihr Tourengebiet abdecken.</p>"},{"location":"installation/#2-brouter-uber-docker-starten","title":"2. BRouter \u00fcber Docker starten","text":"<p>Ein laufender BRouter-HTTP-Server ist erforderlich.</p>"},{"location":"installation/#verwendung-von-docker-empfohlen","title":"Verwendung von Docker (empfohlen):","text":"<pre><code>docker run --rm -p 17777:17777 \\\n  -v C:/brouter/segments4:/segments4 \\\n  brouter\n</code></pre>"},{"location":"installation/#oder-aus-dem-bereitgestellten-dockerfile-bauen","title":"Oder aus dem bereitgestellten Dockerfile bauen:","text":"<pre><code>cd brouter_docker\ndocker build -t brouter .\ndocker run --rm -p 17777:17777 \\\n  -v C:/brouter/segments4:/segments4 \\\n  brouter\n</code></pre> <p>Der Dienst wird verf\u00fcgbar sein unter:</p> <pre><code>http://localhost:17777\n</code></pre> <p>Sie k\u00f6nnen ihn testen mit:</p> <pre><code>curl \"http://localhost:17777/brouter?lonlats=16.44,43.51|18.09,42.65&amp;profile=trekking&amp;format=gpx\"\n</code></pre>"},{"location":"troubleshooting/","title":"Fehlerbehebung","text":""},{"location":"troubleshooting/#haufige-probleme","title":"H\u00e4ufige Probleme","text":""},{"location":"troubleshooting/#brouter-nicht-erreichbar","title":"BRouter nicht erreichbar","text":"<p>Symptom: Fehlermeldung bez\u00fcglich Verbindung zu <code>localhost:17777</code>.</p> <p>L\u00f6sung: 1. Stellen Sie sicher, dass der BRouter-Docker-Container l\u00e4uft: <code>docker ps</code>. 2. Pr\u00fcfen Sie, ob der Port 17777 gemappt ist. 3. Kontrollieren Sie, ob die ben\u00f6tigten <code>.rd5</code>-Kacheln im gemounteten Verzeichnis vorhanden sind.</p>"},{"location":"troubleshooting/#geokodierung-schlagt-fehl","title":"Geokodierung schl\u00e4gt fehl","text":"<p>Symptom: Unterkunft hat keine Koordinaten (0.0, 0.0) oder Fehler bei der Adresssuche.</p> <p>L\u00f6sung: 1. \u00dcberpr\u00fcfen Sie die Adresse in der HTML-Datei. Manchmal sind Namen von Unterk\u00fcnften in den Best\u00e4tigungs-E-Mails nicht eindeutig genug. 2. Versuchen Sie, die Adresse in <code>geocode.py</code> manuell zu testen oder passen Sie sie in der Quelldatei an.</p>"},{"location":"troubleshooting/#gpx-tracks-werden-nicht-verbunden","title":"GPX-Tracks werden nicht verbunden","text":"<p>Symptom: Routen zwischen Unterk\u00fcnften fehlen oder sind unvollst\u00e4ndig.</p> <p>L\u00f6sung: 1. Pr\u00fcfen Sie den <code>max_connection_distance_m</code> Parameter in der Konfiguration. Wenn Ihre Tracks zu weit auseinander liegen, werden sie nicht automatisch verbunden. 2. Stellen Sie sicher, dass alle GPX-Dateien im konfigurierten Verzeichnis liegen. 3. Pr\u00fcfen Sie die Logs auf \"No tracks found within radius\".</p>"},{"location":"troubleshooting/#logs-einsehen","title":"Logs einsehen","text":"<p>Logs werden standardm\u00e4\u00dfig in den Ordner <code>logs/</code> geschrieben. Erh\u00f6hen Sie den Log-Level in der Konfiguration auf <code>DEBUG</code> f\u00fcr detailliertere Informationen.</p>"},{"location":"api/","title":"API-Referenz","text":"<p>Diese Dokumentation wird automatisch aus den Docstrings des Quellcodes generiert.</p>"},{"location":"api/#core-module","title":"Core Module","text":""},{"location":"api/#biketour_planner.gpx_route_manager","title":"<code>biketour_planner.gpx_route_manager</code>","text":""},{"location":"api/#biketour_planner.gpx_route_manager-classes","title":"Classes","text":""},{"location":"api/#biketour_planner.gpx_route_manager.GPXRouteManager","title":"<code>GPXRouteManager</code>","text":"<p>Manages GPX routes and enables chaining of tracks between locations.</p> <p>This class implements an intelligent algorithm for route planning of multi-day bike tours. The core algorithm works as follows:</p> <ol> <li> <p>Target Side Determination: Finds out which side (start or end) of the    target track is closer to the starting point. This is crucial for    determining the correct direction of travel through intermediate tracks.</p> </li> <li> <p>Start Point Optimization: In the start track, the algorithm does not    simply navigate to the point closest to the target, but to the point    closest to the relevant target side. This prevents inefficient routes.</p> </li> <li> <p>Track Chaining: Connects multiple GPX tracks considering:</p> </li> <li>Spatial proximity (max_connection_distance_m)</li> <li>Avoiding duplicates (same base filenames)</li> <li> <p>Continuing previous routes (for multi-day tours)</p> </li> <li> <p>Direction Detection: Automatically determines whether a track must be    traversed forward or backward.</p> </li> </ol> <p>Attributes:</p> Name Type Description <code>gpx_dir</code> <p>Directory with GPX files.</p> <code>gpx_index</code> <code>GPXIndex</code> <p>Preprocessed metadata of all GPX files with start/end points,        distances, elevation profiles, and all track points.</p> <code>max_connection_distance_m</code> <p>Maximum distance in meters for automatic                        chaining of tracks. Tracks further apart will                        not be connected.</p> <code>max_chain_length</code> <p>Maximum number of tracks to chain. Prevents infinite              loops during routing problems.</p> <code>verbose</code> <p>If True, enables detailed logging.</p> Source code in <code>src/biketour_planner/gpx_route_manager.py</code> <pre><code>class GPXRouteManager:\n    \"\"\"Manages GPX routes and enables chaining of tracks between locations.\n\n    This class implements an intelligent algorithm for route planning of\n    multi-day bike tours. The core algorithm works as follows:\n\n    1. **Target Side Determination**: Finds out which side (start or end) of the\n       target track is closer to the starting point. This is crucial for\n       determining the correct direction of travel through intermediate tracks.\n\n    2. **Start Point Optimization**: In the start track, the algorithm does not\n       simply navigate to the point closest to the target, but to the point\n       closest to the relevant target side. This prevents inefficient routes.\n\n    3. **Track Chaining**: Connects multiple GPX tracks considering:\n       - Spatial proximity (max_connection_distance_m)\n       - Avoiding duplicates (same base filenames)\n       - Continuing previous routes (for multi-day tours)\n\n    4. **Direction Detection**: Automatically determines whether a track must be\n       traversed forward or backward.\n\n    Attributes:\n        gpx_dir: Directory with GPX files.\n        gpx_index: Preprocessed metadata of all GPX files with start/end points,\n                   distances, elevation profiles, and all track points.\n        max_connection_distance_m: Maximum distance in meters for automatic\n                                   chaining of tracks. Tracks further apart will\n                                   not be connected.\n        max_chain_length: Maximum number of tracks to chain. Prevents infinite\n                         loops during routing problems.\n        verbose: If True, enables detailed logging.\n    \"\"\"\n\n    def __init__(\n        self,\n        gpx_dir: Path,\n        output_path: Path,\n        max_connection_distance_m: float | None = None,\n        max_chain_length: int | None = None,\n        start_search_radius_km: float | None = None,\n        verbose: bool = False,\n    ):\n        \"\"\"Initializes the GPXRouteManager and loads all GPX files.\n\n        Args:\n            gpx_dir: Directory with GPX files.\n            output_path: Output directory for merged files.\n            max_connection_distance_m: Max distance for track chaining in meters.\n                                       Default from config if None.\n            max_chain_length: Maximum number of tracks to chain. Default from config if None.\n            start_search_radius_km: Search radius for start track in km.\n                                   Default from config if None.\n            verbose: Enable detailed logging.\n        \"\"\"\n        config = get_config()\n\n        self.gpx_dir = gpx_dir\n        self.output_path = output_path\n        self.verbose = verbose\n\n        self.max_connection_distance_m = (\n            max_connection_distance_m if max_connection_distance_m is not None else config.routing.max_connection_distance_m\n        )\n        self.max_chain_length = max_chain_length if max_chain_length is not None else config.routing.max_chain_length\n        self.start_search_radius_km = (\n            start_search_radius_km if start_search_radius_km is not None else config.routing.start_search_radius_km\n        )\n        self.target_search_radius_km = config.routing.target_search_radius_km\n\n        self.gpx_index: GPXIndex = {}\n        self._preprocess_gpx_directory()\n\n    def _preprocess_gpx_directory(self) -&gt; None:\n        \"\"\"Reads all GPX files exactly once and stores relevant metadata.\n\n        This preprocessing avoids repeatedly parsing the same GPX files during\n        route search and significantly speeds up processing.\n\n        Note:\n            Files that cannot be parsed are silently skipped.\n        \"\"\"\n        gpx_files = list(Path(self.gpx_dir).glob(\"*.gpx\"))\n\n        def process_file(gpx_file: Path) -&gt; tuple[str, dict[str, Any]] | None:\n            gpx = read_gpx_file(gpx_file)\n            if gpx is None or not gpx.tracks:\n                return None\n\n            first_point = None\n            last_point = None\n            all_points = []\n\n            point_index = 0\n            for track in gpx.tracks:\n                for seg in track.segments:\n                    for p in seg.points:\n                        if first_point is None:\n                            first_point = p\n                        last_point = p\n                        all_points.append(\n                            {\"lat\": p.latitude, \"lon\": p.longitude, \"elevation\": p.elevation, \"index\": point_index}\n                        )\n                        point_index += 1\n\n            max_elevation, total_distance, total_ascent, total_descent = get_statistics4track(gpx)\n\n            if first_point is None or last_point is None:\n                return None\n\n            return gpx_file.name, {\n                \"file\": gpx_file,\n                \"start_lat\": first_point.latitude,\n                \"start_lon\": first_point.longitude,\n                \"end_lat\": last_point.latitude,\n                \"end_lon\": last_point.longitude,\n                \"total_distance_m\": total_distance,\n                \"total_ascent_m\": total_ascent,\n                \"max_elevation_m\": (int(round(max_elevation)) if max_elevation != float(\"-inf\") else None),\n                \"points\": all_points,\n            }\n\n        with ThreadPoolExecutor(max_workers=4) as executor:\n            results = executor.map(process_file, gpx_files)\n\n        for result in results:\n            if result:\n                filename, metadata = result\n                self.gpx_index[filename] = metadata\n\n    def _find_start_pos(\n        self,\n        start_lat: float,\n        start_lon: float,\n        target_lat: float,\n        target_lon: float,\n        previous_last_file: dict[str, Any] | None = None,\n    ) -&gt; tuple[str | None, int | None, str | None]:\n        \"\"\"Determines the starting position for the route search.\n\n        If multiple tracks are within the search radius of the starting location,\n        the one whose start or end point is closer to the target location is chosen.\n        This optimizes route planning by ensuring the start track already points\n        in the right direction.\n\n        If a previous route exists (multi-day tour), it is continued.\n        In this case, the previous day's direction of travel is enforced to\n        ensure consistent routes.\n\n        Args:\n            start_lat: Latitude of the start point in decimal degrees.\n            start_lon: Longitude of the start point in decimal degrees.\n            target_lat: Latitude of the target point in decimal degrees.\n            target_lon: Longitude of the target point in decimal degrees.\n            previous_last_file: Optional. Dictionary of the last GPX file used\n                            the previous day with keys:\n                            - 'file' (str): filename\n                            - 'end_index' (int): last index used\n                            - 'reversed' (bool): whether track was traversed backward\n\n        Returns:\n            Tuple of:\n                - start_file (str): filename of the starting GPX file.\n                - start_index (int): starting index in the track.\n                - force_direction (str|None): enforced direction ('forward'/'backward')\n                  if continuation from previous day, else None.\n        \"\"\"\n        if previous_last_file:\n            filename = previous_last_file[\"file\"]\n            meta = self.gpx_index.get(filename)\n            if meta:\n                start_file = filename\n                start_index = previous_last_file[\"end_index\"]\n                last_point = meta[\"points\"][start_index]\n                start_distance = haversine(start_lat, start_lon, last_point[\"lat\"], last_point[\"lon\"])\n\n                force_direction = \"backward\" if previous_last_file.get(\"reversed\", False) else \"forward\"\n\n                logger.debug(f\"\ud83d\udd17 Continuation detected: {start_file} from index {start_index}\")\n                logger.debug(f\"\ud83d\udd17 Enforced direction: {force_direction} (from previous day)\")\n                logger.debug(f\"\ud83d\udd17 Distance to continuation point: {start_distance:.1f}m\")\n\n                return start_file, start_index, force_direction\n\n        candidates = []\n        start_radius_m = self.start_search_radius_km * 1000\n\n        for filename, meta in self.gpx_index.items():\n            idx, dist_to_start = find_closest_point_in_track(meta[\"points\"], start_lat, start_lon)\n            if dist_to_start &gt; start_radius_m:\n                continue\n\n            dist_track_start_to_target = haversine(meta[\"start_lat\"], meta[\"start_lon\"], target_lat, target_lon)\n            dist_track_end_to_target = haversine(meta[\"end_lat\"], meta[\"end_lon\"], target_lat, target_lon)\n            min_dist_to_target = min(dist_track_start_to_target, dist_track_end_to_target)\n\n            candidates.append(\n                {\"filename\": filename, \"index\": idx, \"dist_to_start\": dist_to_start, \"dist_to_target\": min_dist_to_target}\n            )\n\n            if self.verbose:\n                logger.debug(\n                    f\"   Candidate: {filename}, \"\n                    f\"Dist to start: {dist_to_start:.0f}m, \"\n                    f\"Min-dist to target: {min_dist_to_target:.0f}m\"\n                )\n\n        if not candidates:\n            logger.warning(\"\u26a0\ufe0f  No tracks found within radius!\")\n            return None, None, None\n\n        # Sort by distance to target (primary), then by distance to start (secondary)\n        best = min(candidates, key=lambda c: (c[\"dist_to_target\"], c[\"dist_to_start\"]))\n\n        logger.info(f\"\u2705 Selected start track: {best['filename']}\")\n        logger.debug(\n            f\"   \ud83d\udccd Start index: {best['index']}, \"\n            f\"Dist to start: {best['dist_to_start']:.0f}m, \"\n            f\"Dist to target: {best['dist_to_target']:.0f}m\"\n        )\n\n        return best[\"filename\"], best[\"index\"], None\n\n    def _find_target_pos(\n        self,\n        start_lat: float,\n        start_lon: float,\n        target_lat: float,\n        target_lon: float,\n    ) -&gt; tuple[str | None, int | None, float | None, float | None]:\n        \"\"\"Determines the target position and the relevant target side for the route search.\n\n        This method implements the central logic for efficient routing:\n        1. Finds the track closest to the target (within target_search_radius_km).\n        2. Determines which side of this track (start or end) is closer to the start point.\n        3. This \"target side\" becomes the reference for all intermediate steps.\n\n        Args:\n            start_lat: Latitude of the start point in decimal degrees.\n            start_lon: Longitude of the start point in decimal degrees.\n            target_lat: Latitude of the target point (accommodation) in decimal degrees.\n            target_lon: Longitude of the target point (accommodation) in decimal degrees.\n\n        Returns:\n            Tuple of:\n                - target_file (str): filename of the target GPX file.\n                - target_index (int): index of the point closest to the target.\n                - target_side_lat (float): latitude of the relevant target side.\n                - target_side_lon (float): longitude of the relevant target side.\n        \"\"\"\n        target_file = None\n        target_index = None\n        target_distance = float(\"inf\")\n        start_point = None\n        end_point = None\n        target_radius_m = self.target_search_radius_km * 1000\n\n        for filename, meta in self.gpx_index.items():\n            idx, dist = find_closest_point_in_track(meta[\"points\"], target_lat, target_lon)\n            if dist &lt; target_distance and dist &lt;= target_radius_m:\n                target_distance = dist\n                target_file = filename\n                target_index = idx\n                start_point = meta[\"points\"][0]\n                end_point = meta[\"points\"][-1]\n\n        if not target_file:\n            logger.warning(f\"\u26a0\ufe0f  No target track found within {self.target_search_radius_km}km!\")\n            return None, None, None, None\n\n        dist_to_start = haversine(start_lat, start_lon, start_point[\"lat\"], start_point[\"lon\"])\n        dist_to_end = haversine(start_lat, start_lon, end_point[\"lat\"], end_point[\"lon\"])\n\n        if dist_to_start &lt; dist_to_end:\n            target_side_lat = start_point[\"lat\"]\n            target_side_lon = start_point[\"lon\"]\n            logger.debug(f\"\ud83c\udfaf Target track {target_file}: Start side closer to start location\")\n        else:\n            target_side_lat = end_point[\"lat\"]\n            target_side_lon = end_point[\"lon\"]\n            logger.debug(f\"\ud83c\udfaf Target track {target_file}: End side closer to start location\")\n\n        logger.debug(f\"\ud83c\udfaf Target: {target_file} (Index {target_index}, Distance: {target_distance:.1f}m)\")\n        logger.debug(f\"\ud83c\udfaf Target side position: ({target_side_lat:.6f}, {target_side_lon:.6f})\")\n\n        return target_file, target_index, target_side_lat, target_side_lon\n\n    def _init_end_index(\n        self,\n        current_index: int,\n        meta: dict[str, Any],\n        force_direction: str,\n        target_side_lat: float,\n        target_side_lon: float,\n    ) -&gt; int:\n        \"\"\"Initializes the end index when the driving direction is forced (multi-day tour continuation).\n\n        In multi-day tours, the direction from the previous day must be maintained.\n        This method finds the point in the forced direction that is closest to\n        the relevant target side.\n\n        Args:\n            current_index: Current starting index in the track.\n            meta: Metadata of the current GPX track.\n            force_direction: Forced direction - either 'forward' or 'backward'.\n            target_side_lat: Latitude of the relevant target side.\n            target_side_lon: Longitude of the relevant target side.\n\n        Returns:\n            Calculated end index in the track.\n        \"\"\"\n        best_idx = current_index\n        best_dist = float(\"inf\")\n\n        for point in meta[\"points\"]:\n            if force_direction == \"forward\" and point[\"index\"] &lt;= current_index:\n                continue\n            if force_direction == \"backward\" and point[\"index\"] &gt;= current_index:\n                continue\n            dist = haversine(target_side_lat, target_side_lon, point[\"lat\"], point[\"lon\"])\n            if dist &lt; best_dist:\n                best_dist = dist\n                best_idx = point[\"index\"]\n\n        if self.verbose:\n            direction_str = \"Forward\" if force_direction == \"forward\" else \"Backward\"\n            logger.debug(f\"   \ud83d\udd0d {direction_str} (forced): Index {best_idx} (Distance: {best_dist:.1f}m)\")\n\n        return best_idx\n\n    def _set_end_index(\n        self,\n        current_index: int,\n        meta: dict[str, Any],\n        force_direction: str | None,\n        target_side_lat: float,\n        target_side_lon: float,\n        iteration: int,\n    ) -&gt; int:\n        \"\"\"Determines the end index for the current track section.\n\n        In the first iteration with a continuation from the previous day, the\n        forced direction is used. In all other cases, the point in the entire\n        track closest to the target side is searched (independent of the\n        direction of travel).\n\n        Args:\n            current_index: Current starting index in the track.\n            meta: Metadata of the current GPX track.\n            force_direction: Optional forced direction ('forward'/'backward').\n            target_side_lat: Latitude of the relevant target side.\n            target_side_lon: Longitude of the relevant target side.\n            iteration: Current iteration number (0-based).\n\n        Returns:\n            Calculated end index in the track.\n        \"\"\"\n        if iteration == 0 and force_direction is not None:\n            return self._init_end_index(current_index, meta, force_direction, target_side_lat, target_side_lon)\n        else:\n            idx, best_dist = find_closest_point_in_track(meta[\"points\"], target_side_lat, target_side_lon)\n            if self.verbose:\n                logger.debug(f\"   \ud83d\udd0d Closest point to target side: Index {idx} (Distance: {best_dist:.1f}m)\")\n            return idx\n\n    def _get_statistics4track(\n        self,\n        meta: dict[str, Any],\n        current_index: int,\n        end_index: int,\n        max_elevation: float,\n        total_distance: float,\n        total_ascent: float,\n        total_descent: float,\n        reversed_direction: bool,\n    ) -&gt; tuple[float, float, float, float]:\n        \"\"\"Calculates statistics for a track section between two indices.\n\n        Args:\n            meta: Metadata of the GPX track.\n            current_index: Start index of the section.\n            end_index: End index of the section.\n            max_elevation: Previous max elevation in meters (will be updated).\n            total_distance: Previous total distance in meters (will be updated).\n            total_ascent: Previous total ascent in meters (will be updated).\n            total_descent: Previous total descent in meters (will be updated).\n            reversed_direction: If True, section is traversed backward.\n\n        Returns:\n            Tuple of (max_elevation, total_distance, total_ascent, total_descent)\n            with updated values.\n        \"\"\"\n        mystart_index = min(current_index, end_index)\n        myend_index = max(current_index, end_index)\n\n        gpx = read_gpx_file(meta[\"file\"])\n        if gpx:\n            return get_statistics4track(\n                gpx, mystart_index, myend_index, max_elevation, total_distance, total_ascent, total_descent, reversed_direction\n            )\n        return max_elevation, total_distance, total_ascent, total_descent\n\n    def _find_next_gpx_file(\n        self,\n        visited: set[str],\n        used_base_files: set[str],\n        current_lat: float,\n        current_lon: float,\n    ) -&gt; tuple[str | None, int | None]:\n        \"\"\"Finds the next GPX file in the route chain.\n\n        Args:\n            visited: Set of already visited filenames to avoid loops.\n            used_base_files: Set of already used base filenames to prevent using\n                            the same track in different directions.\n            current_lat: Current latitude in decimal degrees.\n            current_lon: Current longitude in decimal degrees.\n\n        Returns:\n            Tuple of:\n                - next_file (str|None): filename of the next GPX file.\n                - next_index (int|None): starting index in the next track.\n        \"\"\"\n        next_file = None\n        next_index = None\n        best_dist = float(\"inf\")\n        best_length = float(\"inf\")\n\n        if self.verbose:\n            logger.debug(\"   Searching for next GPX file...\")\n\n        for name, meta in self.gpx_index.items():\n            if name in visited:\n                continue\n            if get_base_filename(name) in used_base_files:\n                continue\n\n            idx, dist = find_closest_point_in_track(meta[\"points\"], current_lat, current_lon)\n\n            if self.verbose:\n                logger.debug(f\"      {meta['total_distance_m']:.0f}m {name} {dist:.1f}m\")\n\n            if dist &gt; self.max_connection_distance_m:\n                continue\n\n            length = meta[\"total_distance_m\"]\n            if dist &lt; best_dist or (dist &lt;= best_dist + 300 and length &lt; best_length):\n                best_dist = dist\n                next_file = name\n                next_index = idx\n                best_length = length\n\n        if next_file:\n            logger.debug(f\"   \u27a1\ufe0f  Next: {next_file} (Index {next_index}, Distance: {best_dist:.1f}m)\")\n\n        return next_file, next_index\n\n    def _process_route_iteration(\n        self,\n        iteration: int,\n        current_file: str,\n        current_index: int,\n        target_file: str,\n        target_index: int,\n        visited: set[str],\n        used_base_files: set[str],\n        route_files: list[dict[str, Any]],\n        force_direction: str | None,\n        target_side_lat: float,\n        target_side_lon: float,\n        max_elevation: float,\n        total_distance: float,\n        total_ascent: float,\n        total_descent: float,\n    ) -&gt; tuple[bool, str | None, int | None, float, float, float, float, float, float]:\n        \"\"\"Processes a single iteration of the route search (compatibility wrapper).\n\n        Args:\n            iteration: Current iteration number.\n            current_file: Name of current GPX file.\n            current_index: Current start index in the track.\n            target_file: Name of target GPX file.\n            target_index: Index of target point.\n            visited: Set of visited files.\n            used_base_files: Set of used base filenames.\n            route_files: List of route segments.\n            force_direction: Optional forced direction.\n            target_side_lat: Latitude of target side.\n            target_side_lon: Longitude of target side.\n            max_elevation: Current max elevation.\n            total_distance: Current total distance.\n            total_ascent: Current total ascent.\n            total_descent: Current total descent.\n\n        Returns:\n            Tuple with continue flag, next file/index, updated position and stats.\n        \"\"\"\n        current = RoutePosition(file=current_file, index=current_index, lat=0, lon=0)\n        target = RoutePosition(file=target_file, index=target_index, lat=target_side_lat, lon=target_side_lon)\n        context = RouteContext(\n            iteration=iteration,\n            target=target,\n            visited=visited,\n            used_base_files=used_base_files,\n            route_files=route_files,\n            force_direction=force_direction,\n        )\n        stats = RouteStatistics(\n            max_elevation=max_elevation, total_distance=total_distance, total_ascent=total_ascent, total_descent=total_descent\n        )\n\n        should_continue, next_pos, updated_stats = self._process_route_iteration_new(current, context, stats)\n\n        next_file = next_pos.file if next_pos else None\n        next_index = next_pos.index if next_pos else None\n\n        meta = self.gpx_index.get(current_file)\n        if meta:\n            if current_file == target_file:\n                end_index = target_index\n            else:\n                end_index = self._set_end_index(\n                    current_index, meta, force_direction, target_side_lat, target_side_lon, iteration\n                )\n            end_pt = meta[\"points\"][end_index]\n            current_lat, current_lon = end_pt[\"lat\"], end_pt[\"lon\"]\n        else:\n            current_lat, current_lon = 0, 0\n\n        return (\n            should_continue,\n            next_file,\n            next_index,\n            current_lat,\n            current_lon,\n            updated_stats.max_elevation,\n            updated_stats.total_distance,\n            updated_stats.total_ascent,\n            updated_stats.total_descent,\n        )\n\n    def _process_route_iteration_new(\n        self,\n        current: RoutePosition,\n        context: RouteContext,\n        stats: RouteStatistics,\n    ) -&gt; tuple[bool, RoutePosition | None, RouteStatistics]:\n        \"\"\"Processes a single iteration of the route search.\n\n        Performs the following steps for a single track section:\n        1. Validation (already visited? metadata available?)\n        2. Determination of the end index (where to go in the track?)\n        3. Determination of the travel direction (forward/backward)\n        4. Update of statistics (distance, elevation)\n        5. Search for the next track (if target not yet reached)\n\n        Args:\n            current: Current position in route calculation.\n            context: Context for route iteration.\n            stats: Accumulated route statistics.\n\n        Returns:\n            Tuple of:\n                - should_continue (bool): True if more iterations are needed.\n                - next_pos (RoutePosition|None): Next position to start from.\n                - stats (RouteStatistics): Updated statistics.\n        \"\"\"\n        # Validations\n        if current.file in context.visited:\n            logger.debug(f\"\u26a0\ufe0f  Iteration {context.iteration + 1}: File {current.file} already visited - aborting\")\n            return False, None, stats\n\n        meta = self.gpx_index.get(current.file)\n        if not meta:\n            logger.debug(f\"\u26a0\ufe0f  Iteration {context.iteration + 1}: No metadata for {current.file} - aborting\")\n            return False, None, stats\n\n        base_name = get_base_filename(current.file)\n        if base_name in context.used_base_files:\n            logger.debug(f\"\u26a0\ufe0f  Iteration {context.iteration + 1}: Base file {base_name} already used - aborting\")\n            return False, None, stats\n\n        logger.debug(f\"\ud83d\udcc1 Iteration {context.iteration + 1}: {current.file} (current index: {current.index})\")\n\n        # Determine end index\n        if current.file == context.target.file:\n            end_index = context.target.index\n            logger.debug(f\"   \u2705 Target file reached! Going to index {end_index}\")\n            should_stop = True\n        else:\n            end_index = self._set_end_index(\n                current.index, meta, context.force_direction, context.target.lat, context.target.lon, context.iteration\n            )\n            should_stop = False\n\n        # Determine direction\n        reversed_dir = current.index &gt; end_index\n        direction_str = \"backward\" if reversed_dir else \"forward\"\n        logger.debug(f\"   Direction: {direction_str} (Index {current.index} -&gt; {end_index})\")\n\n        # Mark as visited\n        context.visited.add(current.file)\n        context.used_base_files.add(base_name)\n\n        # Add to route\n        context.route_files.append(\n            {\"file\": current.file, \"start_index\": current.index, \"end_index\": end_index, \"reversed\": reversed_dir}\n        )\n\n        # Update statistics\n        max_el, dist, asc, desc = self._get_statistics4track(\n            meta,\n            current.index,\n            end_index,\n            stats.max_elevation,\n            stats.total_distance,\n            stats.total_ascent,\n            stats.total_descent,\n            reversed_dir,\n        )\n        stats.max_elevation = max_el\n        stats.total_distance = dist\n        stats.total_ascent = asc\n        stats.total_descent = desc\n\n        # Update position\n        end_pt = meta[\"points\"][end_index]\n        current_lat, current_lon = end_pt[\"lat\"], end_pt[\"lon\"]\n        logger.debug(f\"   New position: ({current_lat:.6f}, {current_lon:.6f})\")\n\n        if should_stop:\n            print(\"\u2705 Target reached!\")\n            return False, None, stats\n\n        # Find next GPX\n        next_file, next_index = self._find_next_gpx_file(context.visited, context.used_base_files, current_lat, current_lon)\n\n        if not next_file:\n            logger.debug(f\"\u26a0\ufe0f  No suitable next GPX found (max distance: {self.max_connection_distance_m}m)\")\n            if context.target.file not in context.visited:\n                self._add_target_track_to_route(\n                    context.target.file, context.target.index, current_lat, current_lon, context.route_files\n                )\n            return False, None, stats\n\n        next_pt = self.gpx_index[next_file][\"points\"][next_index]\n        next_pos = RoutePosition(file=next_file, index=next_index, lat=next_pt[\"lat\"], lon=next_pt[\"lon\"])\n        return True, next_pos, stats\n\n    def _add_target_track_to_route(\n        self,\n        target_file: str,\n        target_index: int,\n        current_lat: float,\n        current_lon: float,\n        route_files: list[dict[str, Any]],\n    ) -&gt; None:\n        \"\"\"Adds the target track to the route when no intermediate track is found.\n\n        This method is called when the automatic route search finds no more\n        suitable intermediate tracks, but the target track has not yet been\n        reached. The target track is then directly appended.\n\n        Args:\n            target_file: Filename of the target GPX file.\n            target_index: Index of the target point (accommodation) in the target track.\n            current_lat: Current latitude in decimal degrees.\n            current_lon: Current longitude in decimal degrees.\n            route_files: List of route dictionaries to be extended.\n        \"\"\"\n        logger.debug(f\"   \u2795 Adding target track: {target_file}\")\n        meta = self.gpx_index[target_file]\n\n        dist_to_start = haversine(current_lat, current_lon, meta[\"points\"][0][\"lat\"], meta[\"points\"][0][\"lon\"])\n        dist_to_end = haversine(current_lat, current_lon, meta[\"points\"][-1][\"lat\"], meta[\"points\"][-1][\"lon\"])\n\n        if dist_to_end &lt; dist_to_start:\n            start_idx = len(meta[\"points\"]) - 1\n            reversed_dir = True\n        else:\n            start_idx = 0\n            reversed_dir = False\n\n        route_files.append(\n            {\n                \"file\": target_file,\n                \"start_index\": min(start_idx, target_index) if not reversed_dir else max(start_idx, target_index),\n                \"end_index\": target_index,\n                \"reversed\": reversed_dir,\n            }\n        )\n\n    def collect_route_between_locations(\n        self,\n        start_lat: float,\n        start_lon: float,\n        target_lat: float,\n        target_lon: float,\n        booking: dict[str, Any],\n        previous_last_file: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"Calculates and chains GPX files between start and target locations.\n\n        This is the main method for route planning. It implements an intelligent\n        algorithm for chaining multiple GPX tracks.\n\n        Args:\n            start_lat: Latitude of the start location.\n            start_lon: Longitude of the start location.\n            target_lat: Latitude of the target location (accommodation).\n            target_lon: Longitude of the target location (accommodation).\n            booking: Booking/Day dictionary to be enriched with route information.\n            previous_last_file: Optional. Dictionary of the last used GPX file\n                               from the previous day.\n        \"\"\"\n        logger.info(f\"\\n{'=' * 80}\")\n        logger.info(f\"Route search: ({start_lat:.6f}, {start_lon:.6f}) -&gt; ({target_lat:.6f}, {target_lon:.6f})\")\n        if previous_last_file:\n            logger.info(f\"\ud83d\udd17 Continuation from: {previous_last_file['file']} (Index {previous_last_file['end_index']})\")\n        logger.info(f\"{'=' * 80}\")\n\n        start_file, start_idx, force_dir = self._find_start_pos(\n            start_lat, start_lon, target_lat, target_lon, previous_last_file\n        )\n        target_file, target_idx, target_side_lat, target_side_lon = self._find_target_pos(\n            start_lat, start_lon, target_lat, target_lon\n        )\n\n        if not start_file or not target_file:\n            logger.warning(\"\u26a0\ufe0f  No matching GPX files found!\")\n            booking.update({\"gpx_files\": [], \"total_distance_km\": 0, \"total_ascent_m\": 0, \"max_elevation_m\": None})\n            return\n\n        start_pt = self.gpx_index[start_file][\"points\"][start_idx]\n        start_pos = RoutePosition(file=start_file, index=start_idx, lat=start_pt[\"lat\"], lon=start_pt[\"lon\"])\n        target_pos = RoutePosition(file=target_file, index=target_idx, lat=target_side_lat, lon=target_side_lon)\n\n        context = RouteContext(iteration=0, target=target_pos, force_direction=force_dir)\n        stats = RouteStatistics()\n        current_pos = start_pos\n\n        for i in range(self.max_chain_length):\n            context.iteration = i\n            should_continue, current_pos, stats = self._process_route_iteration_new(current_pos, context, stats)\n            if not should_continue:\n                break\n\n        logger.info(\"\\n\ud83d\udcca Summary:\")\n        logger.info(f\"   Files: {len(context.route_files)}\")\n        logger.info(f\"   Total distance: {stats.total_distance / 1000:.2f} km\")\n        logger.info(f\"   Total ascent: {stats.total_ascent:.0f} m\")\n        logger.info(f\"   Max elevation: {stats.max_elevation:.0f} m\" if stats.max_elevation != 0 else \"   Max elevation: N/A\")\n        logger.info(f\"{'=' * 80}\\n\")\n\n        booking[\"gpx_files\"] = context.route_files\n        booking[\"total_distance_km\"] = round(stats.total_distance / 1000, 2)\n        booking[\"total_ascent_m\"] = int(round(stats.total_ascent))\n        booking[\"total_descent_m\"] = int(round(stats.total_descent))\n        booking[\"max_elevation_m\"] = int(round(stats.max_elevation)) if stats.max_elevation != 0 else None\n\n        if context.route_files:\n            last = context.route_files[-1]\n            booking[\"_last_gpx_file\"] = {\"file\": last[\"file\"], \"end_index\": last[\"end_index\"], \"reversed\": last[\"reversed\"]}\n\n    def merge_gpx_files(self, route_files: list[dict[str, Any]], output_dir: Path, booking: dict[str, Any]) -&gt; Path | None:\n        \"\"\"Merges multiple GPX track segments into a single GPX file.\n\n        Args:\n            route_files: List of dictionaries with track section information.\n            output_dir: Output directory for the merged GPX file.\n            booking: Booking dictionary for filename generation.\n\n        Returns:\n            Path to the written GPX file or None on error.\n        \"\"\"\n        if not route_files:\n            logger.warning(f\"route_files is empty or None: {route_files}\")\n            return None\n\n        merged_gpx = gpxpy.gpx.GPX()\n        track = gpxpy.gpx.GPXTrack()\n        merged_gpx.tracks.append(track)\n        segment = gpxpy.gpx.GPXTrackSegment()\n        track.segments.append(segment)\n\n        for i, entry in enumerate(route_files):\n            if i == len(route_files) - 1 and entry.get(\"is_to_hotel\"):\n                gpx_file = output_dir / entry[\"file\"]\n            else:\n                gpx_file = self.gpx_dir / entry[\"file\"]\n                if not gpx_file.exists():\n                    gpx_file = output_dir / entry[\"file\"]\n\n            if not gpx_file.exists():\n                logger.warning(f\"\u26a0\ufe0f  File not found: {entry['file']}\")\n                continue\n\n            gpx = read_gpx_file(gpx_file)\n            if not gpx or not gpx.tracks:\n                continue\n\n            s_idx, e_idx = entry[\"start_index\"], entry[\"end_index\"]\n            rev = entry[\"reversed\"]\n            if rev:\n                s_idx, e_idx = e_idx, s_idx\n\n            all_pts = []\n            cnt = 0\n            for trk in gpx.tracks:\n                for seg in trk.segments:\n                    for p in seg.points:\n                        if s_idx &lt;= cnt &lt;= e_idx:\n                            all_pts.append(p)\n                        cnt += 1\n\n            if rev:\n                all_pts = all_pts[::-1]\n\n            for p in all_pts:\n                segment.points.append(gpxpy.gpx.GPXTrackPoint(p.latitude, p.longitude, elevation=p.elevation, time=p.time))\n\n        output_dir.mkdir(parents=True, exist_ok=True)\n        date_str = booking.get(\"arrival_date\", \"unknown_date\")\n        hotel_name = booking.get(\"hotel_name\", \"unknown_hotel\")\n        hotel_name_clean = \"\".join(c for c in hotel_name if c.isalnum() or c in (\" \", \"-\", \"_\")).strip()\n        hotel_name_clean = hotel_name_clean.replace(\" \", \"_\")[:30]\n\n        out_name = f\"{date_str}_{hotel_name_clean}_merged.gpx\"\n        out_path = output_dir / out_name\n        out_path.write_text(merged_gpx.to_xml(), encoding=\"utf-8\")\n\n        booking[\"gpx_track_final\"] = out_name\n        logger.info(f\"\ud83d\udcbe Merged GPX saved: {out_path.name}\")\n\n        return out_path\n\n    def process_all_bookings(self, bookings: list[dict[str, Any]], output_dir: Path) -&gt; list[dict[str, Any]]:\n        \"\"\"Processes all bookings and creates GPS tracks for each day.\"\"\"\n        bookings_sorted = sorted(bookings, key=lambda x: str(x.get(\"arrival_date\", \"9999-12-31\")))\n        prev_lat = prev_lon = None\n        prev_last = None\n\n        for booking in tqdm(bookings_sorted, desc=\"Processing bookings\"):\n            logger.debug(booking.get(\"hotel_name\"))\n            lat, lon = booking.get(\"latitude\"), booking.get(\"longitude\")\n            if prev_lat is not None and lat is not None:\n                self.collect_route_between_locations(prev_lat, prev_lon, lat, lon, booking, previous_last_file=prev_last)\n                self.extend_track2hotel(booking, output_dir)\n                self.merge_gpx_files(booking.get(\"gpx_files\", []), output_dir, booking)\n                prev_last = booking.get(\"_last_gpx_file\")\n            prev_lat, prev_lon = lat, lon\n\n        return bookings_sorted\n\n    def extend_track2hotel(self, booking: dict[str, Any], output_path: Path) -&gt; Path | None:\n        \"\"\"Extends the route to the hotel using BRouter.\"\"\"\n        if not booking.get(\"gpx_files\") or \"latitude\" not in booking:\n            if \"gpx_files\" not in booking or not booking[\"gpx_files\"]:\n                logger.warning(\"\u26a0\ufe0f  No previous route available - cannot extend to accommodation\")\n            else:\n                logger.warning(\"\u26a0\ufe0f  No hotel coordinates available\")\n            return None\n\n        try:\n            last_seg = booking[\"gpx_files\"][-1]\n            gpx_file = self.gpx_dir / last_seg[\"file\"]\n            if not gpx_file.exists():\n                gpx_file = output_path / last_seg[\"file\"]\n\n            gpx = read_gpx_file(gpx_file)\n            if not gpx:\n                logger.error(f\"Could not read {gpx_file.name}\")\n                return None\n\n            extended_gpx = gpxpy.gpx.GPX()\n            track = gpxpy.gpx.GPXTrack()\n            extended_gpx.tracks.append(track)\n            segment = gpxpy.gpx.GPXTrackSegment()\n            track.segments.append(segment)\n\n            s_idx, e_idx, rev = last_seg.get(\"start_index\", 0), last_seg[\"end_index\"], last_seg.get(\"reversed\", False)\n            pts = []\n            cnt = 0\n            m_idx, ma_idx = min(s_idx, e_idx), max(s_idx, e_idx)\n            for trk in gpx.tracks:\n                for seg in trk.segments:\n                    for p in seg.points:\n                        if m_idx &lt;= cnt &lt;= ma_idx:\n                            pts.append(p)\n                        cnt += 1\n            if rev:\n                pts = pts[::-1]\n\n            for p in pts:\n                segment.points.append(gpxpy.gpx.GPXTrackPoint(p.latitude, p.longitude, elevation=p.elevation, time=p.time))\n\n            new_pts = get_route2address_as_points(\n                pts[-1].latitude, pts[-1].longitude, booking[\"latitude\"], booking[\"longitude\"]\n            )\n            for p in new_pts:\n                segment.points.append(gpxpy.gpx.GPXTrackPoint(p.latitude, p.longitude, elevation=p.elevation, time=p.time))\n\n            output_path.mkdir(parents=True, exist_ok=True)\n            date_str = booking.get(\"arrival_date\", \"unknown_date\")\n            hotel_name = booking.get(\"hotel_name\", \"unknown_hotel\")\n            hotel_name_clean = \"\".join(c for c in hotel_name if c.isalnum() or c in (\" \", \"-\", \"_\")).strip()\n            hotel_name_clean = hotel_name_clean.replace(\" \", \"_\")[:30]\n\n            out_name = f\"{date_str}_{hotel_name_clean}_to_hotel.gpx\"\n            out_file = output_path / out_name\n            out_file.write_text(extended_gpx.to_xml(), encoding=\"utf-8\")\n\n            booking[\"gpx_files\"][-1] = {\n                \"file\": out_name,\n                \"start_index\": 0,\n                \"end_index\": len(segment.points) - 1,\n                \"reversed\": False,\n                \"is_to_hotel\": True,\n            }\n            booking[\"_last_gpx_file\"] = {\"file\": out_name, \"end_index\": len(segment.points) - 1, \"reversed\": False}\n\n            logger.info(f\"   \u2705 Hotel point added. Total: {len(segment.points)} points\")\n            logger.info(f\"   \ud83d\udcbe Saved as: {out_name}\")\n\n            return out_file\n        except Exception as e:\n            logger.error(f\"\u274c Error extending route: {e}\")\n            return None\n\n    def _update_gpx_index_entry(self, old_filename: str, new_gpx_file: Path) -&gt; None:\n        \"\"\"Updates a single entry in the GPX index with a new file.\n\n        Args:\n            old_filename: Filename of the entry to be replaced.\n            new_gpx_file: Path to the new GPX file.\n        \"\"\"\n        if old_filename in self.gpx_index:\n            del self.gpx_index[old_filename]\n            logger.debug(f\"   \ud83d\uddd1\ufe0f  Old entry '{old_filename}' removed from index\")\n\n        gpx = read_gpx_file(new_gpx_file)\n        if not gpx or not gpx.tracks:\n            logger.warning(f\"   \u26a0\ufe0f  Could not read new file '{new_gpx_file.name}'\")\n            return\n\n        total_distance = 0.0\n        total_ascent = 0.0\n        max_elevation = float(\"-inf\")\n        first_point = None\n        last_point = None\n        all_points = []\n        point_index = 0\n\n        for track in gpx.tracks:\n            for seg in track.segments:\n                prev = None\n                for p in seg.points:\n                    if first_point is None:\n                        first_point = p\n                    last_point = p\n                    all_points.append({\"lat\": p.latitude, \"lon\": p.longitude, \"elevation\": p.elevation, \"index\": point_index})\n                    point_index += 1\n                    if p.elevation is not None:\n                        max_elevation = max(max_elevation, p.elevation)\n                    if prev:\n                        d = haversine(prev.latitude, prev.longitude, p.latitude, p.longitude)\n                        total_distance += d\n                        if prev.elevation is not None and p.elevation is not None and p.elevation &gt; prev.elevation:\n                            total_ascent += p.elevation - prev.elevation\n                    prev = p\n\n        if first_point and last_point:\n            self.gpx_index[new_gpx_file.name] = {\n                \"file\": new_gpx_file,\n                \"start_lat\": first_point.latitude,\n                \"start_lon\": first_point.longitude,\n                \"end_lat\": last_point.latitude,\n                \"end_lon\": last_point.longitude,\n                \"total_distance_m\": total_distance,\n                \"total_ascent_m\": total_ascent,\n                \"max_elevation_m\": (int(round(max_elevation)) if max_elevation != float(\"-inf\") else None),\n                \"points\": all_points,\n            }\n            logger.info(f\"   \u2705 New entry '{new_gpx_file.name}' added to index\")\n            logger.debug(f\"      Points: {len(all_points)}, Distance: {total_distance / 1000:.2f} km\")\n</code></pre>"},{"location":"api/#biketour_planner.gpx_route_manager.GPXRouteManager-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.gpx_route_manager.GPXRouteManager.__init__","title":"<code>__init__(gpx_dir, output_path, max_connection_distance_m=None, max_chain_length=None, start_search_radius_km=None, verbose=False)</code>","text":"<p>Initializes the GPXRouteManager and loads all GPX files.</p> <p>Parameters:</p> Name Type Description Default <code>gpx_dir</code> <code>Path</code> <p>Directory with GPX files.</p> required <code>output_path</code> <code>Path</code> <p>Output directory for merged files.</p> required <code>max_connection_distance_m</code> <code>float | None</code> <p>Max distance for track chaining in meters.                        Default from config if None.</p> <code>None</code> <code>max_chain_length</code> <code>int | None</code> <p>Maximum number of tracks to chain. Default from config if None.</p> <code>None</code> <code>start_search_radius_km</code> <code>float | None</code> <p>Search radius for start track in km.                    Default from config if None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Enable detailed logging.</p> <code>False</code> Source code in <code>src/biketour_planner/gpx_route_manager.py</code> <pre><code>def __init__(\n    self,\n    gpx_dir: Path,\n    output_path: Path,\n    max_connection_distance_m: float | None = None,\n    max_chain_length: int | None = None,\n    start_search_radius_km: float | None = None,\n    verbose: bool = False,\n):\n    \"\"\"Initializes the GPXRouteManager and loads all GPX files.\n\n    Args:\n        gpx_dir: Directory with GPX files.\n        output_path: Output directory for merged files.\n        max_connection_distance_m: Max distance for track chaining in meters.\n                                   Default from config if None.\n        max_chain_length: Maximum number of tracks to chain. Default from config if None.\n        start_search_radius_km: Search radius for start track in km.\n                               Default from config if None.\n        verbose: Enable detailed logging.\n    \"\"\"\n    config = get_config()\n\n    self.gpx_dir = gpx_dir\n    self.output_path = output_path\n    self.verbose = verbose\n\n    self.max_connection_distance_m = (\n        max_connection_distance_m if max_connection_distance_m is not None else config.routing.max_connection_distance_m\n    )\n    self.max_chain_length = max_chain_length if max_chain_length is not None else config.routing.max_chain_length\n    self.start_search_radius_km = (\n        start_search_radius_km if start_search_radius_km is not None else config.routing.start_search_radius_km\n    )\n    self.target_search_radius_km = config.routing.target_search_radius_km\n\n    self.gpx_index: GPXIndex = {}\n    self._preprocess_gpx_directory()\n</code></pre>"},{"location":"api/#biketour_planner.gpx_route_manager.GPXRouteManager.collect_route_between_locations","title":"<code>collect_route_between_locations(start_lat, start_lon, target_lat, target_lon, booking, previous_last_file=None)</code>","text":"<p>Calculates and chains GPX files between start and target locations.</p> <p>This is the main method for route planning. It implements an intelligent algorithm for chaining multiple GPX tracks.</p> <p>Parameters:</p> Name Type Description Default <code>start_lat</code> <code>float</code> <p>Latitude of the start location.</p> required <code>start_lon</code> <code>float</code> <p>Longitude of the start location.</p> required <code>target_lat</code> <code>float</code> <p>Latitude of the target location (accommodation).</p> required <code>target_lon</code> <code>float</code> <p>Longitude of the target location (accommodation).</p> required <code>booking</code> <code>dict[str, Any]</code> <p>Booking/Day dictionary to be enriched with route information.</p> required <code>previous_last_file</code> <code>dict[str, Any] | None</code> <p>Optional. Dictionary of the last used GPX file                from the previous day.</p> <code>None</code> Source code in <code>src/biketour_planner/gpx_route_manager.py</code> <pre><code>def collect_route_between_locations(\n    self,\n    start_lat: float,\n    start_lon: float,\n    target_lat: float,\n    target_lon: float,\n    booking: dict[str, Any],\n    previous_last_file: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Calculates and chains GPX files between start and target locations.\n\n    This is the main method for route planning. It implements an intelligent\n    algorithm for chaining multiple GPX tracks.\n\n    Args:\n        start_lat: Latitude of the start location.\n        start_lon: Longitude of the start location.\n        target_lat: Latitude of the target location (accommodation).\n        target_lon: Longitude of the target location (accommodation).\n        booking: Booking/Day dictionary to be enriched with route information.\n        previous_last_file: Optional. Dictionary of the last used GPX file\n                           from the previous day.\n    \"\"\"\n    logger.info(f\"\\n{'=' * 80}\")\n    logger.info(f\"Route search: ({start_lat:.6f}, {start_lon:.6f}) -&gt; ({target_lat:.6f}, {target_lon:.6f})\")\n    if previous_last_file:\n        logger.info(f\"\ud83d\udd17 Continuation from: {previous_last_file['file']} (Index {previous_last_file['end_index']})\")\n    logger.info(f\"{'=' * 80}\")\n\n    start_file, start_idx, force_dir = self._find_start_pos(\n        start_lat, start_lon, target_lat, target_lon, previous_last_file\n    )\n    target_file, target_idx, target_side_lat, target_side_lon = self._find_target_pos(\n        start_lat, start_lon, target_lat, target_lon\n    )\n\n    if not start_file or not target_file:\n        logger.warning(\"\u26a0\ufe0f  No matching GPX files found!\")\n        booking.update({\"gpx_files\": [], \"total_distance_km\": 0, \"total_ascent_m\": 0, \"max_elevation_m\": None})\n        return\n\n    start_pt = self.gpx_index[start_file][\"points\"][start_idx]\n    start_pos = RoutePosition(file=start_file, index=start_idx, lat=start_pt[\"lat\"], lon=start_pt[\"lon\"])\n    target_pos = RoutePosition(file=target_file, index=target_idx, lat=target_side_lat, lon=target_side_lon)\n\n    context = RouteContext(iteration=0, target=target_pos, force_direction=force_dir)\n    stats = RouteStatistics()\n    current_pos = start_pos\n\n    for i in range(self.max_chain_length):\n        context.iteration = i\n        should_continue, current_pos, stats = self._process_route_iteration_new(current_pos, context, stats)\n        if not should_continue:\n            break\n\n    logger.info(\"\\n\ud83d\udcca Summary:\")\n    logger.info(f\"   Files: {len(context.route_files)}\")\n    logger.info(f\"   Total distance: {stats.total_distance / 1000:.2f} km\")\n    logger.info(f\"   Total ascent: {stats.total_ascent:.0f} m\")\n    logger.info(f\"   Max elevation: {stats.max_elevation:.0f} m\" if stats.max_elevation != 0 else \"   Max elevation: N/A\")\n    logger.info(f\"{'=' * 80}\\n\")\n\n    booking[\"gpx_files\"] = context.route_files\n    booking[\"total_distance_km\"] = round(stats.total_distance / 1000, 2)\n    booking[\"total_ascent_m\"] = int(round(stats.total_ascent))\n    booking[\"total_descent_m\"] = int(round(stats.total_descent))\n    booking[\"max_elevation_m\"] = int(round(stats.max_elevation)) if stats.max_elevation != 0 else None\n\n    if context.route_files:\n        last = context.route_files[-1]\n        booking[\"_last_gpx_file\"] = {\"file\": last[\"file\"], \"end_index\": last[\"end_index\"], \"reversed\": last[\"reversed\"]}\n</code></pre>"},{"location":"api/#biketour_planner.gpx_route_manager.GPXRouteManager.extend_track2hotel","title":"<code>extend_track2hotel(booking, output_path)</code>","text":"<p>Extends the route to the hotel using BRouter.</p> Source code in <code>src/biketour_planner/gpx_route_manager.py</code> <pre><code>def extend_track2hotel(self, booking: dict[str, Any], output_path: Path) -&gt; Path | None:\n    \"\"\"Extends the route to the hotel using BRouter.\"\"\"\n    if not booking.get(\"gpx_files\") or \"latitude\" not in booking:\n        if \"gpx_files\" not in booking or not booking[\"gpx_files\"]:\n            logger.warning(\"\u26a0\ufe0f  No previous route available - cannot extend to accommodation\")\n        else:\n            logger.warning(\"\u26a0\ufe0f  No hotel coordinates available\")\n        return None\n\n    try:\n        last_seg = booking[\"gpx_files\"][-1]\n        gpx_file = self.gpx_dir / last_seg[\"file\"]\n        if not gpx_file.exists():\n            gpx_file = output_path / last_seg[\"file\"]\n\n        gpx = read_gpx_file(gpx_file)\n        if not gpx:\n            logger.error(f\"Could not read {gpx_file.name}\")\n            return None\n\n        extended_gpx = gpxpy.gpx.GPX()\n        track = gpxpy.gpx.GPXTrack()\n        extended_gpx.tracks.append(track)\n        segment = gpxpy.gpx.GPXTrackSegment()\n        track.segments.append(segment)\n\n        s_idx, e_idx, rev = last_seg.get(\"start_index\", 0), last_seg[\"end_index\"], last_seg.get(\"reversed\", False)\n        pts = []\n        cnt = 0\n        m_idx, ma_idx = min(s_idx, e_idx), max(s_idx, e_idx)\n        for trk in gpx.tracks:\n            for seg in trk.segments:\n                for p in seg.points:\n                    if m_idx &lt;= cnt &lt;= ma_idx:\n                        pts.append(p)\n                    cnt += 1\n        if rev:\n            pts = pts[::-1]\n\n        for p in pts:\n            segment.points.append(gpxpy.gpx.GPXTrackPoint(p.latitude, p.longitude, elevation=p.elevation, time=p.time))\n\n        new_pts = get_route2address_as_points(\n            pts[-1].latitude, pts[-1].longitude, booking[\"latitude\"], booking[\"longitude\"]\n        )\n        for p in new_pts:\n            segment.points.append(gpxpy.gpx.GPXTrackPoint(p.latitude, p.longitude, elevation=p.elevation, time=p.time))\n\n        output_path.mkdir(parents=True, exist_ok=True)\n        date_str = booking.get(\"arrival_date\", \"unknown_date\")\n        hotel_name = booking.get(\"hotel_name\", \"unknown_hotel\")\n        hotel_name_clean = \"\".join(c for c in hotel_name if c.isalnum() or c in (\" \", \"-\", \"_\")).strip()\n        hotel_name_clean = hotel_name_clean.replace(\" \", \"_\")[:30]\n\n        out_name = f\"{date_str}_{hotel_name_clean}_to_hotel.gpx\"\n        out_file = output_path / out_name\n        out_file.write_text(extended_gpx.to_xml(), encoding=\"utf-8\")\n\n        booking[\"gpx_files\"][-1] = {\n            \"file\": out_name,\n            \"start_index\": 0,\n            \"end_index\": len(segment.points) - 1,\n            \"reversed\": False,\n            \"is_to_hotel\": True,\n        }\n        booking[\"_last_gpx_file\"] = {\"file\": out_name, \"end_index\": len(segment.points) - 1, \"reversed\": False}\n\n        logger.info(f\"   \u2705 Hotel point added. Total: {len(segment.points)} points\")\n        logger.info(f\"   \ud83d\udcbe Saved as: {out_name}\")\n\n        return out_file\n    except Exception as e:\n        logger.error(f\"\u274c Error extending route: {e}\")\n        return None\n</code></pre>"},{"location":"api/#biketour_planner.gpx_route_manager.GPXRouteManager.merge_gpx_files","title":"<code>merge_gpx_files(route_files, output_dir, booking)</code>","text":"<p>Merges multiple GPX track segments into a single GPX file.</p> <p>Parameters:</p> Name Type Description Default <code>route_files</code> <code>list[dict[str, Any]]</code> <p>List of dictionaries with track section information.</p> required <code>output_dir</code> <code>Path</code> <p>Output directory for the merged GPX file.</p> required <code>booking</code> <code>dict[str, Any]</code> <p>Booking dictionary for filename generation.</p> required <p>Returns:</p> Type Description <code>Path | None</code> <p>Path to the written GPX file or None on error.</p> Source code in <code>src/biketour_planner/gpx_route_manager.py</code> <pre><code>def merge_gpx_files(self, route_files: list[dict[str, Any]], output_dir: Path, booking: dict[str, Any]) -&gt; Path | None:\n    \"\"\"Merges multiple GPX track segments into a single GPX file.\n\n    Args:\n        route_files: List of dictionaries with track section information.\n        output_dir: Output directory for the merged GPX file.\n        booking: Booking dictionary for filename generation.\n\n    Returns:\n        Path to the written GPX file or None on error.\n    \"\"\"\n    if not route_files:\n        logger.warning(f\"route_files is empty or None: {route_files}\")\n        return None\n\n    merged_gpx = gpxpy.gpx.GPX()\n    track = gpxpy.gpx.GPXTrack()\n    merged_gpx.tracks.append(track)\n    segment = gpxpy.gpx.GPXTrackSegment()\n    track.segments.append(segment)\n\n    for i, entry in enumerate(route_files):\n        if i == len(route_files) - 1 and entry.get(\"is_to_hotel\"):\n            gpx_file = output_dir / entry[\"file\"]\n        else:\n            gpx_file = self.gpx_dir / entry[\"file\"]\n            if not gpx_file.exists():\n                gpx_file = output_dir / entry[\"file\"]\n\n        if not gpx_file.exists():\n            logger.warning(f\"\u26a0\ufe0f  File not found: {entry['file']}\")\n            continue\n\n        gpx = read_gpx_file(gpx_file)\n        if not gpx or not gpx.tracks:\n            continue\n\n        s_idx, e_idx = entry[\"start_index\"], entry[\"end_index\"]\n        rev = entry[\"reversed\"]\n        if rev:\n            s_idx, e_idx = e_idx, s_idx\n\n        all_pts = []\n        cnt = 0\n        for trk in gpx.tracks:\n            for seg in trk.segments:\n                for p in seg.points:\n                    if s_idx &lt;= cnt &lt;= e_idx:\n                        all_pts.append(p)\n                    cnt += 1\n\n        if rev:\n            all_pts = all_pts[::-1]\n\n        for p in all_pts:\n            segment.points.append(gpxpy.gpx.GPXTrackPoint(p.latitude, p.longitude, elevation=p.elevation, time=p.time))\n\n    output_dir.mkdir(parents=True, exist_ok=True)\n    date_str = booking.get(\"arrival_date\", \"unknown_date\")\n    hotel_name = booking.get(\"hotel_name\", \"unknown_hotel\")\n    hotel_name_clean = \"\".join(c for c in hotel_name if c.isalnum() or c in (\" \", \"-\", \"_\")).strip()\n    hotel_name_clean = hotel_name_clean.replace(\" \", \"_\")[:30]\n\n    out_name = f\"{date_str}_{hotel_name_clean}_merged.gpx\"\n    out_path = output_dir / out_name\n    out_path.write_text(merged_gpx.to_xml(), encoding=\"utf-8\")\n\n    booking[\"gpx_track_final\"] = out_name\n    logger.info(f\"\ud83d\udcbe Merged GPX saved: {out_path.name}\")\n\n    return out_path\n</code></pre>"},{"location":"api/#biketour_planner.gpx_route_manager.GPXRouteManager.process_all_bookings","title":"<code>process_all_bookings(bookings, output_dir)</code>","text":"<p>Processes all bookings and creates GPS tracks for each day.</p> Source code in <code>src/biketour_planner/gpx_route_manager.py</code> <pre><code>def process_all_bookings(self, bookings: list[dict[str, Any]], output_dir: Path) -&gt; list[dict[str, Any]]:\n    \"\"\"Processes all bookings and creates GPS tracks for each day.\"\"\"\n    bookings_sorted = sorted(bookings, key=lambda x: str(x.get(\"arrival_date\", \"9999-12-31\")))\n    prev_lat = prev_lon = None\n    prev_last = None\n\n    for booking in tqdm(bookings_sorted, desc=\"Processing bookings\"):\n        logger.debug(booking.get(\"hotel_name\"))\n        lat, lon = booking.get(\"latitude\"), booking.get(\"longitude\")\n        if prev_lat is not None and lat is not None:\n            self.collect_route_between_locations(prev_lat, prev_lon, lat, lon, booking, previous_last_file=prev_last)\n            self.extend_track2hotel(booking, output_dir)\n            self.merge_gpx_files(booking.get(\"gpx_files\", []), output_dir, booking)\n            prev_last = booking.get(\"_last_gpx_file\")\n        prev_lat, prev_lon = lat, lon\n\n    return bookings_sorted\n</code></pre>"},{"location":"api/#biketour_planner.gpx_route_manager-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.parse_booking","title":"<code>biketour_planner.parse_booking</code>","text":"<p>Parsing logic for extracting booking information from HTML confirmations.</p> <p>Supports Booking.com and Airbnb confirmation formats.</p>"},{"location":"api/#biketour_planner.parse_booking-classes","title":"Classes","text":""},{"location":"api/#biketour_planner.parse_booking-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.parse_booking.create_all_bookings","title":"<code>create_all_bookings(booking_dir, search_radius_m, max_pois)</code>","text":"<p>Create all bookings from HTML files in a directory.</p> <p>Parameters:</p> Name Type Description Default <code>booking_dir</code> <code>Path</code> <p>Directory containing HTML booking confirmations.</p> required <code>search_radius_m</code> <code>int</code> <p>Search radius for tourist sights in meters.</p> required <code>max_pois</code> <code>int</code> <p>Maximum number of POIs to find per booking.</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of dictionaries containing booking information.</p> Source code in <code>src/biketour_planner/parse_booking.py</code> <pre><code>def create_all_bookings(booking_dir: Path, search_radius_m: int, max_pois: int) -&gt; list[dict[str, Any]]:\n    \"\"\"Create all bookings from HTML files in a directory.\n\n    Args:\n        booking_dir: Directory containing HTML booking confirmations.\n        search_radius_m: Search radius for tourist sights in meters.\n        max_pois: Maximum number of POIs to find per booking.\n\n    Returns:\n        List of dictionaries containing booking information.\n    \"\"\"\n    all_bookings = []\n    logger.debug(\"Start create_all_bookings\")\n\n    # Support both .htm and .html extensions\n    html_files = list(booking_dir.glob(\"*.htm\")) + list(booking_dir.glob(\"*.html\"))\n\n    for html_file in html_files:\n        booking = extract_booking_info(html_file)\n\n        if booking.get(\"latitude\") is not None:\n            lat, lon = booking[\"latitude\"], booking[\"longitude\"]\n        else:\n            try:\n                lat, lon = geocode_address(booking[\"address\"])\n                booking[\"latitude\"], booking[\"longitude\"] = lat, lon\n            except Exception as e:\n                logger.error(f\"Geocoding failed for {booking.get('address')}: {e}\")\n                all_bookings.append(booking)\n                continue\n\n        # Find tourist sights\n        booking[\"tourist_sights\"] = find_top_tourist_sights(lat, lon, radius=search_radius_m, limit=max_pois)\n        all_bookings.append(booking)\n\n    logger.debug(\"End create_all_bookings\")\n    return all_bookings\n</code></pre>"},{"location":"api/#biketour_planner.parse_booking.extract_booking_info","title":"<code>extract_booking_info(html_path)</code>","text":"<p>Extract booking info from a Booking.com or Airbnb HTML confirmation.</p> <p>Parameters:</p> Name Type Description Default <code>html_path</code> <code>Path</code> <p>Path to the HTML file.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with booking information.</p> Source code in <code>src/biketour_planner/parse_booking.py</code> <pre><code>def extract_booking_info(html_path: Path) -&gt; dict[str, Any]:\n    \"\"\"Extract booking info from a Booking.com or Airbnb HTML confirmation.\n\n    Args:\n        html_path: Path to the HTML file.\n\n    Returns:\n        Dictionary with booking information.\n    \"\"\"\n    try:\n        content = html_path.read_text(encoding=\"utf-8\")\n        soup = BeautifulSoup(content, \"lxml\")\n    except Exception as e:\n        raise ParsingError(f\"Failed to read/parse {html_path}: {e}\") from e\n\n    text = soup.get_text(\" \", strip=True)\n\n    # Try utag_data first (Booking.com)\n    hotel_name = \"\"\n    city_name = \"\"\n    country_name = \"\"\n    arrival_date = None\n    departure_date = None\n    checkin_time = None\n    address = None\n    phone = None\n    gps_lat = gps_lon = None\n\n    script_tag = soup.find(\"script\", string=re.compile(r\"window\\.utag_data\"))\n\n    if not script_tag:\n        airbnb_data = parse_airbnb_booking(soup)\n        if airbnb_data:\n            return airbnb_data\n\n    if script_tag:\n        script_text = script_tag.string\n        h_m = re.search(r\"hotel_name:\\s*'([^']*)'\", script_text)\n        if h_m:\n            hotel_name = h_m.group(1)\n        c_m = re.search(r\"city_name:\\s*'([^']*)'\", script_text)\n        if c_m:\n            city_name = c_m.group(1)\n        co_m = re.search(r\"country_name:\\s*'([^']*)'\", script_text)\n        if co_m:\n            country_name = co_m.group(1)\n        di_m = re.search(r\"date_in:\\s*'([^']*)'\", script_text)\n        if di_m:\n            arrival_date = di_m.group(1)\n        do_m = re.search(r\"date_out:\\s*'([^']*)'\", script_text)\n        if do_m:\n            departure_date = do_m.group(1)\n\n    # Primary: hotel-details__address (new format)\n    hotel_details_div = soup.find(\"div\", class_=\"hotel-details__address\")\n    if hotel_details_div:\n        if not hotel_name:\n            h2_tag = hotel_details_div.find(\"h2\")\n            if h2_tag:\n                hotel_name = h2_tag.text.strip()\n        if not address:\n            addr_strong = hotel_details_div.find(\"strong\", string=\"Adresse:\")\n            if addr_strong and addr_strong.next_sibling:\n                address = addr_strong.next_sibling.strip()\n        phone_strong = hotel_details_div.find(\"strong\", string=\"Telefon:\")\n        if phone_strong:\n            phone_span = phone_strong.find_next(\"span\", class_=\"u-phone\")\n            if phone_span:\n                phone = phone_span.text.strip()\n        gps_strong = hotel_details_div.find(\"strong\", string=\"GPS-Koordinaten:\")\n        if gps_strong and gps_strong.next_sibling:\n            gps_lat, gps_lon = parse_gps_coordinates(gps_strong.next_sibling.strip())\n\n    # Dates section\n    dates_section = soup.find(\"div\", class_=\"row dates\")\n    if dates_section:\n        arrival_col = dates_section.find(\"div\", class_=\"col-6 dates__item\")\n        if arrival_col:\n            if not arrival_date:\n                day_elem = arrival_col.find(\"div\", class_=\"summary__big-num\")\n                month_elem = arrival_col.find(\"div\", class_=\"dates__month\")\n                if day_elem and month_elem:\n                    year_m = re.search(r\"\\d{4}\", text)\n                    year = year_m.group(0) if year_m else \"2026\"\n                    arrival_date = f\"{year}-{MONTHS_DE.get(month_elem.text.strip(), '01')}-{int(day_elem.text.strip()):02d}\"\n            time_div = arrival_col.find(\"div\", class_=\"dates__time\")\n            if time_div:\n                time_m = re.search(r\"(\\d{1,2}:\\d{2})\\s*-\", time_div.text.strip())\n                if time_m:\n                    checkin_time = time_m.group(1)\n\n        departure_cols = dates_section.find_all(\"div\", class_=\"col-6 dates__item\")\n        if len(departure_cols) &gt; 1 and not departure_date:\n            departure_col = departure_cols[1]\n            day_elem = departure_col.find(\"div\", class_=\"summary__big-num\")\n            month_elem = departure_col.find(\"div\", class_=\"dates__month\")\n            if day_elem and month_elem:\n                year_m = re.search(r\"\\d{4}\", text)\n                year = year_m.group(0) if year_m else \"2026\"\n                departure_date = f\"{year}-{MONTHS_DE.get(month_elem.text.strip(), '01')}-{int(day_elem.text.strip()):02d}\"\n\n    # Backup: old methods\n    if not arrival_date:\n        arr_elem = soup.find(\"h3\", string=\"Anreise\")\n        if arr_elem:\n            arrival_date = parse_date(arr_elem.find_next(\"div\").text)\n\n    if not departure_date:\n        dep_elem = soup.find(\"h3\", string=\"Abreise\")\n        if dep_elem:\n            departure_date = parse_date(dep_elem.find_next(\"div\").text)\n\n    if not checkin_time:\n        try:\n            checkin_elem = soup.find(\"h3\", string=\"Anreise\")\n            if checkin_elem:\n                checkin_raw = checkin_elem.find_next(\"div\").find_next(\"div\").text\n                checkin_time = checkin_raw.split(\"-\")[0].strip()\n        except (AttributeError, IndexError):\n            pass\n\n    if not address:\n        addr_label = soup.find(\"div\", string=\"Adresse\")\n        if addr_label:\n            address = addr_label.find_next(\"div\").text.strip()\n\n    # Amenities\n    has_kitchen = has_washing_machine = has_breakfast = False\n    amenities_header = soup.find(\"h5\", string=\"Ausstattung\")\n    if amenities_header:\n        parent = amenities_header.find_parent([\"tr\", \"th\"])\n        td = parent.find_next(\"td\") if parent else amenities_header.find_next(\"td\")\n        if td:\n            txt = td.get_text(\" \")\n            has_kitchen, has_washing_machine = \"K\u00fcche\" in txt, \"Waschmaschine\" in txt\n\n    meals_header = soup.find(\"h5\", string=\"Mahlzeiten\")\n    if meals_header:\n        parent = meals_header.find_parent([\"tr\", \"th\"])\n        td = parent.find_next(\"td\") if parent else meals_header.find_next(\"td\")\n        if td:\n            has_breakfast = \"Fr\u00fchst\u00fcck\" in td.get_text(\" \")\n\n    # Price\n    total_price = None\n    price_elem = soup.find(\"div\", attrs={\"data-total-price\": True})\n    if price_elem:\n        try:\n            total_price = float(price_elem.get(\"data-total-price\"))\n        except (ValueError, TypeError):\n            pass\n\n    # Cancellation\n    cancel_m = re.search(r\"bis (\\d{1,2}\\. [A-Za-z\u00e4\u00f6\u00fc\u00c4\u00d6\u00dc]+ \\d{4})\", text)\n    free_cancel_until = parse_date(cancel_m.group(1)) if cancel_m else None\n\n    # Fallback for hotel_name\n    if not hotel_name:\n        h_elem = soup.select_one(\".gta-modal-preview__hotel-name .bui-text\")\n        if h_elem:\n            hotel_name = h_elem.text.strip()\n        if not hotel_name:\n            container = soup.find(\"div\", class_=\"gta-modal-preview__hotel-name\")\n            if container:\n                bui = container.find(\"div\", class_=\"bui-text\")\n                if bui:\n                    hotel_name = bui.text.strip()\n\n    return {\n        \"hotel_name\": hotel_name,\n        \"city_name\": city_name,\n        \"country_name\": country_name,\n        \"arrival_date\": arrival_date,\n        \"departure_date\": departure_date,\n        \"checkin_time\": checkin_time,\n        \"address\": address,\n        \"phone\": phone,\n        \"latitude\": gps_lat,\n        \"longitude\": gps_lon,\n        \"has_kitchen\": has_kitchen,\n        \"has_washing_machine\": has_washing_machine,\n        \"has_breakfast\": has_breakfast,\n        \"total_price\": total_price,\n        \"free_cancel_until\": free_cancel_until,\n    }\n</code></pre>"},{"location":"api/#biketour_planner.parse_booking.parse_airbnb_booking","title":"<code>parse_airbnb_booking(soup)</code>","text":"<p>Extract booking information from an Airbnb HTML confirmation.</p> <p>Parameters:</p> Name Type Description Default <code>soup</code> <code>BeautifulSoup</code> <p>BeautifulSoup object of the HTML page.</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Dictionary with booking information or None on error.</p> Source code in <code>src/biketour_planner/parse_booking.py</code> <pre><code>def parse_airbnb_booking(soup: BeautifulSoup) -&gt; dict[str, Any] | None:\n    \"\"\"Extract booking information from an Airbnb HTML confirmation.\n\n    Args:\n        soup: BeautifulSoup object of the HTML page.\n\n    Returns:\n        Dictionary with booking information or None on error.\n    \"\"\"\n    # Search for script tag with Airbnb data (metadata)\n    script_tag = soup.find(\"script\", string=re.compile(r'\"metadata\".*\"title\".*\"check_in_date\"'))\n\n    if not script_tag:\n        return None\n\n    script_text = script_tag.string\n\n    # Extract title (accommodation name)\n    title_match = re.search(r'\"title\"\\s*:\\s*\"([^\"]*)\"', script_text)\n    hotel_name = title_match.group(1) if title_match else None\n\n    # Extract check_in_date\n    checkin_match = re.search(r'\"check_in_date\"\\s*:\\s*\"([^\"]*)\"', script_text)\n    arrival_date = checkin_match.group(1) if checkin_match else None\n\n    # Extract check_out_date\n    checkout_match = re.search(r'\"check_out_date\"\\s*:\\s*\"([^\"]*)\"', script_text)\n    departure_date = checkout_match.group(1) if checkout_match else None\n\n    # Extract GPS coordinates\n    lat_match = re.search(r'\"lat\"\\s*:\\s*([\\d.]+)', script_text)\n    gps_lat = float(lat_match.group(1)) if lat_match else None\n\n    lng_match = re.search(r'\"lng\"\\s*:\\s*([\\d.]+)', script_text)\n    gps_lon = float(lng_match.group(1)) if lng_match else None\n\n    # Validate critical fields\n    if not (hotel_name and arrival_date and departure_date):\n        logger.warning(\"Airbnb Parser: Critical fields missing\")\n        return None\n\n    # Search for additional information in SSRUIStateToken\n    city_name = \"\"\n    country_name = \"\"\n    address = None\n    checkin_time = None\n    total_price = None\n\n    # Search in all script tags for specific JSON structures\n    for script in soup.find_all(\"script\"):\n        if not script.string:\n            continue\n\n        script_content = script.string\n\n        # Search for checkin_checkout_arrival_guide\n        if '\"id\":\"checkin_checkout_arrival_guide\"' in script_content:\n            checkin_m = re.search(\n                r'\"leading_kicker\"\\s*:\\s*\"Check-in\".*?\"leading_subtitle\"\\s*:\\s*\"([^\"]*)\"', script_content, re.DOTALL\n            )\n            if checkin_m:\n                checkin_time = checkin_m.group(1)\n\n        # Search for header_action.direction for address\n        if '\"id\":\"header_action.direction\"' in script_content:\n            address_m = re.search(\n                r'\"id\"\\s*:\\s*\"header_action\\.direction\".*?\"subtitle\"\\s*:\\s*\"([^\"]*)\"', script_content, re.DOTALL\n            )\n            if address_m:\n                address = address_m.group(1).strip()\n                address_parts = address.split(\",\")\n                if len(address_parts) &gt;= 2:\n                    city_name = address_parts[-1].strip()\n                elif len(address_parts) == 1:\n                    city_name = address_parts[0].strip()\n\n        # Search for total price\n        if '\"id\":\"payment_summary\"' in script_content:\n            price_m = re.search(r\"Gesamtkosten:\\s*([\\d,]+(?:\\.\\d{2})?)\\s*\u20ac\", script_content)\n            if price_m:\n                try:\n                    price_str = price_m.group(1).replace(\",\", \".\")\n                    total_price = float(price_str)\n                except ValueError:\n                    pass\n\n    address_div = soup.find(\"div\", class_=\"rz78adb\")\n    if address_div:\n        address_p = address_div.find(\"p\", class_=\"_yz1jt7x\", string=re.compile(r\".+,.+\"))\n        if address_p:\n            address_new = address_p.get_text().strip()\n            if not address:\n                address = address_new\n            if address_new and \", \" in address_new:\n                address_parts = [part.strip() for part in address.split(\",\")]\n                if len(address_parts) &gt;= 1:\n                    country_name = address_parts[-1]\n                    if not city_name:\n                        city_name = address_parts[-2] if len(address_parts) &gt;= 2 else \"\"\n\n    # Try to find phone number\n    phone = None\n    phone_match = re.search(r\"tel:(\\+[\\d]+)\", script_text)\n    if phone_match:\n        phone = phone_match.group(1)\n\n    logger.info(f\"Airbnb booking detected: {hotel_name}\")\n\n    return {\n        \"hotel_name\": hotel_name,\n        \"arrival_date\": arrival_date,\n        \"departure_date\": departure_date,\n        \"latitude\": gps_lat,\n        \"longitude\": gps_lon,\n        \"city_name\": city_name,\n        \"country_name\": country_name,\n        \"checkin_time\": checkin_time,\n        \"address\": address,\n        \"phone\": phone,\n        \"has_kitchen\": False,\n        \"has_washing_machine\": False,\n        \"has_breakfast\": False,\n        \"total_price\": total_price,\n        \"free_cancel_until\": None,\n    }\n</code></pre>"},{"location":"api/#biketour_planner.parse_booking.parse_date","title":"<code>parse_date(text)</code>","text":"<p>Parse a German date in format 'Day, D. Month Year'.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>String with date information, e.g., \"So., 8. M\u00e4rz 2026\"</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>ISO-formatted date (YYYY-MM-DD) or None on error.</p> Source code in <code>src/biketour_planner/parse_booking.py</code> <pre><code>def parse_date(text: str) -&gt; str | None:\n    \"\"\"Parse a German date in format 'Day, D. Month Year'.\n\n    Args:\n        text: String with date information, e.g., \"So., 8. M\u00e4rz 2026\"\n\n    Returns:\n        ISO-formatted date (YYYY-MM-DD) or None on error.\n    \"\"\"\n    if not text:\n        return None\n    # e.g., \"So., 8. M\u00e4rz 2026\"\n    m = re.search(r\"(\\d{1,2})\\. ([A-Za-z\u00e4\u00f6\u00fc\u00c4\u00d6\u00dc]+) (\\d{4})\", text)\n    if not m:\n        return None\n    day, month, year = m.groups()\n    if month in MONTHS_DE:\n        return f\"{year}-{MONTHS_DE[month]}-{int(day):02d}\"\n    return None\n</code></pre>"},{"location":"api/#biketour_planner.parse_booking.parse_gps_coordinates","title":"<code>parse_gps_coordinates(gps_text)</code>","text":"<p>Convert GPS coordinates from degrees/minutes to decimal degrees.</p> <p>Parameters:</p> Name Type Description Default <code>gps_text</code> <code>str</code> <p>GPS string in format \"N 043\u00b0 56.181, E 15\u00b0 26.645\"</p> required <p>Returns:</p> Type Description <code>tuple[float | None, float | None]</code> <p>Tuple of (latitude, longitude) in decimal degrees or (None, None).</p> Source code in <code>src/biketour_planner/parse_booking.py</code> <pre><code>def parse_gps_coordinates(gps_text: str) -&gt; tuple[float | None, float | None]:\n    \"\"\"Convert GPS coordinates from degrees/minutes to decimal degrees.\n\n    Args:\n        gps_text: GPS string in format \"N 043\u00b0 56.181, E 15\u00b0 26.645\"\n\n    Returns:\n        Tuple of (latitude, longitude) in decimal degrees or (None, None).\n    \"\"\"\n    if not gps_text:\n        return None, None\n\n    # Extract N/S degrees and minutes\n    lat_match = re.search(r\"([NS])\\s*(\\d+)[\u00b0&amp;deg;]+\\s*([\\d.]+)\", gps_text)\n    # Extract E/W degrees and minutes\n    lon_match = re.search(r\"([EW])\\s*(\\d+)[\u00b0&amp;deg;]+\\s*([\\d.]+)\", gps_text)\n\n    if not lat_match or not lon_match:\n        return None, None\n\n    # Convert to decimal degrees: Degrees + (Minutes / 60)\n    lat_deg = int(lat_match.group(2))\n    lat_min = float(lat_match.group(3))\n    lat = lat_deg + (lat_min / 60)\n    if lat_match.group(1) == \"S\":\n        lat = -lat\n\n    lon_deg = int(lon_match.group(2))\n    lon_min = float(lon_match.group(3))\n    lon = lon_deg + (lon_min / 60)\n    if lon_match.group(1) == \"W\":\n        lon = -lon\n\n    return lat, lon\n</code></pre>"},{"location":"api/#biketour_planner.brouter","title":"<code>biketour_planner.brouter</code>","text":"<p>BRouter API integration for offline routing.</p>"},{"location":"api/#biketour_planner.brouter-classes","title":"Classes","text":""},{"location":"api/#biketour_planner.brouter-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.brouter.check_brouter_availability","title":"<code>check_brouter_availability()</code>","text":"<p>Checks if the BRouter server is reachable and responding.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the server is available, False otherwise.</p> Source code in <code>src/biketour_planner/brouter.py</code> <pre><code>def check_brouter_availability() -&gt; bool:\n    \"\"\"Checks if the BRouter server is reachable and responding.\n\n    Returns:\n        True if the server is available, False otherwise.\n    \"\"\"\n    config = get_config()\n    base_url = config.routing.brouter_url.rstrip(\"/\")\n    url = f\"{base_url}/brouter\"\n    try:\n        logger.debug(f\"Checking BRouter availability at {url}\")\n        r = requests.get(url, timeout=5)\n        # BRouter might return 400 (Bad Request) if called without parameters,\n        # which is still a sign that the server is up and responding.\n        return r.status_code &lt; 500\n    except requests.exceptions.RequestException as e:\n        logger.debug(f\"BRouter not reachable at {url}: {e}\")\n        return False\n</code></pre>"},{"location":"api/#biketour_planner.brouter.get_route2address_as_points","title":"<code>get_route2address_as_points(start_lat, start_lon, target_lat, target_lon)</code>","text":"<p>Computes a route between two points and returns it as a list of GPX points.</p> <p>Parameters:</p> Name Type Description Default <code>start_lat</code> <code>float</code> <p>Latitude of the start point.</p> required <code>start_lon</code> <code>float</code> <p>Longitude of the start point.</p> required <code>target_lat</code> <code>float</code> <p>Latitude of the target point.</p> required <code>target_lon</code> <code>float</code> <p>Longitude of the target point.</p> required <p>Returns:</p> Type Description <code>list[GPXTrackPoint]</code> <p>A list of GPXTrackPoint objects.</p> <p>Raises:</p> Type Description <code>RoutingError</code> <p>If routing fails or the response is invalid.</p> Source code in <code>src/biketour_planner/brouter.py</code> <pre><code>def get_route2address_as_points(\n    start_lat: float, start_lon: float, target_lat: float, target_lon: float\n) -&gt; list[gpxpy.gpx.GPXTrackPoint]:\n    \"\"\"Computes a route between two points and returns it as a list of GPX points.\n\n    Args:\n        start_lat: Latitude of the start point.\n        start_lon: Longitude of the start point.\n        target_lat: Latitude of the target point.\n        target_lon: Longitude of the target point.\n\n    Returns:\n        A list of GPXTrackPoint objects.\n\n    Raises:\n        RoutingError: If routing fails or the response is invalid.\n    \"\"\"\n    gpx_str = route_to_address(start_lat, start_lon, target_lat, target_lon)\n    if not gpx_str:\n        raise RoutingError(\"Empty response\")\n    try:\n        gpx = gpxpy.parse(gpx_str)\n        if not gpx.tracks or not gpx.tracks[0].segments:\n            raise RoutingError(\"No tracks or segments found in GPX\")\n        points = gpx.tracks[0].segments[0].points\n        if not points:\n            raise RoutingError(\"No points found in GPX\")\n        return points\n    except RoutingError:\n        raise\n    except Exception as e:\n        raise RoutingError(f\"Failed to parse GPX: {e}\") from e\n</code></pre>"},{"location":"api/#biketour_planner.brouter.route_to_address","title":"<code>route_to_address(lat_from, lon_from, lat_to, lon_to)</code>","text":"<p>Computes a route between two points using BRouter.</p> <p>Parameters:</p> Name Type Description Default <code>lat_from</code> <code>float</code> <p>Latitude of the start point.</p> required <code>lon_from</code> <code>float</code> <p>Longitude of the start point.</p> required <code>lat_to</code> <code>float</code> <p>Latitude of the destination point.</p> required <code>lon_to</code> <code>float</code> <p>Longitude of the destination point.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The routing response as a GPX string.</p> <p>Raises:</p> Type Description <code>RoutingError</code> <p>If BRouter is unreachable or the request fails.</p> Source code in <code>src/biketour_planner/brouter.py</code> <pre><code>def route_to_address(lat_from: float, lon_from: float, lat_to: float, lon_to: float) -&gt; str:\n    \"\"\"Computes a route between two points using BRouter.\n\n    Args:\n        lat_from: Latitude of the start point.\n        lon_from: Longitude of the start point.\n        lat_to: Latitude of the destination point.\n        lon_to: Longitude of the destination point.\n\n    Returns:\n        The routing response as a GPX string.\n\n    Raises:\n        RoutingError: If BRouter is unreachable or the request fails.\n    \"\"\"\n    if not check_brouter_availability():\n        raise RoutingError(\"BRouter server not reachable\")\n\n    config = get_config()\n    base_url = config.routing.brouter_url.rstrip(\"/\")\n    url = f\"{base_url}/brouter\"\n    lonlats = f\"{lon_from:.15g},{lat_from:.15g}|{lon_to:.15g},{lat_to:.15g}\"\n    try:\n        r = requests.get(url, params={\"lonlats\": lonlats, \"profile\": \"trekking\", \"format\": \"gpx\"}, timeout=30)\n        r.raise_for_status()\n        return r.text\n    except Exception as e:\n        raise RoutingError(str(e)) from e\n</code></pre>"},{"location":"api/#biketour_planner.geocode","title":"<code>biketour_planner.geocode</code>","text":"<p>Geocoding utilities for the Bike Tour Planner.</p> <p>This module provides functions to convert postal addresses into geographic coordinates using various geocoding services with fallback strategies and caching.</p>"},{"location":"api/#biketour_planner.geocode-classes","title":"Classes","text":""},{"location":"api/#biketour_planner.geocode-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.geocode.clean_address","title":"<code>clean_address(address)</code>","text":"<p>Cleans an address string from noise and local floor information.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The raw address string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The cleaned address string.</p> Source code in <code>src/biketour_planner/geocode.py</code> <pre><code>def clean_address(address: str) -&gt; str:\n    \"\"\"Cleans an address string from noise and local floor information.\n\n    Args:\n        address: The raw address string.\n\n    Returns:\n        The cleaned address string.\n    \"\"\"\n    address = re.sub(r\"\\s+(Prizemlje|[\\d]+\\.\\s*kat)\\b\", \"\", address, flags=re.IGNORECASE)\n    address = re.sub(r\"\\s+-\\s+\\d+\", \"\", address)\n    address = re.sub(r\"\\bbr\\.\\s+\\d+\", \"\", address)\n    return re.sub(r\"\\s+\", \" \", address).strip()\n</code></pre>"},{"location":"api/#biketour_planner.geocode.extract_city_country","title":"<code>extract_city_country(address)</code>","text":"<p>Extracts city and country from a full address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The full address string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The city and country part of the address.</p> Source code in <code>src/biketour_planner/geocode.py</code> <pre><code>def extract_city_country(address: str) -&gt; str:\n    \"\"\"Extracts city and country from a full address.\n\n    Args:\n        address: The full address string.\n\n    Returns:\n        The city and country part of the address.\n    \"\"\"\n    parts = address.split(\",\")\n    return \",\".join(parts[-2:]).strip() if len(parts) &gt;= 2 else address\n</code></pre>"},{"location":"api/#biketour_planner.geocode.geocode_address","title":"<code>geocode_address(address)</code>","text":"<p>Geocodes an address with caching and multiple strategies.</p> <p>This is the main public entry point for geocoding.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The address to geocode.</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>A tuple of (latitude, longitude).</p> <p>Raises:</p> Type Description <code>GeocodingError</code> <p>If all geocoding strategies fail.</p> Source code in <code>src/biketour_planner/geocode.py</code> <pre><code>def geocode_address(address: str) -&gt; tuple[float, float]:\n    \"\"\"Geocodes an address with caching and multiple strategies.\n\n    This is the main public entry point for geocoding.\n\n    Args:\n        address: The address to geocode.\n\n    Returns:\n        A tuple of (latitude, longitude).\n\n    Raises:\n        GeocodingError: If all geocoding strategies fail.\n    \"\"\"\n    result = _cached_geocode(address)\n    if result:\n        return tuple(result)\n    raise GeocodingError(address, \"All geocoding strategies failed\")\n</code></pre>"},{"location":"api/#biketour_planner.geocode.geocode_with_nominatim","title":"<code>geocode_with_nominatim(address, retries=3)</code>","text":"<p>Geocodes an address using Nominatim.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The address to geocode.</p> required <code>retries</code> <code>int</code> <p>Number of retries on timeout.</p> <code>3</code> <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>A tuple of (latitude, longitude).</p> <p>Raises:</p> Type Description <code>GeocodingError</code> <p>If the address cannot be found or the service is unavailable.</p> Source code in <code>src/biketour_planner/geocode.py</code> <pre><code>def geocode_with_nominatim(address: str, retries: int = 3) -&gt; tuple[float, float]:\n    \"\"\"Geocodes an address using Nominatim.\n\n    Args:\n        address: The address to geocode.\n        retries: Number of retries on timeout.\n\n    Returns:\n        A tuple of (latitude, longitude).\n\n    Raises:\n        GeocodingError: If the address cannot be found or the service is unavailable.\n    \"\"\"\n    for attempt in range(retries):\n        try:\n            location = geolocator_nominatim.geocode(address)\n            sleep(GEOCONTROL_RATELIMIT_SLEEP)\n            if location:\n                return location.latitude, location.longitude\n        except (GeocoderTimedOut, GeocoderServiceError) as e:\n            if attempt &lt; retries - 1:\n                sleep(2)\n                continue\n            raise GeocodingError(address, str(e)) from e\n    raise GeocodingError(address, \"Address not found\")\n</code></pre>"},{"location":"api/#biketour_planner.geocode.geocode_with_photon","title":"<code>geocode_with_photon(address)</code>","text":"<p>Geocodes an address using Photon.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The address to geocode.</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>A tuple of (latitude, longitude).</p> <p>Raises:</p> Type Description <code>GeocodingError</code> <p>If Photon is not available or the address is not found.</p> Source code in <code>src/biketour_planner/geocode.py</code> <pre><code>def geocode_with_photon(address: str) -&gt; tuple[float, float]:\n    \"\"\"Geocodes an address using Photon.\n\n    Args:\n        address: The address to geocode.\n\n    Returns:\n        A tuple of (latitude, longitude).\n\n    Raises:\n        GeocodingError: If Photon is not available or the address is not found.\n    \"\"\"\n    if not geolocator_photon:\n        raise GeocodingError(address, \"Photon not available\")\n    try:\n        location = geolocator_photon.geocode(address)\n        if location:\n            return location.latitude, location.longitude\n    except Exception as e:\n        raise GeocodingError(address, str(e)) from e\n    raise GeocodingError(address, \"Address not found\")\n</code></pre>"},{"location":"api/#biketour_planner.geoapify","title":"<code>biketour_planner.geoapify</code>","text":"<p>Geoapify API integration for tourist sight discovery.</p>"},{"location":"api/#biketour_planner.geoapify-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.geoapify.find_top_tourist_sights","title":"<code>find_top_tourist_sights(lat, lon, radius=None, limit=None)</code>","text":"<p>Finds top tourist sights near a location with caching.</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Latitude.</p> required <code>lon</code> <code>float</code> <p>Longitude.</p> required <code>radius</code> <code>int | None</code> <p>Optional search radius in meters. Defaults to config value.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Optional maximum number of sights. Defaults to config value.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Dictionary containing tourist sights or None.</p> Source code in <code>src/biketour_planner/geoapify.py</code> <pre><code>def find_top_tourist_sights(\n    lat: float, lon: float, radius: int | None = None, limit: int | None = None\n) -&gt; dict[str, Any] | None:\n    \"\"\"Finds top tourist sights near a location with caching.\n\n    Args:\n        lat: Latitude.\n        lon: Longitude.\n        radius: Optional search radius in meters. Defaults to config value.\n        limit: Optional maximum number of sights. Defaults to config value.\n\n    Returns:\n        Dictionary containing tourist sights or None.\n    \"\"\"\n    config = get_config()\n    if radius is None:\n        try:\n            radius = config.geoapify.search_radius_m\n        except (AttributeError, KeyError):\n            radius = GEOAPIFY_DEFAULT_SEARCH_RADIUS_M\n    if limit is None:\n        try:\n            limit = config.geoapify.max_pois\n        except (AttributeError, KeyError):\n            limit = GEOAPIFY_DEFAULT_MAX_POIS\n    return _fetch_tourist_sights(round(lat, 4), round(lon, 4), radius, limit)\n</code></pre>"},{"location":"api/#biketour_planner.geoapify.get_names_as_comma_separated_string","title":"<code>get_names_as_comma_separated_string(data)</code>","text":"<p>Extracts names from Geoapify data and returns them as a comma-separated string.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any] | None</code> <p>The Geoapify API response dictionary.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A comma-separated string of names.</p> Source code in <code>src/biketour_planner/geoapify.py</code> <pre><code>def get_names_as_comma_separated_string(data: dict[str, Any] | None) -&gt; str:\n    \"\"\"Extracts names from Geoapify data and returns them as a comma-separated string.\n\n    Args:\n        data: The Geoapify API response dictionary.\n\n    Returns:\n        A comma-separated string of names.\n    \"\"\"\n    if not data:\n        return \"\"\n    names = []\n    for poi in data.get(\"features\", []):\n        props = poi.get(\"properties\", {})\n        if \"name\" in props:\n            names.append(props[\"name\"])\n        elif \"street\" in props:\n            names.append(props[\"street\"])\n        else:\n            names.append(f\"({props.get('lat')}, {props.get('lon')})\")\n    return \", \".join(names)\n</code></pre>"},{"location":"api/#biketour_planner.pdf_export","title":"<code>biketour_planner.pdf_export</code>","text":"<p>PDF export module for travel planning with clickable hyperlinks.</p> <p>This module creates PDFs directly from booking data with clickable Google Maps links for tourist sights and elevation profiles.</p>"},{"location":"api/#biketour_planner.pdf_export-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.pdf_export.create_tourist_sights_links","title":"<code>create_tourist_sights_links(tourist_sights)</code>","text":"<p>Creates HTML links for tourist sights.</p> <p>Parameters:</p> Name Type Description Default <code>tourist_sights</code> <code>dict | None</code> <p>Geoapify response dictionary or None.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of HTML formatted links for reportlab Paragraph.</p> Source code in <code>src/biketour_planner/pdf_export.py</code> <pre><code>def create_tourist_sights_links(tourist_sights: dict | None) -&gt; list[str]:\n    \"\"\"Creates HTML links for tourist sights.\n\n    Args:\n        tourist_sights: Geoapify response dictionary or None.\n\n    Returns:\n        List of HTML formatted links for reportlab Paragraph.\n    \"\"\"\n    if not tourist_sights or \"features\" not in tourist_sights:\n        return []\n\n    links = []\n    features = tourist_sights.get(\"features\", [])\n\n    for poi in features:\n        if \"properties\" not in poi:\n            continue\n\n        props = poi[\"properties\"]\n\n        # Determine name (with fallbacks)\n        if \"name\" in props:\n            display_name = props[\"name\"]\n        elif \"street\" in props:\n            display_name = props[\"street\"]\n        else:\n            display_name = f\"({props.get('lat')}, {props.get('lon')})\"\n\n        # Extract GPS coordinates\n        lat, lon = props.get(\"lat\"), props.get(\"lon\")\n        if lat is None or lon is None:\n            continue\n\n        # Create Google Maps URL\n        google_maps_url = f\"https://www.google.com/maps/search/?api=1&amp;query={lat},{lon}\"\n\n        # HTML link for reportlab\n        html_link = f'&lt;a href=\"{google_maps_url}\" color=\"blue\"&gt;&lt;u&gt;{display_name}&lt;/u&gt;&lt;/a&gt;'\n        links.append(html_link)\n\n    return links\n</code></pre>"},{"location":"api/#biketour_planner.pdf_export.export_bookings_to_pdf","title":"<code>export_bookings_to_pdf(json_path, output_path, output_dir=None, gpx_dir=None, title='Bike Tour Planning', excel_info_path=None)</code>","text":"<p>Exports booking info to a PDF file with clickable links and elevation profiles.</p> <p>Parameters:</p> Name Type Description Default <code>json_path</code> <code>Path</code> <p>Path to JSON file with bookings.</p> required <code>output_path</code> <code>Path</code> <p>Path for the output PDF file.</p> required <code>output_dir</code> <code>Path</code> <p>Path to directory with merged GPX files.</p> <code>None</code> <code>gpx_dir</code> <code>Path</code> <p>Path to directory with original GPX files for passes.</p> <code>None</code> <code>title</code> <code>str</code> <p>Document title.</p> <code>'Bike Tour Planning'</code> <code>excel_info_path</code> <code>Path</code> <p>Path to Excel file with additional daily info.</p> <code>None</code> Source code in <code>src/biketour_planner/pdf_export.py</code> <pre><code>def export_bookings_to_pdf(\n    json_path: Path,\n    output_path: Path,\n    output_dir: Path = None,\n    gpx_dir: Path = None,\n    title: str = \"Bike Tour Planning\",\n    excel_info_path: Path = None,\n) -&gt; None:\n    \"\"\"Exports booking info to a PDF file with clickable links and elevation profiles.\n\n    Args:\n        json_path: Path to JSON file with bookings.\n        output_path: Path for the output PDF file.\n        output_dir: Path to directory with merged GPX files.\n        gpx_dir: Path to directory with original GPX files for passes.\n        title: Document title.\n        excel_info_path: Path to Excel file with additional daily info.\n    \"\"\"\n    # Register Unicode fonts\n    try:\n        pdfmetrics.registerFont(TTFont(\"DejaVuSans\", \"DejaVuSans.ttf\"))\n        pdfmetrics.registerFont(TTFont(\"DejaVuSans-Bold\", \"DejaVuSans-Bold.ttf\"))\n        default_font, bold_font = \"DejaVuSans\", \"DejaVuSans-Bold\"\n    except Exception:\n        try:\n            pdfmetrics.registerFont(TTFont(\"ArialUnicode\", \"ARIALUNI.TTF\"))\n            default_font, bold_font = \"ArialUnicode\", \"ArialUnicode\"\n        except Exception:\n            print(\"\u26a0\ufe0f Warning: No Unicode font found. Special characters might not be displayed correctly.\")\n            default_font, bold_font = \"Helvetica\", \"Helvetica-Bold\"\n\n    # Load JSON\n    with open(json_path, encoding=\"utf-8\") as f:\n        bookings = json.load(f)\n\n    bookings_sorted = sorted(bookings, key=lambda x: x.get(\"arrival_date\", \"9999-12-31\"))\n\n    daily_info = {}\n    if excel_info_path and excel_info_path.exists():\n        daily_info = read_daily_info_from_excel(excel_info_path)\n\n    # Create PDF\n    output_path.parent.mkdir(parents=True, exist_ok=True)\n    doc = SimpleDocTemplate(\n        str(output_path),\n        pagesize=landscape(A4),\n        rightMargin=1 * cm,\n        leftMargin=1 * cm,\n        topMargin=1.5 * cm,\n        bottomMargin=1.5 * cm,\n    )\n\n    styles = getSampleStyleSheet()\n    title_style = ParagraphStyle(\n        \"CustomTitle\",\n        parent=styles[\"Heading1\"],\n        fontSize=16,\n        textColor=colors.HexColor(\"#1f4788\"),\n        alignment=TA_CENTER,\n        fontName=bold_font,\n        spaceAfter=12,\n    )\n    cell_style = ParagraphStyle(\"CellStyle\", parent=styles[\"Normal\"], fontSize=9, leading=11, fontName=default_font)\n    link_style = ParagraphStyle(\n        \"LinkStyle\", parent=styles[\"Normal\"], fontSize=8, leading=10, textColor=colors.blue, fontName=default_font\n    )\n    summary_style = ParagraphStyle(\n        \"SummaryStyle\",\n        parent=styles[\"Normal\"],\n        fontSize=11,\n        leading=14,\n        fontName=bold_font,\n        textColor=colors.HexColor(\"#1f4788\"),\n        spaceAfter=6,\n    )\n\n    story = [Paragraph(title, title_style), Spacer(1, 0.5 * cm)]\n    table_data = [\n        [\n            Paragraph(\"&lt;b&gt;Tag&lt;/b&gt;\", cell_style),\n            Paragraph(\"&lt;b&gt;Datum&lt;/b&gt;\", cell_style),\n            Paragraph(\"&lt;b&gt;Von&lt;/b&gt;\", cell_style),\n            Paragraph(\"&lt;b&gt;Nach&lt;/b&gt;\", cell_style),\n            Paragraph(\"&lt;b&gt;km&lt;/b&gt;\", cell_style),\n            Paragraph(\"&lt;b&gt;Unterkunft&lt;/b&gt;\", cell_style),\n            Paragraph(\"&lt;b&gt;Hm/Max&lt;/b&gt;\", cell_style),\n            Paragraph(\"&lt;b&gt;GPX&lt;/b&gt;\", cell_style),\n            Paragraph(\"&lt;b&gt;Infos, Berge und Site Seeing&lt;/b&gt;\", cell_style),\n            Paragraph(\"&lt;b&gt;Preis&lt;/b&gt;\", cell_style),\n            Paragraph(\"&lt;b&gt;Storno&lt;/b&gt;\", cell_style),\n        ]\n    ]\n\n    previous_city = previous_departure_date = None\n    day_counter, total_km, total_ascent, total_price = 1, 0.0, 0, 0.0\n\n    for booking in bookings_sorted:\n        # Check for intermediate days\n        if previous_departure_date and booking.get(\"arrival_date\"):\n            try:\n                prev_departure = datetime.fromisoformat(previous_departure_date)\n                current_arrival = datetime.fromisoformat(booking[\"arrival_date\"])\n                days_between = (current_arrival - prev_departure).days\n                if days_between &gt; 0:\n                    for day_offset in range(days_between):\n                        intermediate_date = prev_departure + timedelta(days=day_offset)\n                        intermediate_date_iso = intermediate_date.strftime(\"%Y-%m-%d\")\n                        intermediate_info = daily_info.get(intermediate_date_iso, [])\n                        row = [\n                            Paragraph(str(day_counter), cell_style),\n                            Paragraph(intermediate_date.strftime(\"%a, %d.%m.%Y\"), cell_style),\n                            Paragraph(previous_city or \"\", cell_style),\n                            \"\",\n                            \"\",\n                            \"\",\n                            \"\",\n                            \"\",\n                            Paragraph(\"&lt;br/&gt;\".join(intermediate_info), link_style),\n                            \"\",\n                            \"\",\n                        ]\n                        table_data.append(row)\n                        day_counter += 1\n            except ValueError:\n                pass\n\n        arrival_date = booking.get(\"arrival_date\", \"\")\n        if arrival_date:\n            try:\n                date_obj = datetime.fromisoformat(arrival_date)\n                date_str = date_obj.strftime(\"%a, %d.%m.%Y\")\n            except ValueError:\n                date_str = arrival_date\n        else:\n            date_str = \"\"\n\n        current_city = extract_city_name(booking.get(\"address\", \"\"))\n        accommodation_text = create_accommodation_text(booking)\n\n        km_values, hm_max_values, gpx_tracks = [], [], []\n\n        # Main track stats\n        if booking.get(\"gpx_track_final\"):\n            gpx_tracks.append(str(booking.get(\"gpx_track_final\", \"\"))[:12])\n            km_val = booking.get(\"total_distance_km\")\n            km_values.append(f\"{km_val:.0f}\" if km_val else \"\")\n            hm = booking.get(\"total_ascent_m\")\n            max_elev = booking.get(\"max_elevation_m\")\n            hm_max_values.append(f\"{hm} / {max_elev}\" if hm or max_elev else \"\")\n            if km_val:\n                total_km += float(km_val)\n            if hm:\n                total_ascent += int(hm)\n\n        # Pass tracks stats\n        for pass_track in booking.get(\"paesse_tracks\", []):\n            pass_file = pass_track.get(\"file\", \"\")[:12]\n            gpx_tracks.append(f\"{pass_file}&lt;br/&gt;({pass_track.get('passname', '')})\")\n            pass_gpx_path = gpx_dir / pass_track.get(\"file\", \"\") if gpx_dir else None\n            if pass_gpx_path and pass_gpx_path.exists():\n                gpx = read_gpx_file(pass_gpx_path)\n                if gpx and gpx.tracks:\n                    p_max, p_dist, p_asc, _ = get_statistics4track(gpx)\n                    pass_km = p_dist / 1000\n                    km_values.append(f\"{pass_km:.0f}\")\n                    total_km += pass_km\n                    hm_max_values.append(f\"{int(round(p_asc))} / {int(round(p_max)) if p_max != float('-inf') else ''}\")\n                    total_ascent += int(round(p_asc))\n                else:\n                    km_values.append(\"\")\n                    hm_max_values.append(\"\")\n            else:\n                km_values.append(\"\")\n                hm_max_values.append(\"\")\n\n        if booking.get(\"total_price\"):\n            total_price += float(booking.get(\"total_price\", 0))\n\n        sights_links = create_tourist_sights_links(booking.get(\"tourist_sights\"))\n        for pass_track in booking.get(\"paesse_tracks\", []):\n            p_lat, p_lon = pass_track.get(\"latitude\"), pass_track.get(\"longitude\")\n            if pass_track.get(\"passname\") and p_lat is not None and p_lon is not None:\n                google_maps_url = f\"https://www.google.com/maps/search/?api=1&amp;query={p_lat},{p_lon}\"\n                sights_links.append(f'&lt;a href=\"{google_maps_url}\" color=\"blue\"&gt;&lt;u&gt;{pass_track[\"passname\"]}&lt;/u&gt;&lt;/a&gt;')\n\n        if arrival_date in daily_info:\n            sights_links.extend(daily_info[arrival_date])\n\n        cancellation_style = get_cancellation_cell_style(\n            booking.get(\"free_cancel_until\"), booking.get(\"arrival_date\"), cell_style\n        )\n\n        row = [\n            Paragraph(str(day_counter), cell_style),\n            Paragraph(date_str, cell_style),\n            Paragraph(previous_city or \"\", cell_style),\n            Paragraph(current_city, cell_style),\n            Paragraph(\"&lt;br/&gt;\".join(km_values), cell_style),\n            Paragraph(accommodation_text.replace(\"\\n\", \"&lt;br/&gt;\"), cell_style),\n            Paragraph(\"&lt;br/&gt;\".join(hm_max_values), cell_style),\n            Paragraph(\"&lt;br/&gt;\".join(gpx_tracks), cell_style),\n            Paragraph(\"&lt;br/&gt;\".join(sights_links), link_style),\n            Paragraph(str(booking.get(\"total_price\", \"\")), cell_style),\n            Paragraph(\n                f\"bis: {booking.get('free_cancel_until', '')}\" if booking.get(\"free_cancel_until\") else \"\", cancellation_style\n            ),\n        ]\n        table_data.append(row)\n\n        # Add stay days for this booking\n        if booking.get(\"arrival_date\") and booking.get(\"departure_date\"):\n            try:\n                arrival = datetime.fromisoformat(booking[\"arrival_date\"])\n                departure = datetime.fromisoformat(booking[\"departure_date\"])\n                stay_days_count = (departure - arrival).days\n                if stay_days_count &gt; 1:\n                    for d_off in range(1, stay_days_count):\n                        stay_date = arrival + timedelta(days=d_off)\n                        stay_date_iso = stay_date.strftime(\"%Y-%m-%d\")\n                        stay_info = daily_info.get(stay_date_iso, [])\n                        day_counter += 1\n                        table_data.append(\n                            [\n                                Paragraph(str(day_counter), cell_style),\n                                Paragraph(stay_date.strftime(\"%a, %d.%m.%Y\"), cell_style),\n                                Paragraph(current_city, cell_style),\n                                \"\",\n                                \"\",\n                                Paragraph(accommodation_text.replace(\"\\n\", \"&lt;br/&gt;\"), cell_style),\n                                \"\",\n                                \"\",\n                                Paragraph(\"&lt;br/&gt;\".join(stay_info), link_style),\n                                \"\",\n                                \"\",\n                            ]\n                        )\n            except ValueError:\n                pass\n\n        previous_city, previous_departure_date, day_counter = current_city, booking.get(\"departure_date\"), day_counter + 1\n\n    # Checkout row for last accommodation\n    if bookings_sorted and previous_departure_date:\n        last_booking = bookings_sorted[-1]\n        last_departure_date = last_booking.get(\"departure_date\")\n        last_city = extract_city_name(last_booking.get(\"address\", \"\"))\n        if last_departure_date:\n            try:\n                last_checkout = datetime.fromisoformat(last_departure_date)\n\n                checkout_date_iso = last_checkout.strftime(\"%Y-%m-%d\")\n                checkout_info = daily_info.get(checkout_date_iso, [])\n                table_data.append(\n                    [\n                        Paragraph(str(day_counter), cell_style),\n                        Paragraph(last_checkout.strftime(\"%a, %d.%m.%Y\"), cell_style),\n                        Paragraph(last_city, cell_style),\n                        Paragraph(\"Checkout\", cell_style),\n                        \"\",\n                        \"\",\n                        \"\",\n                        \"\",\n                        Paragraph(\"&lt;br/&gt;\".join(checkout_info), link_style),\n                        \"\",\n                        \"\",\n                    ]\n                )\n            except ValueError:\n                pass\n\n    col_widths = [1.0 * cm, 2.1 * cm, 2.2 * cm, 2.2 * cm, 1.0 * cm, 5.3 * cm, 1.8 * cm, 2.2 * cm, 4.1 * cm, 1.2 * cm, 2.0 * cm]\n    table = Table(table_data, colWidths=col_widths, repeatRows=1)\n    table.setStyle(\n        TableStyle(\n            [\n                (\"BACKGROUND\", (0, 0), (-1, 0), colors.HexColor(\"#4472C4\")),\n                (\"TEXTCOLOR\", (0, 0), (-1, 0), colors.whitesmoke),\n                (\"ALIGN\", (0, 0), (-1, 0), \"CENTER\"),\n                (\"FONTNAME\", (0, 0), (-1, 0), bold_font),\n                (\"FONTSIZE\", (0, 0), (-1, 0), 10),\n                (\"BOTTOMPADDING\", (0, 0), (-1, 0), 8),\n                (\"BACKGROUND\", (0, 1), (-1, -1), colors.white),\n                (\"TEXTCOLOR\", (0, 1), (-1, -1), colors.black),\n                (\"ALIGN\", (0, 1), (0, -1), \"CENTER\"),\n                (\"ALIGN\", (4, 1), (4, -1), \"RIGHT\"),\n                (\"ALIGN\", (9, 1), (9, -1), \"RIGHT\"),\n                (\"FONTNAME\", (0, 1), (-1, -1), default_font),\n                (\"FONTSIZE\", (0, 1), (-1, -1), 9),\n                (\"VALIGN\", (0, 0), (-1, -1), \"TOP\"),\n                (\"GRID\", (0, 0), (-1, -1), 0.5, colors.grey),\n                (\"LINEBELOW\", (0, 0), (-1, 0), 2, colors.HexColor(\"#4472C4\")),\n                (\"LEFTPADDING\", (0, 0), (-1, -1), 4),\n                (\"RIGHTPADDING\", (0, 0), (-1, -1), 4),\n                (\"TOPPADDING\", (0, 1), (-1, -1), 4),\n                (\"BOTTOMPADDING\", (0, 1), (-1, -1), 4),\n            ]\n        )\n    )\n    story.append(table)\n    story.append(Spacer(1, 0.8 * cm))\n    summary_text = (\n        f\"&lt;b&gt;Gesamtkilometer:&lt;/b&gt; {total_km:.2f} km       \"\n        f\"&lt;b&gt;Gesamth\u00f6henmeter:&lt;/b&gt; {total_ascent} m       \"\n        f\"&lt;b&gt;Gesamtkosten:&lt;/b&gt; {total_price:.2f} \u20ac\"\n    )\n    story.append(Paragraph(summary_text, summary_style))\n\n    if output_dir:\n        gpx_files = get_merged_gpx_files_from_bookings(bookings_sorted, output_dir)\n        # Sequenzielle Erstellung der H\u00f6henprofile (User-Wunsch zur Vermeidung von leeren Plots)\n        add_elevation_profiles_to_story_seq(\n            story, gpx_files, bookings_sorted, gpx_dir or output_dir, title_style, page_width_cm=PDF_PAGE_WIDTH_CM\n        )\n\n    doc.build(story)\n    print(f\"PDF-Datei erstellt: {output_path}\")\n</code></pre>"},{"location":"api/#biketour_planner.pdf_export.get_cancellation_cell_style","title":"<code>get_cancellation_cell_style(free_cancel_until, arrival_date, base_cell_style)</code>","text":"<p>Creates a ParagraphStyle for cancellation cells based on the timeframe.</p> <p>Parameters:</p> Name Type Description Default <code>free_cancel_until</code> <code>str | None</code> <p>ISO date of cancellation deadline or None.</p> required <code>arrival_date</code> <code>str</code> <p>ISO date of arrival.</p> required <code>base_cell_style</code> <code>ParagraphStyle</code> <p>Base ParagraphStyle to copy.</p> required <p>Returns:</p> Type Description <code>ParagraphStyle</code> <p>ParagraphStyle with adjusted text color.</p> Source code in <code>src/biketour_planner/pdf_export.py</code> <pre><code>def get_cancellation_cell_style(\n    free_cancel_until: str | None, arrival_date: str, base_cell_style: ParagraphStyle\n) -&gt; ParagraphStyle:\n    \"\"\"Creates a ParagraphStyle for cancellation cells based on the timeframe.\n\n    Args:\n        free_cancel_until: ISO date of cancellation deadline or None.\n        arrival_date: ISO date of arrival.\n        base_cell_style: Base ParagraphStyle to copy.\n\n    Returns:\n        ParagraphStyle with adjusted text color.\n    \"\"\"\n    text_color = colors.black\n\n    if free_cancel_until and arrival_date:\n        try:\n            cancel_date = datetime.fromisoformat(free_cancel_until)\n            arrival = datetime.fromisoformat(arrival_date)\n            days_diff = (arrival - cancel_date).days\n\n            if days_diff &lt; 7:\n                text_color = colors.HexColor(\"#008000\")  # Green\n            elif days_diff &gt; 30:\n                text_color = colors.HexColor(\"#DC143C\")  # Crimson Red\n        except ValueError:\n            pass\n\n    return ParagraphStyle(f\"CancellationStyle_{id(free_cancel_until)}\", parent=base_cell_style, textColor=text_color)\n</code></pre>"},{"location":"api/#biketour_planner.excel_export","title":"<code>biketour_planner.excel_export</code>","text":"<p>Excel export functionality for the Bike Tour Planner.</p>"},{"location":"api/#biketour_planner.excel_export-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.excel_export.create_accommodation_text","title":"<code>create_accommodation_text(booking)</code>","text":"<p>Creates a formatted text for accommodation including name, address, and amenities.</p> <p>Parameters:</p> Name Type Description Default <code>booking</code> <code>dict</code> <p>Dictionary containing booking information.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Formatted multi-line text for the Excel cell.</p> Source code in <code>src/biketour_planner/excel_export.py</code> <pre><code>def create_accommodation_text(booking: dict) -&gt; str:\n    \"\"\"Creates a formatted text for accommodation including name, address, and amenities.\n\n    Args:\n        booking: Dictionary containing booking information.\n\n    Returns:\n        Formatted multi-line text for the Excel cell.\n    \"\"\"\n    text_parts = []\n\n    # Hotel name\n    if booking.get(\"hotel_name\"):\n        text_parts.append(booking[\"hotel_name\"])\n\n    # Address\n    if booking.get(\"address\"):\n        text_parts.append(booking[\"address\"])\n\n    # Amenities\n    amenities = []\n    if booking.get(\"has_washing_machine\"):\n        amenities.append(\"Wasch\")\n    if booking.get(\"has_kitchen\"):\n        amenities.append(\"K\u00fcche\")\n    if booking.get(\"has_breakfast\"):\n        amenities.append(\"Fr\u00fch\")\n    if booking.get(\"checkin_time\"):\n        amenities.append(\"Checkin: \" + booking[\"checkin_time\"])\n\n    if amenities:\n        text_parts.append(\", \".join(amenities))\n\n    return \"\\n\".join(text_parts)\n</code></pre>"},{"location":"api/#biketour_planner.excel_export.export_bookings_to_excel","title":"<code>export_bookings_to_excel(json_path, template_path, output_path, start_row=4)</code>","text":"<p>Exports booking information to an Excel file based on a template.</p> <p>Automatically inserts empty lines for days without a booking (between the departure date of one booking and the arrival date of the next).</p> <p>Parameters:</p> Name Type Description Default <code>json_path</code> <code>Path</code> <p>Path to the JSON file with bookings.</p> required <code>template_path</code> <code>Path</code> <p>Path to the Excel template file.</p> required <code>output_path</code> <code>Path</code> <p>Path for the output Excel file.</p> required <code>start_row</code> <code>int</code> <p>Row to start inserting data (1-based).</p> <code>4</code> Source code in <code>src/biketour_planner/excel_export.py</code> <pre><code>def export_bookings_to_excel(json_path: Path, template_path: Path, output_path: Path, start_row: int = 4) -&gt; None:\n    \"\"\"Exports booking information to an Excel file based on a template.\n\n    Automatically inserts empty lines for days without a booking (between the departure date\n    of one booking and the arrival date of the next).\n\n    Args:\n        json_path: Path to the JSON file with bookings.\n        template_path: Path to the Excel template file.\n        output_path: Path for the output Excel file.\n        start_row: Row to start inserting data (1-based).\n    \"\"\"\n    # Load JSON\n    with open(json_path, encoding=\"utf-8\") as f:\n        bookings = json.load(f)\n\n    # Sort by arrival date\n    bookings_sorted = sorted(bookings, key=lambda x: x.get(\"arrival_date\", \"9999-12-31\"))\n\n    # Load template\n    wb = load_workbook(template_path)\n    ws = wb.active\n\n    # Previous city for start-destination determination\n    previous_city = None\n    previous_departure_date = None\n\n    # Current day counter\n    day_counter = 1\n\n    # Current Excel row\n    current_row = start_row\n\n    # Insert data\n    for booking in bookings_sorted:\n        # Check if empty rows for gap days need to be inserted\n        if previous_departure_date and booking.get(\"arrival_date\"):\n            try:\n                prev_departure = datetime.fromisoformat(previous_departure_date)\n                current_arrival = datetime.fromisoformat(booking[\"arrival_date\"])\n\n                # Calculate difference in days\n                days_between = (current_arrival - prev_departure).days\n\n                # Insert empty rows (one row per gap day)\n                if days_between &gt; 0:\n                    for day_offset in range(days_between):\n                        # Column A: Day counter\n                        ws[f\"A{current_row}\"] = day_counter\n\n                        # Column B: Date of the gap day\n                        intermediate_date = prev_departure + timedelta(days=day_offset)\n                        ws[f\"B{current_row}\"] = intermediate_date\n                        ws[f\"B{current_row}\"].number_format = \"DDD, DD.MM.YYYY\"\n\n                        # Column C: Start city (previous city)\n                        if previous_city:\n                            ws[f\"C{current_row}\"] = previous_city\n\n                        day_counter += 1\n                        current_row += 1\n\n            except ValueError:\n                pass\n\n        # Insert normal booking row\n        row = current_row\n\n        # Column A: Day counter\n        ws[f\"A{row}\"] = day_counter\n\n        # Column B: Date\n        arrival_date = booking.get(\"arrival_date\", \"\")\n        if arrival_date:\n            try:\n                date_obj = datetime.fromisoformat(arrival_date)\n                ws[f\"B{row}\"] = date_obj\n                ws[f\"B{row}\"].number_format = \"DDD, DD.MM.YYYY\"\n            except ValueError:\n                ws[f\"B{row}\"] = arrival_date\n\n        # Column C: Start city (previous city)\n        if previous_city:\n            ws[f\"C{row}\"] = previous_city\n\n        # Column D: Destination city (current city)\n        current_city = extract_city_name(booking.get(\"address\", \"\"))\n        ws[f\"D{row}\"] = current_city\n\n        # Column E: distance in km\n        ws[f\"E{row}\"] = booking.get(\"total_distance_km\", \"\")\n\n        # Column F: Accommodation with name, address, and amenities\n        accommodation_text = create_accommodation_text(booking)\n        ws[f\"F{row}\"] = accommodation_text\n        ws[f\"F{row}\"].alignment = Alignment(wrap_text=True, vertical=\"top\")\n\n        # Column G: Ascent / Max Elevation\n        ws[f\"G{row}\"] = f\"{booking.get('total_ascent_m', '')} / {booking.get('max_elevation_m', '')}\"\n\n        # Column H: Final track name\n        ws[f\"H{row}\"] = booking.get(\"gpx_track_final\", \"\")[:12]\n\n        # Column I: Tourist Sights\n        create_tourist_sights_hyperlinks(ws, row, booking.get(\"tourist_sights\", None))\n\n        # Column J: Price\n        ws[f\"J{row}\"] = booking.get(\"total_price\", \"\")\n\n        # Column K: Cancellation info\n        ws[f\"K{row}\"] = f\"Stornierung bis: {booking.get('free_cancel_until', '')}\"\n\n        # Update variables for next iteration\n        previous_city = current_city\n        previous_departure_date = booking.get(\"departure_date\")\n        day_counter += 1\n        current_row += 1\n\n    # Save output\n    wb.save(output_path)\n    print(f\"Excel file created: {output_path}\")\n</code></pre>"},{"location":"api/#biketour_planner.excel_export.extract_city_name","title":"<code>extract_city_name(address)</code>","text":"<p>Extracts only the city name from a full address string.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Full address, e.g., \"Street 1, 21000 Split, Croatia\"</p> required <p>Returns:</p> Type Description <code>str</code> <p>The city name, e.g., \"Split\".</p> Source code in <code>src/biketour_planner/excel_export.py</code> <pre><code>def extract_city_name(address: str) -&gt; str:\n    \"\"\"Extracts only the city name from a full address string.\n\n    Args:\n        address: Full address, e.g., \"Street 1, 21000 Split, Croatia\"\n\n    Returns:\n        The city name, e.g., \"Split\".\n    \"\"\"\n    if not address:\n        return \"\"\n\n    # Format: \"Street, ZIP City, Country\"\n    # We want only \"City\"\n\n    # Remove country at the end (after last comma)\n    parts = address.split(\",\")\n\n    # Determine the part that might contain the city\n    if len(parts) &gt;= 2:\n        # Take the second to last part (should be \"ZIP City\")\n        city_part = parts[-2].strip()\n    else:\n        # If no commas, take the whole string\n        city_part = address.strip()\n\n    # Remove ZIP (leading digits and spaces)\n    city_match = re.search(r\"^\\d+\\s+(.+)$\", city_part)\n    if city_match:\n        return city_match.group(1).strip()\n\n    # Fallback to cleaned city part\n    return city_part\n</code></pre>"},{"location":"api/#biketour_planner.ics_export","title":"<code>biketour_planner.ics_export</code>","text":"<p>ICS-Export-Modul f\u00fcr Reiseplanung.</p> <p>Dieses Modul erstellt ICS-Kalenderdateien mit: - \u00dcbernachtungsereignissen (mit vollst\u00e4ndigen Buchungsdetails) - Stornierungserinnerungen (48h vor Stornierungsfrist)</p>"},{"location":"api/#biketour_planner.ics_export-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.ics_export.create_accommodation_description","title":"<code>create_accommodation_description(booking)</code>","text":"<p>Erstellt eine Beschreibung f\u00fcr \u00dcbernachtungsereignisse.</p> <p>Extrahiert alle relevanten Informationen aus dem Buchungs-Dictionary und formatiert sie f\u00fcr die Kalenderbeschreibung.</p> <p>Parameters:</p> Name Type Description Default <code>booking</code> <code>dict</code> <p>Buchungs-Dictionary mit Informationen zur Unterkunft.     Verwendet werden:     - hotel_name: Name der Unterkunft     - address: Vollst\u00e4ndige Adresse     - phone: Telefonnummer     - checkin_time: Fr\u00fcheste Check-in-Zeit     - has_kitchen: Boolean f\u00fcr K\u00fcchenausstattung     - has_washing_machine: Boolean f\u00fcr Waschmaschine     - has_breakfast: Boolean f\u00fcr Fr\u00fchst\u00fcck     - total_price: Gesamtpreis der Buchung     - free_cancel_until: Datum der kostenlosen Stornierungsfrist     - latitude, longitude: GPS-Koordinaten</p> required <p>Returns:</p> Type Description <code>str</code> <p>Formatierter mehrzeiliger Beschreibungstext.</p> Source code in <code>src/biketour_planner/ics_export.py</code> <pre><code>def create_accommodation_description(booking: dict) -&gt; str:\n    \"\"\"Erstellt eine Beschreibung f\u00fcr \u00dcbernachtungsereignisse.\n\n    Extrahiert alle relevanten Informationen aus dem Buchungs-Dictionary\n    und formatiert sie f\u00fcr die Kalenderbeschreibung.\n\n    Args:\n        booking: Buchungs-Dictionary mit Informationen zur Unterkunft.\n                Verwendet werden:\n                - hotel_name: Name der Unterkunft\n                - address: Vollst\u00e4ndige Adresse\n                - phone: Telefonnummer\n                - checkin_time: Fr\u00fcheste Check-in-Zeit\n                - has_kitchen: Boolean f\u00fcr K\u00fcchenausstattung\n                - has_washing_machine: Boolean f\u00fcr Waschmaschine\n                - has_breakfast: Boolean f\u00fcr Fr\u00fchst\u00fcck\n                - total_price: Gesamtpreis der Buchung\n                - free_cancel_until: Datum der kostenlosen Stornierungsfrist\n                - latitude, longitude: GPS-Koordinaten\n\n    Returns:\n        Formatierter mehrzeiliger Beschreibungstext.\n    \"\"\"\n    lines = []\n\n    # Unterkunftsname\n    if booking.get(\"hotel_name\"):\n        lines.append(f\"Unterkunft: {booking['hotel_name']}\")\n\n    # Adresse\n    if booking.get(\"address\"):\n        lines.append(f\"Adresse: {booking['address']}\")\n\n    # Telefon\n    if booking.get(\"phone\"):\n        lines.append(f\"Telefon: {booking['phone']}\")\n\n    # Check-in Zeit\n    if booking.get(\"checkin_time\"):\n        lines.append(f\"Check-in ab: {booking['checkin_time']}\")\n\n    # Ausstattung\n    amenities = []\n    if booking.get(\"has_kitchen\"):\n        amenities.append(\"K\u00fcche\")\n    if booking.get(\"has_washing_machine\"):\n        amenities.append(\"Waschmaschine\")\n    if booking.get(\"has_breakfast\"):\n        amenities.append(\"Fr\u00fchst\u00fcck\")\n\n    if amenities:\n        lines.append(f\"Ausstattung: {', '.join(amenities)}\")\n\n    # Preis\n    if booking.get(\"total_price\"):\n        lines.append(f\"Preis: {booking['total_price']:.2f} \u20ac\")\n\n    # Stornierungsfrist\n    if booking.get(\"free_cancel_until\"):\n        lines.append(f\"Kostenlose Stornierung bis: {booking['free_cancel_until']}\")\n\n    # GPS-Koordinaten (als Google Maps Link)\n    if booking.get(\"latitude\") and booking.get(\"longitude\"):\n        lat = booking[\"latitude\"]\n        lon = booking[\"longitude\"]\n        lines.append(f\"Google Maps: https://www.google.com/maps/search/?api=1&amp;query={lat},{lon}\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/#biketour_planner.ics_export.create_ics_event","title":"<code>create_ics_event(summary, start_date, end_date, description='', location='')</code>","text":"<p>Erstellt einen einzelnen ICS-Event-Block.</p> <p>Parameters:</p> Name Type Description Default <code>summary</code> <code>str</code> <p>Titel des Events.</p> required <code>start_date</code> <code>datetime</code> <p>Startdatum und -zeit des Events.</p> required <code>end_date</code> <code>datetime</code> <p>Enddatum und -zeit des Events.</p> required <code>description</code> <code>str</code> <p>Optionale Beschreibung des Events.</p> <code>''</code> <code>location</code> <code>str</code> <p>Optionaler Ort des Events.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>ICS-formatierter Event-String im VCALENDAR-Format.</p> Note <ul> <li>Verwendet VALUE=DATE f\u00fcr Ganztagesevents</li> <li>Escapet Sonderzeichen gem\u00e4\u00df ICS-Spezifikation</li> <li>Bricht lange Zeilen bei 75 Zeichen um</li> </ul> Source code in <code>src/biketour_planner/ics_export.py</code> <pre><code>def create_ics_event(\n    summary: str,\n    start_date: datetime,\n    end_date: datetime,\n    description: str = \"\",\n    location: str = \"\",\n) -&gt; str:\n    \"\"\"Erstellt einen einzelnen ICS-Event-Block.\n\n    Args:\n        summary: Titel des Events.\n        start_date: Startdatum und -zeit des Events.\n        end_date: Enddatum und -zeit des Events.\n        description: Optionale Beschreibung des Events.\n        location: Optionaler Ort des Events.\n\n    Returns:\n        ICS-formatierter Event-String im VCALENDAR-Format.\n\n    Note:\n        - Verwendet VALUE=DATE f\u00fcr Ganztagesevents\n        - Escapet Sonderzeichen gem\u00e4\u00df ICS-Spezifikation\n        - Bricht lange Zeilen bei 75 Zeichen um\n    \"\"\"\n    # Generiere eindeutige UID basierend auf Zeitstempel und Summary\n    uid = f\"{start_date.strftime('%Y%m%d%H%M%S')}-{hash(summary)}@biketour-planner\"\n\n    # Erstelle Zeitstempel f\u00fcr CREATED und DTSTAMP\n    now = datetime.utcnow().strftime(\"%Y%m%dT%H%M%SZ\")\n\n    # F\u00fcr Ganztagesevents (keine Uhrzeit)\n    start_str = start_date.strftime(\"%Y%m%d\")\n    end_str = end_date.strftime(\"%Y%m%d\")\n\n    # Escape Sonderzeichen in Text (ICS-Spec: Kommas, Semikolons, Backslashes)\n    def escape_text(text: str) -&gt; str:\n        \"\"\"Escapet Sonderzeichen f\u00fcr ICS-Format.\"\"\"\n        return text.replace(\"\\\\\", \"\\\\\\\\\").replace(\",\", \"\\\\,\").replace(\";\", \"\\\\;\").replace(\"\\n\", \"\\\\n\")\n\n    event = [\n        \"BEGIN:VEVENT\",\n        f\"UID:{uid}\",\n        f\"DTSTAMP:{now}\",\n        f\"DTSTART;VALUE=DATE:{start_str}\",\n        f\"DTEND;VALUE=DATE:{end_str}\",\n        f\"SUMMARY:{escape_text(summary)}\",\n    ]\n\n    if description:\n        # Breche lange Zeilen nach ICS-Spec (max 75 Zeichen pro Zeile)\n        desc_escaped = escape_text(description)\n        desc_line = f\"DESCRIPTION:{desc_escaped}\"\n\n        # Umbrechen bei &gt; ICS_MAX_LINE_LENGTH Zeichen (mit Continuation auf neuer Zeile)\n        if len(desc_line) &gt; ICS_MAX_LINE_LENGTH:\n            lines = []\n            current_line = desc_line[:ICS_MAX_LINE_LENGTH]\n            remaining = desc_line[ICS_MAX_LINE_LENGTH:]\n            lines.append(current_line)\n\n            while remaining:\n                lines.append(\" \" + remaining[: ICS_MAX_LINE_LENGTH - 1])  # Space-Prefix f\u00fcr Continuation\n                remaining = remaining[ICS_MAX_LINE_LENGTH - 1 :]\n\n            event.extend(lines)\n        else:\n            event.append(desc_line)\n\n    if location:\n        event.append(f\"LOCATION:{escape_text(location)}\")\n\n    event.append(\"END:VEVENT\")\n\n    return \"\\n\".join(event)\n</code></pre>"},{"location":"api/#biketour_planner.ics_export.export_bookings_to_ics","title":"<code>export_bookings_to_ics(bookings, output_path)</code>","text":"<p>Exportiert Buchungsinformationen in eine ICS-Kalenderdatei.</p> <p>Erstellt eine iCalendar-kompatible Datei (.ics) mit zwei Arten von Events:</p> <ol> <li> <p>\u00dcbernachtungsereignisse: Ganztagesevents von arrival_date bis    departure_date mit vollst\u00e4ndigen Buchungsdetails (Adresse, Ausstattung,    Preis, etc.)</p> </li> <li> <p>Stornierungserinnerungen: Ganztagesevents 48 Stunden vor der    kostenlosen Stornierungsfrist (free_cancel_until) als Reminder.</p> </li> </ol> <p>Die generierten ICS-Dateien k\u00f6nnen in alle g\u00e4ngigen Kalender-Anwendungen importiert werden (Google Calendar, Outlook, Apple Calendar, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>bookings</code> <code>list[dict]</code> <p>Liste mit Buchungs-Dictionaries. Erforderliche Keys:      - arrival_date: ISO-Datum (YYYY-MM-DD)      - departure_date: ISO-Datum (YYYY-MM-DD)      - hotel_name: Name der Unterkunft      Optional:      - address, city_name, phone, checkin_time      - has_kitchen, has_washing_machine, has_breakfast      - total_price      - free_cancel_until: ISO-Datum der Stornierungsfrist      - latitude, longitude</p> required <code>output_path</code> <code>Path</code> <p>Pfad f\u00fcr die Ausgabe-ICS-Datei.</p> required Example <p>bookings = [ ...     { ...         \"hotel_name\": \"Hotel Alpenblick\", ...         \"arrival_date\": \"2026-05-15\", ...         \"departure_date\": \"2026-05-17\", ...         \"address\": \"Hauptstra\u00dfe 1, Garmisch\", ...         \"has_kitchen\": True, ...         \"total_price\": 180.00, ...         \"free_cancel_until\": \"2026-05-10\" ...     } ... ] export_bookings_to_ics(bookings, Path(\"reise.ics\")) \u2705 ICS-Datei erstellt: reise.ics    \ud83d\udcc5 1 \u00dcbernachtungen    \u26a0\ufe0f  1 Stornierungserinnerungen</p> Source code in <code>src/biketour_planner/ics_export.py</code> <pre><code>def export_bookings_to_ics(\n    bookings: list[dict],\n    output_path: Path,\n) -&gt; None:\n    \"\"\"Exportiert Buchungsinformationen in eine ICS-Kalenderdatei.\n\n    Erstellt eine iCalendar-kompatible Datei (.ics) mit zwei Arten von Events:\n\n    1. **\u00dcbernachtungsereignisse**: Ganztagesevents von arrival_date bis\n       departure_date mit vollst\u00e4ndigen Buchungsdetails (Adresse, Ausstattung,\n       Preis, etc.)\n\n    2. **Stornierungserinnerungen**: Ganztagesevents 48 Stunden vor der\n       kostenlosen Stornierungsfrist (free_cancel_until) als Reminder.\n\n    Die generierten ICS-Dateien k\u00f6nnen in alle g\u00e4ngigen Kalender-Anwendungen\n    importiert werden (Google Calendar, Outlook, Apple Calendar, etc.).\n\n    Args:\n        bookings: Liste mit Buchungs-Dictionaries. Erforderliche Keys:\n                 - arrival_date: ISO-Datum (YYYY-MM-DD)\n                 - departure_date: ISO-Datum (YYYY-MM-DD)\n                 - hotel_name: Name der Unterkunft\n                 Optional:\n                 - address, city_name, phone, checkin_time\n                 - has_kitchen, has_washing_machine, has_breakfast\n                 - total_price\n                 - free_cancel_until: ISO-Datum der Stornierungsfrist\n                 - latitude, longitude\n        output_path: Pfad f\u00fcr die Ausgabe-ICS-Datei.\n\n    Example:\n        &gt;&gt;&gt; bookings = [\n        ...     {\n        ...         \"hotel_name\": \"Hotel Alpenblick\",\n        ...         \"arrival_date\": \"2026-05-15\",\n        ...         \"departure_date\": \"2026-05-17\",\n        ...         \"address\": \"Hauptstra\u00dfe 1, Garmisch\",\n        ...         \"has_kitchen\": True,\n        ...         \"total_price\": 180.00,\n        ...         \"free_cancel_until\": \"2026-05-10\"\n        ...     }\n        ... ]\n        &gt;&gt;&gt; export_bookings_to_ics(bookings, Path(\"reise.ics\"))\n        \u2705 ICS-Datei erstellt: reise.ics\n           \ud83d\udcc5 1 \u00dcbernachtungen\n           \u26a0\ufe0f  1 Stornierungserinnerungen\n    \"\"\"\n    logger.info(\"Starte ICS-Export...\")\n\n    # ICS-Header\n    ics_content = [\n        \"BEGIN:VCALENDAR\",\n        \"VERSION:2.0\",\n        \"PRODID:-//Biketour Planner//ICS Export//DE\",\n        \"CALSCALE:GREGORIAN\",\n        \"METHOD:PUBLISH\",\n        \"X-WR-CALNAME:Kroatien Radtour 2026\",\n        \"X-WR-TIMEZONE:Europe/Berlin\",\n    ]\n\n    # Sortiere Buchungen nach Anreisedatum\n    bookings_sorted = sorted(bookings, key=lambda x: x.get(\"arrival_date\", \"9999-12-31\"))\n\n    accommodation_count = 0\n    cancellation_count = 0\n\n    for booking in bookings_sorted:\n        # 1. \u00dcbernachtungsereignis\n        arrival_date = booking.get(\"arrival_date\")\n        departure_date = booking.get(\"departure_date\")\n\n        if arrival_date and departure_date:\n            try:\n                start = datetime.fromisoformat(arrival_date)\n                # ICS-Enddatum ist exklusiv, daher +1 Tag f\u00fcr korrekte Anzeige\n                end = datetime.fromisoformat(departure_date)\n\n                hotel_name = booking.get(\"hotel_name\", \"Unterkunft\")\n                city_name = booking.get(\"city_name\", \"\")\n\n                summary = f\"\ud83c\udfe8 {hotel_name}\"\n                if city_name:\n                    summary += f\" ({city_name})\"\n\n                location = booking.get(\"address\", \"\")\n                description = create_accommodation_description(booking)\n\n                event = create_ics_event(\n                    summary=summary,\n                    start_date=start,\n                    end_date=end,\n                    description=description,\n                    location=location,\n                )\n\n                ics_content.append(event)\n                accommodation_count += 1\n\n                logger.debug(f\"\u00dcbernachtung hinzugef\u00fcgt: {hotel_name} ({arrival_date} - {departure_date})\")\n\n            except ValueError as e:\n                logger.warning(f\"Ung\u00fcltiges Datum bei {booking.get('hotel_name', 'Unbekannt')}: {e}\")\n\n        # 2. Stornierungserinnerung (48h vor Stornierungsfrist)\n        free_cancel_until = booking.get(\"free_cancel_until\")\n\n        if free_cancel_until:\n            try:\n                cancel_date = datetime.fromisoformat(free_cancel_until)\n                # Erinnerung 48h vorher\n                reminder_date = cancel_date - timedelta(hours=48)\n                # Enddatum = Startdatum + 1 Tag (Ganztagesevent)\n                reminder_end = reminder_date + timedelta(days=1)\n\n                hotel_name = booking.get(\"hotel_name\", \"Unterkunft\")\n\n                summary = f\"\u26a0\ufe0f Stornierungsfrist: {hotel_name}\"\n\n                description_lines = [\n                    f\"ERINNERUNG: Kostenlose Stornierung m\u00f6glich bis {free_cancel_until}\",\n                    f\"Unterkunft: {hotel_name}\",\n                ]\n\n                if booking.get(\"address\"):\n                    description_lines.append(f\"Adresse: {booking['address']}\")\n\n                if booking.get(\"total_price\"):\n                    description_lines.append(f\"Preis: {booking['total_price']:.2f} \u20ac\")\n\n                description = \"\\n\".join(description_lines)\n\n                event = create_ics_event(\n                    summary=summary,\n                    start_date=reminder_date,\n                    end_date=reminder_end,\n                    description=description,\n                    location=\"\",\n                )\n\n                ics_content.append(event)\n                cancellation_count += 1\n\n                logger.debug(f\"Stornierungserinnerung hinzugef\u00fcgt: {hotel_name} (48h vor {free_cancel_until})\")\n\n            except ValueError as e:\n                logger.warning(f\"Ung\u00fcltiges Stornierungsdatum bei {booking.get('hotel_name', 'Unbekannt')}: {e}\")\n\n    # ICS-Footer\n    ics_content.append(\"END:VCALENDAR\")\n\n    # Schreibe ICS-Datei\n    output_path.parent.mkdir(parents=True, exist_ok=True)\n    output_path.write_text(\"\\n\".join(ics_content), encoding=\"utf-8\")\n\n    logger.info(f\"\u2705 ICS-Datei erstellt: {output_path}\")\n    logger.info(f\"   \ud83d\udcc5 {accommodation_count} \u00dcbernachtungen\")\n    logger.info(f\"   \u26a0\ufe0f  {cancellation_count} Stornierungserinnerungen\")\n</code></pre>"},{"location":"api/#hilfsmodule","title":"Hilfsmodule","text":""},{"location":"api/#biketour_planner.gpx_route_manager_static","title":"<code>biketour_planner.gpx_route_manager_static</code>","text":"<p>Static helper functions for GPX route management.</p>"},{"location":"api/#biketour_planner.gpx_route_manager_static-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.gpx_route_manager_static.find_closest_point_in_track","title":"<code>find_closest_point_in_track(points, target_lat, target_lon)</code>","text":"<p>Finds the closest point within a track to a target coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[dict]</code> <p>List of point dictionaries with keys 'lat', 'lon', 'index'.</p> required <code>target_lat</code> <code>float</code> <p>Target latitude.</p> required <code>target_lon</code> <code>float</code> <p>Target longitude.</p> required <p>Returns:</p> Type Description <code>tuple[int, float]</code> <p>A tuple of (index, distance) for the closest point.</p> Source code in <code>src/biketour_planner/gpx_route_manager_static.py</code> <pre><code>def find_closest_point_in_track(points: list[dict], target_lat: float, target_lon: float) -&gt; tuple[int, float]:\n    \"\"\"Finds the closest point within a track to a target coordinate.\n\n    Args:\n        points: List of point dictionaries with keys 'lat', 'lon', 'index'.\n        target_lat: Target latitude.\n        target_lon: Target longitude.\n\n    Returns:\n        A tuple of (index, distance) for the closest point.\n    \"\"\"\n    best_idx = None\n    best_dist = float(\"inf\")\n\n    for point in points:\n        d = haversine(target_lat, target_lon, point[\"lat\"], point[\"lon\"])\n        if d &lt; best_dist:\n            best_dist = d\n            best_idx = point[\"index\"]\n\n    return best_idx, best_dist\n</code></pre>"},{"location":"api/#biketour_planner.gpx_route_manager_static.get_base_filename","title":"<code>get_base_filename(filename)</code>","text":"<p>Extracts the base filename without direction suffixes.</p> <p>Removes suffixes like '_inverted', '_reversed', '_rev' etc. to prevent using the same track multiple times in different directions.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>GPX filename with potential direction suffix.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Base filename without direction info.</p> Example <p>get_base_filename(\"route_Munich_Garmisch_reversed.gpx\") 'route_Munich_Garmisch.gpx'</p> Source code in <code>src/biketour_planner/gpx_route_manager_static.py</code> <pre><code>def get_base_filename(filename: str) -&gt; str:\n    \"\"\"Extracts the base filename without direction suffixes.\n\n    Removes suffixes like '_inverted', '_reversed', '_rev' etc. to prevent\n    using the same track multiple times in different directions.\n\n    Args:\n        filename: GPX filename with potential direction suffix.\n\n    Returns:\n        Base filename without direction info.\n\n    Example:\n        &gt;&gt;&gt; get_base_filename(\"route_Munich_Garmisch_reversed.gpx\")\n        'route_Munich_Garmisch.gpx'\n    \"\"\"\n    # Remove common suffixes for inverted tracks\n    for suffix in [\"_inverted\", \"_reversed\", \"_rev\", \"_inverse\", \"_backward\"]:\n        if filename.lower().endswith(f\"{suffix}.gpx\"):\n            return filename[: -len(suffix) - 4] + \".gpx\"\n\n    return filename\n</code></pre>"},{"location":"api/#biketour_planner.gpx_route_manager_static.get_statistics4track","title":"<code>get_statistics4track(gpx, start_index=0, end_index=None, max_elevation=0.0, total_distance=0.0, total_ascent=0.0, total_descent=0.0, reversed_direction=False)</code>","text":"<p>Calculates statistics for a track section between two indices.</p> <p>Parameters:</p> Name Type Description Default <code>gpx</code> <code>GPX</code> <p>GPX object.</p> required <code>start_index</code> <code>int</code> <p>Start index of the section.</p> <code>0</code> <code>end_index</code> <code>int</code> <p>End index of the section.</p> <code>None</code> <code>max_elevation</code> <code>float</code> <p>Previous max elevation.</p> <code>0.0</code> <code>total_distance</code> <code>float</code> <p>Previous total distance.</p> <code>0.0</code> <code>total_ascent</code> <code>float</code> <p>Previous total ascent.</p> <code>0.0</code> <code>total_descent</code> <code>float</code> <p>Previous total descent.</p> <code>0.0</code> <code>reversed_direction</code> <code>bool</code> <p>If True, the section is traversed backward.</p> <code>False</code> <p>Returns:</p> Type Description <code>TrackStats</code> <p>Tuple of (max_elevation, total_distance, total_ascent, total_descent).</p> Source code in <code>src/biketour_planner/gpx_route_manager_static.py</code> <pre><code>def get_statistics4track(\n    gpx: gpxpy.gpx.GPX,\n    start_index: int = 0,\n    end_index: int = None,\n    max_elevation: float = 0.0,\n    total_distance: float = 0.0,\n    total_ascent: float = 0.0,\n    total_descent: float = 0.0,\n    reversed_direction: bool = False,\n) -&gt; TrackStats:\n    \"\"\"Calculates statistics for a track section between two indices.\n\n    Args:\n        gpx: GPX object.\n        start_index: Start index of the section.\n        end_index: End index of the section.\n        max_elevation: Previous max elevation.\n        total_distance: Previous total distance.\n        total_ascent: Previous total ascent.\n        total_descent: Previous total descent.\n        reversed_direction: If True, the section is traversed backward.\n\n    Returns:\n        Tuple of (max_elevation, total_distance, total_ascent, total_descent).\n    \"\"\"\n    if not end_index or end_index == float(\"inf\"):\n        # Determine total number of points\n        num_points = 0\n        for track in gpx.tracks:\n            for seg in track.segments:\n                num_points += len(seg.points)\n        end_index = num_points - 1\n\n    segment_points = []\n    point_counter = 0\n    for track in gpx.tracks:\n        for seg in track.segments:\n            if reversed_direction:\n                for p in seg.points[::-1]:\n                    if start_index &lt;= point_counter &lt;= end_index:\n                        segment_points.append(p)\n                    point_counter += 1\n            else:\n                for p in seg.points:\n                    if start_index &lt;= point_counter &lt;= end_index:\n                        segment_points.append(p)\n                    point_counter += 1\n\n    prev = None\n    for p in segment_points:\n        if prev:\n            d = haversine(prev.latitude, prev.longitude, p.latitude, p.longitude)\n            total_distance += d\n        prev = p\n\n    elevations = [p.elevation for p in segment_points if p.elevation is not None]\n    if elevations:\n        max_elevation = max(max(elevations), max_elevation)\n\n        # take mean of elevation calculations as both are not accurate\n        ascent_segment = calculate_elevation_gain_segment_based(elevations, calculate_descent=False)\n        ascent_smoothed = calculate_elevation_gain_smoothed(elevations, calculate_descent=False)\n        total_ascent += (ascent_segment + ascent_smoothed) / 2\n\n        descent_segment = calculate_elevation_gain_segment_based(elevations, calculate_descent=True)\n        descent_smoothed = calculate_elevation_gain_smoothed(elevations, calculate_descent=True)\n        total_descent += (descent_segment + descent_smoothed) / 2\n\n    logger.debug(f\"   Points: {len(segment_points)}\")\n\n    return max_elevation, total_distance, total_ascent, total_descent\n</code></pre>"},{"location":"api/#biketour_planner.gpx_route_manager_static.haversine","title":"<code>haversine(lat1, lon1, lat2, lon2)</code>","text":"<p>Calculates the distance between two coordinates in meters.</p> <p>Uses the Haversine formula for great-circle distances on a sphere. This formula provides good approximations for distances on the Earth's surface.</p> <p>Parameters:</p> Name Type Description Default <code>lat1</code> <code>float</code> <p>Latitude of point 1 in decimal degrees.</p> required <code>lon1</code> <code>float</code> <p>Longitude of point 1 in decimal degrees.</p> required <code>lat2</code> <code>float</code> <p>Latitude of point 2 in decimal degrees.</p> required <code>lon2</code> <code>float</code> <p>Longitude of point 2 in decimal degrees.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The distance in meters.</p> Example <p>distance = haversine(52.5200, 13.4050, 48.1351, 11.5820)  # Berlin -&gt; Munich print(f\"{distance / 1000:.1f} km\") 504.2 km</p> Source code in <code>src/biketour_planner/gpx_route_manager_static.py</code> <pre><code>def haversine(lat1: float, lon1: float, lat2: float, lon2: float) -&gt; float:\n    \"\"\"Calculates the distance between two coordinates in meters.\n\n    Uses the Haversine formula for great-circle distances on a sphere.\n    This formula provides good approximations for distances on the Earth's surface.\n\n    Args:\n        lat1: Latitude of point 1 in decimal degrees.\n        lon1: Longitude of point 1 in decimal degrees.\n        lat2: Latitude of point 2 in decimal degrees.\n        lon2: Longitude of point 2 in decimal degrees.\n\n    Returns:\n        The distance in meters.\n\n    Example:\n        &gt;&gt;&gt; distance = haversine(52.5200, 13.4050, 48.1351, 11.5820)  # Berlin -&gt; Munich\n        &gt;&gt;&gt; print(f\"{distance / 1000:.1f} km\")\n        504.2 km\n    \"\"\"\n    R = 6371000\n    phi1, phi2 = math.radians(lat1), math.radians(lat2)\n    dphi = math.radians(lat2 - lat1)\n    dlambda = math.radians(lon2 - lon1)\n    a = math.sin(dphi / 2) ** 2 + math.cos(phi1) * math.cos(phi2) * math.sin(dlambda / 2) ** 2\n    return 2 * R * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n</code></pre>"},{"location":"api/#biketour_planner.gpx_route_manager_static.read_gpx_file","title":"<code>read_gpx_file(gpx_file)</code>","text":"<p>Reads a GPX file with robust encoding handling.</p> <p>Tries different encoding strategies (UTF-8, Latin-1, CP1252) and handles BOM (Byte Order Mark) and leading whitespaces.</p> <p>Parameters:</p> Name Type Description Default <code>gpx_file</code> <code>Path</code> <p>Path to the GPX file.</p> required <p>Returns:</p> Type Description <code>GPX | None</code> <p>The parsed GPX object or None on error.</p> Source code in <code>src/biketour_planner/gpx_route_manager_static.py</code> <pre><code>def read_gpx_file(gpx_file: Path) -&gt; gpxpy.gpx.GPX | None:\n    \"\"\"Reads a GPX file with robust encoding handling.\n\n    Tries different encoding strategies (UTF-8, Latin-1, CP1252) and\n    handles BOM (Byte Order Mark) and leading whitespaces.\n\n    Args:\n        gpx_file: Path to the GPX file.\n\n    Returns:\n        The parsed GPX object or None on error.\n    \"\"\"\n    # Try different encoding strategies\n    encodings = [\"utf-8\", \"utf-8-sig\", \"latin-1\", \"cp1252\"]\n\n    for encoding in encodings:\n        try:\n            content = gpx_file.read_text(encoding=encoding)\n\n            # Remove BOM if present\n            if content.startswith(\"\\ufeff\"):\n                content = content[1:]\n\n            # Remove leading whitespaces/newlines\n            content = content.lstrip()\n\n            # Parse GPX\n            gpx = gpxpy.parse(content)\n            return gpx\n\n        except (UnicodeDecodeError, gpxpy.gpx.GPXXMLSyntaxException):\n            continue\n        except Exception as e:\n            logger.error(f\"Unexpected error reading {gpx_file.name}: {e}\")\n            continue\n\n    # If all encodings fail, try binary reading\n    try:\n        with open(gpx_file, \"rb\") as f:\n            content = f.read()\n\n        # Try UTF-8 with error handling\n        text = content.decode(\"utf-8\", errors=\"ignore\")\n\n        # Remove BOM\n        if text.startswith(\"\\ufeff\"):\n            text = text[1:]\n\n        text = text.lstrip()\n\n        return gpxpy.parse(text)\n\n    except Exception as e:\n        logger.error(f\"Error parsing {gpx_file.name}: {e}\")\n        return None\n</code></pre>"},{"location":"api/#biketour_planner.gpx_utils","title":"<code>biketour_planner.gpx_utils</code>","text":"<p>Utility functions for GPX track management in the Bike Tour Planner.</p>"},{"location":"api/#biketour_planner.gpx_utils-classes","title":"Classes","text":""},{"location":"api/#biketour_planner.gpx_utils-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.gpx_utils.get_gps_tracks4day_4alldays","title":"<code>get_gps_tracks4day_4alldays(gpx_dir, bookings, output_path)</code>","text":"<p>Processes all bookings and collects GPS tracks for each day.</p> <p>This function is a wrapper around GPXRouteManager.process_all_bookings() for compatibility with existing code.</p> <p>Parameters:</p> Name Type Description Default <code>gpx_dir</code> <code>Path</code> <p>Directory with GPX files.</p> required <code>bookings</code> <code>list[dict]</code> <p>List of bookings.</p> required <code>output_path</code> <code>Path</code> <p>Output path for merged GPX files.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>Sorted list of bookings enriched with GPS track information.</p> Source code in <code>src/biketour_planner/gpx_utils.py</code> <pre><code>def get_gps_tracks4day_4alldays(gpx_dir: Path, bookings: list[dict], output_path: Path) -&gt; list[dict]:\n    \"\"\"Processes all bookings and collects GPS tracks for each day.\n\n    This function is a wrapper around GPXRouteManager.process_all_bookings()\n    for compatibility with existing code.\n\n    Args:\n        gpx_dir: Directory with GPX files.\n        bookings: List of bookings.\n        output_path: Output path for merged GPX files.\n\n    Returns:\n        Sorted list of bookings enriched with GPS track information.\n    \"\"\"\n    manager = GPXRouteManager(gpx_dir, output_path)\n    return manager.process_all_bookings(bookings, output_path)\n</code></pre>"},{"location":"api/#biketour_planner.elevation_calc","title":"<code>biketour_planner.elevation_calc</code>","text":"<p>Verbesserte H\u00f6henmeterberechnung mit Gl\u00e4ttung und Schwellwert.</p>"},{"location":"api/#biketour_planner.elevation_calc-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.elevation_calc.calculate_elevation_gain_segment_based","title":"<code>calculate_elevation_gain_segment_based(elevations, min_segment_length=10, calculate_descent=False)</code>","text":"<p>Berechnet positive oder negative H\u00f6henmeter segment-basiert (robusteste Methode).</p> <p>Diese Methode identifiziert zusammenh\u00e4ngende Anstiegs- und Abstiegssegmente und summiert nur die Netto-Anstiege bzw. Netto-Abstiege jedes Segments. Dies ist die genaueste Methode f\u00fcr reale GPS-Tracks.</p> <p>Parameters:</p> Name Type Description Default <code>elevations</code> <code>list[float]</code> <p>Liste der H\u00f6henwerte in Metern.</p> required <code>min_segment_length</code> <code>int</code> <p>Minimale Anzahl Punkte f\u00fcr ein g\u00fcltiges Segment (Default: 10).</p> <code>10</code> <code>calculate_descent</code> <code>bool</code> <p>Wenn True, werden Abstiege berechnet statt Anstiege (Default: False).</p> <code>False</code> <p>Returns:</p> Type Description <code>float</code> <p>Gesamter positiver H\u00f6henunterschied (Anstiege) oder negativer H\u00f6henunterschied</p> <code>float</code> <p>(Abstiege) in Metern, je nach calculate_descent Parameter.</p> Example <p>elevations = list(range(100, 200, 5)) + list(range(200, 180, -2)) + list(range(180, 250, 3)) ascent = calculate_elevation_gain_segment_based(elevations) descent = calculate_elevation_gain_segment_based(elevations, calculate_descent=True) print(f\"Anstiege: {ascent:.0f}m, Abstiege: {descent:.0f}m\")</p> Source code in <code>src/biketour_planner/elevation_calc.py</code> <pre><code>def calculate_elevation_gain_segment_based(\n    elevations: list[float], min_segment_length: int = 10, calculate_descent: bool = False\n) -&gt; float:\n    \"\"\"Berechnet positive oder negative H\u00f6henmeter segment-basiert (robusteste Methode).\n\n    Diese Methode identifiziert zusammenh\u00e4ngende Anstiegs- und Abstiegssegmente\n    und summiert nur die Netto-Anstiege bzw. Netto-Abstiege jedes Segments.\n    Dies ist die genaueste Methode f\u00fcr reale GPS-Tracks.\n\n    Args:\n        elevations: Liste der H\u00f6henwerte in Metern.\n        min_segment_length: Minimale Anzahl Punkte f\u00fcr ein g\u00fcltiges Segment (Default: 10).\n        calculate_descent: Wenn True, werden Abstiege berechnet statt Anstiege (Default: False).\n\n    Returns:\n        Gesamter positiver H\u00f6henunterschied (Anstiege) oder negativer H\u00f6henunterschied\n        (Abstiege) in Metern, je nach calculate_descent Parameter.\n\n    Example:\n        &gt;&gt;&gt; elevations = list(range(100, 200, 5)) + list(range(200, 180, -2)) + list(range(180, 250, 3))\n        &gt;&gt;&gt; ascent = calculate_elevation_gain_segment_based(elevations)\n        &gt;&gt;&gt; descent = calculate_elevation_gain_segment_based(elevations, calculate_descent=True)\n        &gt;&gt;&gt; print(f\"Anstiege: {ascent:.0f}m, Abstiege: {descent:.0f}m\")\n    \"\"\"\n    if not elevations or len(elevations) &lt; 2:\n        return 0.0\n\n    # Filtere None-Werte\n    valid_elevations = [e for e in elevations if e is not None]\n\n    if len(valid_elevations) &lt; min_segment_length:\n        # Fallback auf einfache Methode (ohne Schwellwert) f\u00fcr sehr kurze Tracks\n        return calculate_elevation_gain_simple(valid_elevations, threshold=0.0, calculate_descent=calculate_descent)\n\n    # Gl\u00e4ttung (kleines Fenster um nur Rauschen zu entfernen)\n    window = 3\n    smoothed = np.convolve(valid_elevations, np.ones(window) / window, mode=\"valid\")\n\n    # Finde Wendepunkte (\u00dcbergang Anstieg &lt;-&gt; Abstieg)\n    is_ascending = []\n    for i in range(1, len(smoothed)):\n        is_ascending.append(smoothed[i] &gt; smoothed[i - 1])\n\n    # Identifiziere Segmente\n    segments = []\n    segment_start = 0\n    current_direction = is_ascending[0] if is_ascending else None\n\n    for i in range(1, len(is_ascending)):\n        if is_ascending[i] != current_direction:\n            # Richtungswechsel -&gt; Segment abschlie\u00dfen\n            segments.append(\n                {\n                    \"start\": segment_start,\n                    \"end\": i,\n                    \"ascending\": current_direction,\n                    \"elevation_change\": smoothed[i] - smoothed[segment_start],\n                }\n            )\n            segment_start = i\n            current_direction = is_ascending[i]\n\n    # Letztes Segment\n    if segment_start &lt; len(smoothed) - 1:\n        segments.append(\n            {\n                \"start\": segment_start,\n                \"end\": len(smoothed) - 1,\n                \"ascending\": current_direction,\n                \"elevation_change\": smoothed[-1] - smoothed[segment_start],\n            }\n        )\n\n    # Summiere aufsteigende oder absteigende Segmente\n    if calculate_descent:\n        # Summiere Abstiege (negative elevation_change, als Absolutwert)\n        total = sum(abs(seg[\"elevation_change\"]) for seg in segments if not seg[\"ascending\"] and seg[\"elevation_change\"] &lt; 0)\n    else:\n        # Summiere Anstiege (positive elevation_change)\n        total = sum(seg[\"elevation_change\"] for seg in segments if seg[\"ascending\"] and seg[\"elevation_change\"] &gt; 0)\n\n    return total\n</code></pre>"},{"location":"api/#biketour_planner.elevation_calc.calculate_elevation_gain_simple","title":"<code>calculate_elevation_gain_simple(elevations, threshold=3.0, calculate_descent=False)</code>","text":"<p>Berechnet positive H\u00f6henmeter mit Schwellwert (einfache Methode).</p> <p>Diese Methode ignoriert kleine Schwankungen unter dem Schwellwert und z\u00e4hlt nur signifikante Anstiege.</p> <p>Parameters:</p> Name Type Description Default <code>elevations</code> <code>list[float]</code> <p>Liste der H\u00f6henwerte in Metern.</p> required <code>threshold</code> <code>float</code> <p>Minimaler H\u00f6henunterschied in Metern der gez\u00e4hlt wird (Default: 3m).</p> <code>3.0</code> <code>calculate_descent</code> <code>bool</code> <p>Wenn True, werden Abstiege berechnet statt Anstiege.</p> <code>False</code> <p>Returns:</p> Type Description <code>float</code> <p>Gesamter positiver H\u00f6henunterschied in Metern.</p> Example <p>elevations = [100, 102, 99, 103, 101, 110, 108, 115] gain = calculate_elevation_gain_simple(elevations, threshold=3.0) print(f\"{gain:.0f}m\")  # Erwartet: ~15m (3+7+7)</p> Source code in <code>src/biketour_planner/elevation_calc.py</code> <pre><code>def calculate_elevation_gain_simple(elevations: list[float], threshold: float = 3.0, calculate_descent: bool = False) -&gt; float:\n    \"\"\"Berechnet positive H\u00f6henmeter mit Schwellwert (einfache Methode).\n\n    Diese Methode ignoriert kleine Schwankungen unter dem Schwellwert und\n    z\u00e4hlt nur signifikante Anstiege.\n\n    Args:\n        elevations: Liste der H\u00f6henwerte in Metern.\n        threshold: Minimaler H\u00f6henunterschied in Metern der gez\u00e4hlt wird (Default: 3m).\n        calculate_descent: Wenn True, werden Abstiege berechnet statt Anstiege.\n\n    Returns:\n        Gesamter positiver H\u00f6henunterschied in Metern.\n\n    Example:\n        &gt;&gt;&gt; elevations = [100, 102, 99, 103, 101, 110, 108, 115]\n        &gt;&gt;&gt; gain = calculate_elevation_gain_simple(elevations, threshold=3.0)\n        &gt;&gt;&gt; print(f\"{gain:.0f}m\")  # Erwartet: ~15m (3+7+7)\n    \"\"\"\n    if not elevations or len(elevations) &lt; 2:\n        return 0.0\n\n    total_gain = 0.0\n    accumulated_diff = 0.0\n\n    for i in range(1, len(elevations)):\n        if elevations[i] is None or elevations[i - 1] is None:\n            continue\n\n        diff = elevations[i] - elevations[i - 1]\n        if calculate_descent:\n            diff = -diff\n\n        if diff &gt; 0:\n            accumulated_diff += diff\n\n            # Wenn akkumulierter Anstieg \u00fcber Schwellwert, z\u00e4hle ihn\n            if accumulated_diff &gt;= threshold:\n                total_gain += accumulated_diff\n                accumulated_diff = 0.0\n        else:\n            # Bei Abstieg: Reset der Akkumulation\n            accumulated_diff = 0.0\n\n    return total_gain\n</code></pre>"},{"location":"api/#biketour_planner.elevation_calc.calculate_elevation_gain_smoothed","title":"<code>calculate_elevation_gain_smoothed(elevations, window_size=5, threshold=3.0, calculate_descent=False)</code>","text":"<p>Berechnet positive H\u00f6henmeter mit Gl\u00e4ttung (empfohlene Methode).</p> <p>Diese Methode gl\u00e4ttet zuerst die H\u00f6hendaten mit einem gleitenden Durchschnitt um GPS-Rauschen zu reduzieren, und z\u00e4hlt dann nur signifikante Anstiege.</p> <p>Parameters:</p> Name Type Description Default <code>elevations</code> <code>list[float]</code> <p>Liste der H\u00f6henwerte in Metern.</p> required <code>window_size</code> <code>int</code> <p>Fenstergr\u00f6\u00dfe f\u00fcr gleitenden Durchschnitt (Default: 5 Punkte).</p> <code>5</code> <code>threshold</code> <code>float</code> <p>Minimaler H\u00f6henunterschied in Metern der gez\u00e4hlt wird (Default: 3m).</p> <code>3.0</code> <code>calculate_descent</code> <code>bool</code> <p>Wenn True, werden Abstiege berechnet statt Anstiege.</p> <code>False</code> <p>Returns:</p> Type Description <code>float</code> <p>Gesamter positiver H\u00f6henunterschied in Metern.</p> Example <p>elevations = [100, 102, 99, 103, 101, 110, 108, 115, 113, 120] gain = calculate_elevation_gain_smoothed(elevations) print(f\"{gain:.0f}m\")  # Glattere, realistischere Werte</p> Source code in <code>src/biketour_planner/elevation_calc.py</code> <pre><code>def calculate_elevation_gain_smoothed(\n    elevations: list[float], window_size: int = 5, threshold: float = 3.0, calculate_descent: bool = False\n) -&gt; float:\n    \"\"\"Berechnet positive H\u00f6henmeter mit Gl\u00e4ttung (empfohlene Methode).\n\n    Diese Methode gl\u00e4ttet zuerst die H\u00f6hendaten mit einem gleitenden Durchschnitt\n    um GPS-Rauschen zu reduzieren, und z\u00e4hlt dann nur signifikante Anstiege.\n\n    Args:\n        elevations: Liste der H\u00f6henwerte in Metern.\n        window_size: Fenstergr\u00f6\u00dfe f\u00fcr gleitenden Durchschnitt (Default: 5 Punkte).\n        threshold: Minimaler H\u00f6henunterschied in Metern der gez\u00e4hlt wird (Default: 3m).\n        calculate_descent: Wenn True, werden Abstiege berechnet statt Anstiege.\n\n    Returns:\n        Gesamter positiver H\u00f6henunterschied in Metern.\n\n    Example:\n        &gt;&gt;&gt; elevations = [100, 102, 99, 103, 101, 110, 108, 115, 113, 120]\n        &gt;&gt;&gt; gain = calculate_elevation_gain_smoothed(elevations)\n        &gt;&gt;&gt; print(f\"{gain:.0f}m\")  # Glattere, realistischere Werte\n    \"\"\"\n    if not elevations or len(elevations) &lt; 2:\n        return 0.0\n\n    # Filtere None-Werte\n    valid_elevations = [e for e in elevations if e is not None]\n\n    if len(valid_elevations) &lt; window_size + 1:\n        # Fallback auf einfache Methode bei zu wenig Punkten\n        return calculate_elevation_gain_simple(valid_elevations, threshold, calculate_descent)\n\n    # Gl\u00e4ttung mit gleitendem Durchschnitt\n    smoothed = np.convolve(valid_elevations, np.ones(window_size) / window_size, mode=\"valid\")\n\n    # Berechne Anstiege mit Schwellwert \u00fcber die einfache Methode\n    return calculate_elevation_gain_simple(smoothed.tolist(), threshold, calculate_descent)\n</code></pre>"},{"location":"api/#biketour_planner.elevation_profiles","title":"<code>biketour_planner.elevation_profiles</code>","text":"<p>H\u00f6henprofil-Generierung f\u00fcr GPS-Tracks mit Steigungsvisualisierung.</p> <p>Dieses Modul erstellt farbcodierte H\u00f6henprofile aus GPX-Dateien: - Rot f\u00fcr Anstiege (desto steiler, desto kr\u00e4ftiger) - Gr\u00fcn f\u00fcr Abfahrten (desto steiler, desto kr\u00e4ftiger)</p>"},{"location":"api/#biketour_planner.elevation_profiles-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.elevation_profiles.add_elevation_profiles_to_story","title":"<code>add_elevation_profiles_to_story(story, gpx_files, bookings, gpx_dir, title_style, page_width_cm=25.0, max_workers=14)</code>","text":"<p>F\u00fcgt H\u00f6henprofile f\u00fcr alle GPX-Dateien zur PDF-Story hinzu (parallelisiert).</p> <p>Erstellt H\u00f6henprofile f\u00fcr: 1. Haupt-Tracks (merged GPX zu Hotels) 2. Pass-Tracks (direkt nach dem zugeh\u00f6rigen Haupt-Track)</p> <p>Parameters:</p> Name Type Description Default <code>story</code> <code>list</code> <p>reportlab Story-Liste (wird in-place modifiziert).</p> required <code>gpx_files</code> <code>list[Path]</code> <p>Liste von Pfaden zu gemergten GPX-Dateien.</p> required <code>bookings</code> <code>list[dict]</code> <p>Liste mit Buchungs-Dictionaries (f\u00fcr Pass-Zuordnung).</p> required <code>gpx_dir</code> <code>Path</code> <p>Verzeichnis mit Original-GPX-Dateien (f\u00fcr Pass-Tracks).</p> required <code>title_style</code> <code>ParagraphStyle</code> <p>ParagraphStyle f\u00fcr \u00dcberschriften.</p> required <code>page_width_cm</code> <code>float</code> <p>Verf\u00fcgbare Seitenbreite in cm f\u00fcr Skalierung.</p> <code>25.0</code> <code>max_workers</code> <code>int</code> <p>Maximale Anzahl paralleler Worker-Threads (Default: 14).</p> <code>14</code> Example <p>story = [] gpx_files = [Path(\"day1.gpx\"), Path(\"day2.gpx\")] add_elevation_profiles_to_story(story, gpx_files, bookings, gpx_dir, title_style)</p> Source code in <code>src/biketour_planner/elevation_profiles.py</code> <pre><code>def add_elevation_profiles_to_story(\n    story: list,\n    gpx_files: list[Path],\n    bookings: list[dict],\n    gpx_dir: Path,\n    title_style: ParagraphStyle,\n    page_width_cm: float = 25.0,\n    max_workers: int = 14,\n) -&gt; None:\n    \"\"\"F\u00fcgt H\u00f6henprofile f\u00fcr alle GPX-Dateien zur PDF-Story hinzu (parallelisiert).\n\n    Erstellt H\u00f6henprofile f\u00fcr:\n    1. Haupt-Tracks (merged GPX zu Hotels)\n    2. Pass-Tracks (direkt nach dem zugeh\u00f6rigen Haupt-Track)\n\n    Args:\n        story: reportlab Story-Liste (wird in-place modifiziert).\n        gpx_files: Liste von Pfaden zu gemergten GPX-Dateien.\n        bookings: Liste mit Buchungs-Dictionaries (f\u00fcr Pass-Zuordnung).\n        gpx_dir: Verzeichnis mit Original-GPX-Dateien (f\u00fcr Pass-Tracks).\n        title_style: ParagraphStyle f\u00fcr \u00dcberschriften.\n        page_width_cm: Verf\u00fcgbare Seitenbreite in cm f\u00fcr Skalierung.\n        max_workers: Maximale Anzahl paralleler Worker-Threads (Default: 14).\n\n    Example:\n        &gt;&gt;&gt; story = []\n        &gt;&gt;&gt; gpx_files = [Path(\"day1.gpx\"), Path(\"day2.gpx\")]\n        &gt;&gt;&gt; add_elevation_profiles_to_story(story, gpx_files, bookings, gpx_dir, title_style)\n    \"\"\"\n    if not gpx_files and not any(b.get(\"paesse_tracks\") for b in bookings):\n        return\n\n    # Neue Seite f\u00fcr H\u00f6henprofile\n    story.append(PageBreak())\n\n    # \u00dcberschrift\n    heading = Paragraph(\"&lt;b&gt;H\u00f6henprofile&lt;/b&gt;\", title_style)\n    story.append(heading)\n\n    # Erstelle Mapping: GPX-Dateiname -&gt; Booking (f\u00fcr Pass-Zuordnung)\n    gpx_to_booking = {}\n    for booking in bookings:\n        gpx_track = booking.get(\"gpx_track_final\")\n        if gpx_track:\n            gpx_to_booking[gpx_track] = booking\n\n    # Sammle alle zu erstellenden Profile (Haupt-Tracks + Pass-Tracks)\n    profile_tasks = []\n\n    for gpx_file in gpx_files:\n        booking = gpx_to_booking.get(gpx_file.name)\n\n        # Haupt-Track\n        profile_tasks.append(\n            {\n                \"gpx_file\": gpx_file,\n                \"booking\": booking,\n                \"pass_track\": None,\n                \"title\": gpx_file.stem,\n                \"type\": \"main\",\n                \"booking_ref\": booking,\n            }\n        )\n\n        # Pass-Tracks f\u00fcr diesen Tag\n        if booking and booking.get(\"paesse_tracks\"):\n            for pass_track in booking[\"paesse_tracks\"]:\n                pass_file = gpx_dir / pass_track[\"file\"]\n                passname = pass_track.get(\"passname\", \"Pass\")\n\n                if pass_file.exists():\n                    profile_tasks.append(\n                        {\n                            \"gpx_file\": pass_file,\n                            \"booking\": booking,\n                            \"pass_track\": pass_track,\n                            \"title\": f\"{passname} ({pass_file.stem})\",\n                            \"type\": \"pass\",\n                            \"booking_ref\": booking,\n                        }\n                    )\n\n    # Parallele Profil-Erstellung mit ThreadPoolExecutor\n    profile_results = {}\n\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        # Starte alle Tasks\n        future_to_task = {\n            executor.submit(_create_single_profile, task[\"gpx_file\"], task[\"booking\"], task[\"pass_track\"], task[\"title\"]): task\n            for task in profile_tasks\n        }\n\n        # Sammle Ergebnisse mit Fortschrittsanzeige\n        with tqdm(total=len(profile_tasks), desc=\"Erstelle H\u00f6henprofile\") as pbar:\n            for future in as_completed(future_to_task):\n                task = future_to_task[future]\n                result = future.result()\n\n                # Speichere Ergebnis mit eindeutigem Key\n                key = (task[\"gpx_file\"].name, task[\"type\"])\n                profile_results[key] = (result, task)\n\n                pbar.update(1)\n\n    # F\u00fcge Profile in der richtigen Reihenfolge zur Story hinzu\n    logger.debug(f\"\ud83d\udcdd F\u00fcge {len(profile_results)} Profile zur Story hinzu\")\n\n    added_count = 0\n    error_count = 0\n\n    for gpx_file in gpx_files:\n        # Haupt-Track\n        main_key = (gpx_file.name, \"main\")\n        if main_key in profile_results:\n            result, task = profile_results[main_key]\n            img_bytes, filename, is_error = result\n\n            logger.debug(\n                f\"\ud83d\udcdd Verarbeite Haupt-Track: {filename}, is_error={is_error}, bytes_len={len(img_bytes) if not is_error else 'N/A'}\"\n            )\n\n            if is_error:\n                # img_bytes contains error message string in this case\n                error_text = f\"&lt;i&gt;{img_bytes}&lt;/i&gt;\"\n                story.append(Paragraph(error_text, title_style))\n                error_count += 1\n                logger.warning(f\"\u26a0\ufe0f  Fehler bei {filename}\")\n            else:\n                # WICHTIG: Erstelle neuen BytesIO-Buffer aus den gespeicherten Bytes\n                img_buffer = BytesIO(img_bytes)\n                img_buffer.seek(0)  # Stelle sicher dass am Anfang\n\n                # Validiere Buffer-Inhalt\n                if len(img_bytes) == 0:\n                    logger.error(f\"\u274c Leerer Buffer f\u00fcr {filename}\")\n                    error_count += 1\n                    continue\n\n                logger.debug(f\"\ud83d\udcdd BytesIO erstellt, Gr\u00f6\u00dfe: {len(img_bytes)} bytes, Position: {img_buffer.tell()}\")\n\n                img = Image(img_buffer, width=page_width_cm * cm, height=(page_width_cm / 3) * cm)\n                logger.debug(f\"\ud83d\udcdd Image-Objekt erstellt: {type(img)}, width={img.drawWidth}, height={img.drawHeight}\")\n\n                story.append(img)\n                added_count += 1\n                logger.debug(f\"\u2705 Haupt-Track hinzugef\u00fcgt: {filename}\")\n\n        # Pass-Tracks f\u00fcr diesen Tag\n        booking = gpx_to_booking.get(gpx_file.name)\n        if booking and booking.get(\"paesse_tracks\"):\n            for pass_track in booking[\"paesse_tracks\"]:\n                pass_file = gpx_dir / pass_track[\"file\"]\n                pass_key = (pass_file.name, \"pass\")\n\n                if pass_key in profile_results:\n                    result, task = profile_results[pass_key]\n                    img_bytes, filename, is_error = result\n\n                    logger.debug(f\"\ud83d\udcdd Verarbeite Pass-Track: {filename}, is_error={is_error}\")\n\n                    if is_error:\n                        error_text = f\"&lt;i&gt;{img_bytes}&lt;/i&gt;\"\n                        story.append(Paragraph(error_text, title_style))\n                        error_count += 1\n                    else:\n                        # WICHTIG: Erstelle neuen BytesIO-Buffer aus den gespeicherten Bytes\n                        img_buffer = BytesIO(img_bytes)\n                        img = Image(img_buffer, width=page_width_cm * cm, height=(page_width_cm / 3) * cm)\n                        story.append(img)\n                        added_count += 1\n                        logger.debug(f\"\u2705 Pass-Track hinzugef\u00fcgt: {filename}\")\n\n    total_profiles = len(profile_tasks)\n    logger.info(f\"\ud83d\udcca Zusammenfassung: {added_count} erfolgreich, {error_count} Fehler, {total_profiles} gesamt\")\n    print(f\"\u2705 {total_profiles} H\u00f6henprofile erstellt (parallel mit {max_workers} Threads)\")\n</code></pre>"},{"location":"api/#biketour_planner.elevation_profiles.add_elevation_profiles_to_story_seq","title":"<code>add_elevation_profiles_to_story_seq(story, gpx_files, bookings, gpx_dir, title_style, page_width_cm=25.0)</code>","text":"<p>F\u00fcgt H\u00f6henprofile f\u00fcr alle GPX-Dateien zur PDF-Story hinzu (sequenziell).</p> <p>Erstellt H\u00f6henprofile f\u00fcr: 1. Haupt-Tracks (merged GPX zu Hotels) 2. Pass-Tracks (direkt nach dem zugeh\u00f6rigen Haupt-Track)</p> <p>Parameters:</p> Name Type Description Default <code>story</code> <code>list</code> <p>reportlab Story-Liste (wird in-place modifiziert).</p> required <code>gpx_files</code> <code>list[Path]</code> <p>Liste von Pfaden zu gemergten GPX-Dateien.</p> required <code>bookings</code> <code>list[dict]</code> <p>Liste mit Buchungs-Dictionaries (f\u00fcr Pass-Zuordnung).</p> required <code>gpx_dir</code> <code>Path</code> <p>Verzeichnis mit Original-GPX-Dateien (f\u00fcr Pass-Tracks).</p> required <code>title_style</code> <code>ParagraphStyle</code> <p>ParagraphStyle f\u00fcr \u00dcberschriften.</p> required <code>page_width_cm</code> <code>float</code> <p>Verf\u00fcgbare Seitenbreite in cm f\u00fcr Skalierung.</p> <code>25.0</code> Source code in <code>src/biketour_planner/elevation_profiles.py</code> <pre><code>def add_elevation_profiles_to_story_seq(\n    story: list,\n    gpx_files: list[Path],\n    bookings: list[dict],\n    gpx_dir: Path,\n    title_style: ParagraphStyle,\n    page_width_cm: float = 25.0,\n) -&gt; None:\n    \"\"\"F\u00fcgt H\u00f6henprofile f\u00fcr alle GPX-Dateien zur PDF-Story hinzu (sequenziell).\n\n    Erstellt H\u00f6henprofile f\u00fcr:\n    1. Haupt-Tracks (merged GPX zu Hotels)\n    2. Pass-Tracks (direkt nach dem zugeh\u00f6rigen Haupt-Track)\n\n    Args:\n        story: reportlab Story-Liste (wird in-place modifiziert).\n        gpx_files: Liste von Pfaden zu gemergten GPX-Dateien.\n        bookings: Liste mit Buchungs-Dictionaries (f\u00fcr Pass-Zuordnung).\n        gpx_dir: Verzeichnis mit Original-GPX-Dateien (f\u00fcr Pass-Tracks).\n        title_style: ParagraphStyle f\u00fcr \u00dcberschriften.\n        page_width_cm: Verf\u00fcgbare Seitenbreite in cm f\u00fcr Skalierung.\n    \"\"\"\n    if not gpx_files and not any(b.get(\"paesse_tracks\") for b in bookings):\n        return\n\n    # Neue Seite f\u00fcr H\u00f6henprofile\n    story.append(PageBreak())\n\n    # \u00dcberschrift\n    heading = Paragraph(\"&lt;b&gt;H\u00f6henprofile&lt;/b&gt;\", title_style)\n    story.append(heading)\n\n    # Erstelle Mapping: GPX-Dateiname -&gt; Booking (f\u00fcr Pass-Zuordnung)\n    gpx_to_booking = {}\n    for booking in bookings:\n        gpx_track = booking.get(\"gpx_track_final\")\n        if gpx_track:\n            gpx_to_booking[gpx_track] = booking\n\n    added_count = 0\n    error_count = 0\n\n    # F\u00fcr jede GPX-Datei ein Profil erstellen\n    for gpx_file in tqdm(gpx_files, desc=\"Erstelle H\u00f6henprofile\"):\n        try:\n            booking = gpx_to_booking.get(gpx_file.name)\n\n            # 1. Haupt-Track\n            logger.debug(f\"\ud83d\udcdd Verarbeite Haupt-Track: {gpx_file.name}\")\n            img_buffer = create_elevation_profile_plot(gpx_file, booking, title=gpx_file.stem)\n\n            img = Image(img_buffer, width=page_width_cm * cm, height=(page_width_cm / 3) * cm)\n            story.append(img)\n            added_count += 1\n            logger.debug(f\"\u2705 Haupt-Track hinzugef\u00fcgt: {gpx_file.name}\")\n\n            # 2. Pass-Tracks f\u00fcr diesen Tag\n            if booking and booking.get(\"paesse_tracks\"):\n                for pass_track in booking[\"paesse_tracks\"]:\n                    pass_file = gpx_dir / pass_track[\"file\"]\n                    passname = pass_track.get(\"passname\", \"Pass\")\n\n                    if pass_file.exists():\n                        try:\n                            logger.debug(f\"\ud83d\udcdd Verarbeite Pass-Track: {pass_file.name}\")\n                            pass_img_buffer = create_elevation_profile_plot(\n                                pass_file,\n                                booking,\n                                pass_track=pass_track,\n                                title=f\"{passname} ({pass_file.stem})\",\n                            )\n\n                            pass_img = Image(pass_img_buffer, width=page_width_cm * cm, height=(page_width_cm / 3) * cm)\n                            story.append(pass_img)\n                            added_count += 1\n                            logger.debug(f\"\u2705 Pass-Track hinzugef\u00fcgt: {pass_file.name}\")\n\n                        except Exception as e:\n                            error_text = f\"&lt;i&gt;Fehler beim Erstellen des Pass-Profils f\u00fcr {passname}: {e}&lt;/i&gt;\"\n                            story.append(Paragraph(error_text, title_style))\n                            error_count += 1\n                            logger.warning(f\"\u26a0\ufe0f  Fehler bei Pass-Track {pass_file.name}: {e}\")\n\n        except Exception as e:\n            # Fehler-Nachricht bei Problemen\n            error_text = f\"&lt;i&gt;Fehler beim Erstellen des Profils f\u00fcr {gpx_file.name}: {e}&lt;/i&gt;\"\n            story.append(Paragraph(error_text, title_style))\n            error_count += 1\n            logger.warning(f\"\u26a0\ufe0f  Fehler bei Haupt-Track {gpx_file.name}: {e}\")\n\n    total_profiles = added_count + error_count\n    logger.info(f\"\ud83d\udcca Zusammenfassung (sequenziell): {added_count} erfolgreich, {error_count} Fehler, {total_profiles} gesamt\")\n    print(f\"\u2705 {total_profiles} H\u00f6henprofile erstellt (sequenziell)\")\n</code></pre>"},{"location":"api/#biketour_planner.elevation_profiles.calculate_gradient","title":"<code>calculate_gradient(distances, elevations)</code>","text":"<p>Berechnet die Steigung in Prozent zwischen aufeinanderfolgenden Punkten.</p> <p>Parameters:</p> Name Type Description Default <code>distances</code> <code>ndarray</code> <p>Distanzen in Kilometern.</p> required <code>elevations</code> <code>ndarray</code> <p>H\u00f6hen in Metern.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Steigungen in Prozent als numpy array (gleiche L\u00e4nge wie Input).</p> Source code in <code>src/biketour_planner/elevation_profiles.py</code> <pre><code>def calculate_gradient(distances: np.ndarray, elevations: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Berechnet die Steigung in Prozent zwischen aufeinanderfolgenden Punkten.\n\n    Args:\n        distances: Distanzen in Kilometern.\n        elevations: H\u00f6hen in Metern.\n\n    Returns:\n        Steigungen in Prozent als numpy array (gleiche L\u00e4nge wie Input).\n    \"\"\"\n    logger.debug(f\"Start Gradientberechnung f\u00fcr {len(distances)} Eintr\u00e4ge.\")\n    start_time = time.time()\n\n    gradients = np.zeros_like(elevations)\n\n    for i in range(1, len(distances)):\n        dist_diff = (distances[i] - distances[i - 1]) * 1000  # in Meter\n        elev_diff = elevations[i] - elevations[i - 1]\n\n        if dist_diff &gt; 0:\n            gradients[i] = (elev_diff / dist_diff) * 100  # in Prozent\n        else:\n            gradients[i] = 0\n\n    elapsed = time.time() - start_time\n    logger.debug(f\"Gradient berechnet in {elapsed:.2f}s\")\n\n    return gradients\n</code></pre>"},{"location":"api/#biketour_planner.elevation_profiles.create_elevation_profile_plot","title":"<code>create_elevation_profile_plot(gpx_file, booking, pass_track=None, title=None, figsize=(12, 4))</code>","text":"<p>Erstellt ein farbcodiertes H\u00f6henprofil aus einer GPX-Datei.</p> <p>Parameters:</p> Name Type Description Default <code>gpx_file</code> <code>Path</code> <p>Pfad zur GPX-Datei.</p> required <code>booking</code> <code>dict</code> <p>Buchungs-Dictionary (f\u00fcr Haupt-Track Statistiken).</p> required <code>pass_track</code> <code>dict</code> <p>Optional. Pass-Track Dictionary mit Statistiken (falls Pass-Track).</p> <code>None</code> <code>title</code> <code>str</code> <p>Titel des Plots (Default: Dateiname).</p> <code>None</code> <code>figsize</code> <code>tuple[int, int]</code> <p>Gr\u00f6\u00dfe der Figur in Zoll (Breite, H\u00f6he).</p> <code>(12, 4)</code> <p>Returns:</p> Type Description <code>BytesIO</code> <p>BytesIO-Objekt mit PNG-Bilddaten.</p> Example Source code in <code>src/biketour_planner/elevation_profiles.py</code> <pre><code>def create_elevation_profile_plot(\n    gpx_file: Path, booking: dict, pass_track: dict = None, title: str = None, figsize: tuple[int, int] = (12, 4)\n) -&gt; BytesIO:\n    \"\"\"Erstellt ein farbcodiertes H\u00f6henprofil aus einer GPX-Datei.\n\n    Args:\n        gpx_file: Pfad zur GPX-Datei.\n        booking: Buchungs-Dictionary (f\u00fcr Haupt-Track Statistiken).\n        pass_track: Optional. Pass-Track Dictionary mit Statistiken (falls Pass-Track).\n        title: Titel des Plots (Default: Dateiname).\n        figsize: Gr\u00f6\u00dfe der Figur in Zoll (Breite, H\u00f6he).\n\n    Returns:\n        BytesIO-Objekt mit PNG-Bilddaten.\n\n    Example:\n        &gt;&gt;&gt; # Haupt-Track\n        &gt;&gt;&gt; img_buffer = create_elevation_profile_plot(Path(\"route.gpx\"), booking)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Pass-Track\n        &gt;&gt;&gt; pass_track = {\"total_ascent_m\": 1234, \"total_descent_m\": 567, ...}\n        &gt;&gt;&gt; img_buffer = create_elevation_profile_plot(Path(\"pass.gpx\"), booking, pass_track)\n    \"\"\"\n    logger.debug(f\"Erstelle H\u00f6henprofil-Plot f\u00fcr {gpx_file.name}\")\n    start_time = time.time()\n\n    # Timing f\u00fcr einzelne Schritte\n    t0 = time.time()\n\n    # Daten extrahieren\n    distances, elevations = extract_elevation_profile(gpx_file)\n    t1 = time.time()\n    logger.debug(f\"  \u2514\u2500 Datenextraktion: {t1 - t0:.2f}s\")\n\n    gradients = calculate_gradient(distances, elevations)\n    t2 = time.time()\n    logger.debug(f\"  \u2514\u2500 Gradientberechnung: {t2 - t1:.2f}s\")\n\n    # Plot erstellen - Verwende OO-API f\u00fcr Thread-Sicherheit\n    fig = Figure(figsize=figsize, dpi=100)\n    ax = fig.add_subplot(111)\n    t3 = time.time()\n    logger.debug(f\"  \u2514\u2500 Figure erstellen: {t3 - t2:.2f}s\")\n\n    # OPTIMIERUNG: Reduziere Anzahl der Segmente durch Downsampling bei vielen Punkten\n    max_segments = 5000\n    if len(distances) &gt; max_segments:\n        # Downsample: Nimm nur jeden n-ten Punkt\n        step = len(distances) // max_segments\n        distances_plot = distances[::step]\n        elevations_plot = elevations[::step]\n        gradients_plot = gradients[::step]\n        logger.debug(f\"  \u2514\u2500 Downsampling: {len(distances)} -&gt; {len(distances_plot)} Punkte\")\n    else:\n        distances_plot = distances\n        elevations_plot = elevations\n        gradients_plot = gradients\n\n    # OPTIMIERUNG: Verwende PolyCollection f\u00fcr massiv bessere Performance\n    from collections import defaultdict\n\n    color_verts = defaultdict(list)\n\n    for i in range(1, len(distances_plot)):\n        color = get_color_for_gradient(gradients_plot[i])\n        # Erstelle Polygon-Vertizes f\u00fcr dieses Segment: (x0,0), (x0,y0), (x1,y1), (x1,0)\n        verts = [\n            (distances_plot[i - 1], 0),\n            (distances_plot[i - 1], elevations_plot[i - 1]),\n            (distances_plot[i], elevations_plot[i]),\n            (distances_plot[i], 0),\n        ]\n        color_verts[color].append(verts)\n\n    # Zeichne alle Segmente einer Farbe als eine Collection\n    for color, verts in color_verts.items():\n        collection = PolyCollection(verts, facecolors=color, alpha=0.7, linewidths=0, edgecolors=\"none\")\n        ax.add_collection(collection)\n\n    t4 = time.time()\n    logger.debug(f\"  \u2514\u2500 Farbsegmente zeichnen ({len(distances_plot) - 1} Segmente, {len(color_verts)} Farben): {t4 - t3:.2f}s\")\n\n    # Schwarze Konturlinie oben\n    ax.plot(distances, elevations, color=\"black\", linewidth=1.5, zorder=10)\n    t5 = time.time()\n    logger.debug(f\"  \u2514\u2500 Konturlinie zeichnen: {t5 - t4:.2f}s\")\n\n    # Beschriftungen\n    if title is None:\n        title = gpx_file.stem\n    ax.set_title(title, fontsize=14, fontweight=\"bold\", pad=15)\n    ax.set_xlabel(\"Distanz (km)\", fontsize=11)\n    ax.set_ylabel(\"H\u00f6he (m)\", fontsize=11)\n\n    # Grid (vor tight_layout um Performance zu verbessern)\n    ax.grid(True, alpha=0.3, linestyle=\"--\", linewidth=0.5)\n\n    # Achsenlimits (vor tight_layout)\n    ax.set_xlim(0, distances[-1])\n    ax.set_ylim(min(elevations) * 0.8, max(elevations) * 1.1)\n\n    # Statistiken als Text - verwende pass_track falls vorhanden, sonst booking\n    if pass_track:\n        total_ascent = pass_track.get(\"total_ascent_m\", \"\")\n        total_descent = pass_track.get(\"total_descent_m\", \"\")\n    else:\n        total_ascent = booking.get(\"total_ascent_m\", \"\")\n        total_descent = booking.get(\"total_descent_m\", \"\")\n\n    stats_text = (\n        f\"Distanz: {distances[-1]:.1f} km  |  \"\n        f\"Max: {max(elevations):.0f} m  |  \"\n        f\"\u2191 {total_ascent:.0f} m  |  \"\n        f\"\u2193 {total_descent:.0f} m\"\n    )\n    ax.text(\n        0.5,\n        0.98,\n        stats_text,\n        transform=ax.transAxes,\n        fontsize=10,\n        verticalalignment=\"top\",\n        horizontalalignment=\"center\",\n        bbox={\"boxstyle\": \"round\", \"facecolor\": \"wheat\", \"alpha\": 0.5},\n    )\n\n    # Tight Layout auf Figure-Ebene\n    fig.tight_layout()\n    t6 = time.time()\n    logger.debug(f\"  \u2514\u2500 Layout &amp; Beschriftungen: {t6 - t5:.2f}s\")\n\n    # In BytesIO speichern\n    img_buffer = BytesIO()\n\n    # KRITISCHER SCHRITT: Dieser ist oft der Flaschenhals\n    fig.savefig(img_buffer, format=\"png\", dpi=100, bbox_inches=\"tight\")\n    t7 = time.time()\n    logger.debug(f\"  \u2514\u2500 savefig() (KRITISCH): {t7 - t6:.2f}s\")\n\n    # NEU: Validiere dass tats\u00e4chlich Daten im Buffer sind\n    buffer_size = img_buffer.tell()\n\n    # WICHTIG: Buffer zur\u00fccksetzen damit er gelesen werden kann!\n    img_buffer.seek(0)\n\n    # fig.close() existiert nicht bei Figure-Objekten, sie werden durch GC aufger\u00e4umt\n    t8 = time.time()\n    logger.debug(f\"  \u2514\u2500 close(): {t8 - t7:.2f}s\")\n    if buffer_size == 0:\n        raise ValueError(\"savefig() hat keine Daten in den Buffer geschrieben\")\n\n    # WICHTIG: Zur\u00fcck zum Anfang f\u00fcr sp\u00e4teres Lesen\n    img_buffer.seek(0)\n\n    total_time = time.time() - start_time\n    logger.debug(f\"H\u00f6henprofil-Plot erstellt in: {total_time:.2f}s\")\n\n    # Warnung bei langsamen Plots\n    if total_time &gt; 5.0:\n        logger.warning(f\"\u26a0\ufe0f  Plot f\u00fcr {gpx_file.name} war langsam ({total_time:.1f}s) - savefig ben\u00f6tigte {t7 - t6:.1f}s\")\n\n    return img_buffer\n</code></pre>"},{"location":"api/#biketour_planner.elevation_profiles.create_elevation_profile_plot--haupt-track","title":"Haupt-Track","text":"<p>img_buffer = create_elevation_profile_plot(Path(\"route.gpx\"), booking)</p>"},{"location":"api/#biketour_planner.elevation_profiles.create_elevation_profile_plot--pass-track","title":"Pass-Track","text":"<p>pass_track = {\"total_ascent_m\": 1234, \"total_descent_m\": 567, ...} img_buffer = create_elevation_profile_plot(Path(\"pass.gpx\"), booking, pass_track)</p>"},{"location":"api/#biketour_planner.elevation_profiles.extract_elevation_profile","title":"<code>extract_elevation_profile(gpx_file)</code>","text":"<p>Extrahiert Distanz und H\u00f6henprofil aus einer GPX-Datei.</p> <p>Parameters:</p> Name Type Description Default <code>gpx_file</code> <code>Path</code> <p>Pfad zur GPX-Datei.</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>Tuple aus (distances, elevations): - distances: Kumulative Distanz in Kilometern als numpy array - elevations: H\u00f6he in Metern als numpy array</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Wenn GPX-Datei nicht gelesen werden kann oder keine Daten enth\u00e4lt.</p> Source code in <code>src/biketour_planner/elevation_profiles.py</code> <pre><code>def extract_elevation_profile(gpx_file: Path) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Extrahiert Distanz und H\u00f6henprofil aus einer GPX-Datei.\n\n    Args:\n        gpx_file: Pfad zur GPX-Datei.\n\n    Returns:\n        Tuple aus (distances, elevations):\n            - distances: Kumulative Distanz in Kilometern als numpy array\n            - elevations: H\u00f6he in Metern als numpy array\n\n    Raises:\n        ValueError: Wenn GPX-Datei nicht gelesen werden kann oder keine Daten enth\u00e4lt.\n    \"\"\"\n    logger.debug(f\"Extrahiere H\u00f6henprofil aus {gpx_file.name}\")\n    start_time = time.time()\n\n    gpx = read_gpx_file(gpx_file)\n\n    if gpx is None or not gpx.tracks:\n        raise ValueError(f\"Konnte {gpx_file.name} nicht lesen oder keine Tracks gefunden\")\n\n    distances = [0.0]  # Start bei 0 km\n    elevations = []\n\n    prev_point = None\n    cumulative_distance = 0.0\n\n    for track in gpx.tracks:\n        for segment in track.segments:\n            for point in segment.points:\n                if point.elevation is None:\n                    continue\n\n                elevations.append(point.elevation)\n\n                if prev_point is not None:\n                    dist = haversine(prev_point.latitude, prev_point.longitude, point.latitude, point.longitude)\n                    cumulative_distance += dist / 1000.0  # in km\n                    distances.append(cumulative_distance)\n\n                prev_point = point\n\n    if not elevations:\n        raise ValueError(f\"Keine H\u00f6hendaten in {gpx_file.name} gefunden\")\n\n    elapsed = time.time() - start_time\n    logger.debug(f\"H\u00f6henprofil extrahiert f\u00fcr {gpx_file.name} in {elapsed:.2f}s ({len(elevations)} Punkte)\")\n\n    return np.array(distances), np.array(elevations)\n</code></pre>"},{"location":"api/#biketour_planner.elevation_profiles.get_color_for_gradient","title":"<code>get_color_for_gradient(gradient)</code>","text":"<p>Bestimmt die Farbe basierend auf der Steigung.</p> <p>Steigungen (positiv = bergauf): - 0-3%: Hellrot - 3-6%: Mittelrot - 6-10%: Rot - &gt;10%: Dunkelrot</p> <p>Gef\u00e4lle (negativ = bergab): - 0 bis -3%: Hellgr\u00fcn - -3 bis -6%: Mittelgr\u00fcn - -6 bis -10%: Gr\u00fcn - &lt; -10%: Dunkelgr\u00fcn</p> <p>Parameters:</p> Name Type Description Default <code>gradient</code> <code>float</code> <p>Steigung in Prozent.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Hex-Farbcode als String.</p> Source code in <code>src/biketour_planner/elevation_profiles.py</code> <pre><code>def get_color_for_gradient(gradient: float) -&gt; str:\n    \"\"\"Bestimmt die Farbe basierend auf der Steigung.\n\n    Steigungen (positiv = bergauf):\n    - 0-3%: Hellrot\n    - 3-6%: Mittelrot\n    - 6-10%: Rot\n    - &gt;10%: Dunkelrot\n\n    Gef\u00e4lle (negativ = bergab):\n    - 0 bis -3%: Hellgr\u00fcn\n    - -3 bis -6%: Mittelgr\u00fcn\n    - -6 bis -10%: Gr\u00fcn\n    - &lt; -10%: Dunkelgr\u00fcn\n\n    Args:\n        gradient: Steigung in Prozent.\n\n    Returns:\n        Hex-Farbcode als String.\n    \"\"\"\n    if gradient &gt; 0:  # Anstieg - Rott\u00f6ne\n        if gradient &lt; 3:\n            return \"#ffcccc\"  # Hellrot\n        elif gradient &lt; 6:\n            return \"#ff6666\"  # Mittelrot\n        elif gradient &lt; 10:\n            return \"#ff0000\"  # Rot\n        else:\n            return \"#cc0000\"  # Dunkelrot\n    else:  # Abstieg - Gr\u00fcnt\u00f6ne\n        gradient = abs(gradient)\n        if gradient &lt; 3:\n            return \"#ccffcc\"  # Hellgr\u00fcn\n        elif gradient &lt; 6:\n            return \"#66ff66\"  # Mittelgr\u00fcn\n        elif gradient &lt; 10:\n            return \"#00ff00\"  # Gr\u00fcn\n        else:\n            return \"#00cc00\"  # Dunkelgr\u00fcn\n</code></pre>"},{"location":"api/#biketour_planner.elevation_profiles.get_merged_gpx_files_from_bookings","title":"<code>get_merged_gpx_files_from_bookings(bookings, output_dir)</code>","text":"<p>Extrahiert die Pfade zu den gemergten GPX-Dateien aus den Buchungen.</p> <p>Parameters:</p> Name Type Description Default <code>bookings</code> <code>list[dict]</code> <p>Liste mit Buchungs-Dictionaries.</p> required <code>output_dir</code> <code>Path</code> <p>Verzeichnis mit den gemergten GPX-Dateien.</p> required <p>Returns:</p> Type Description <code>list[Path]</code> <p>Liste von Pfaden zu GPX-Dateien.</p> Source code in <code>src/biketour_planner/elevation_profiles.py</code> <pre><code>def get_merged_gpx_files_from_bookings(bookings: list[dict], output_dir: Path) -&gt; list[Path]:\n    \"\"\"Extrahiert die Pfade zu den gemergten GPX-Dateien aus den Buchungen.\n\n    Args:\n        bookings: Liste mit Buchungs-Dictionaries.\n        output_dir: Verzeichnis mit den gemergten GPX-Dateien.\n\n    Returns:\n        Liste von Pfaden zu GPX-Dateien.\n    \"\"\"\n    gpx_files = []\n\n    for booking in bookings:\n        gpx_track = booking.get(\"gpx_track_final\")\n        if gpx_track:\n            gpx_path = output_dir / gpx_track\n            if gpx_path.exists():\n                gpx_files.append(gpx_path)\n\n    return gpx_files\n</code></pre>"},{"location":"api/#biketour_planner.pass_finder","title":"<code>biketour_planner.pass_finder</code>","text":"<p>Pass-Finder Modul f\u00fcr automatische Zuordnung von Pass-Tracks zu Buchungen.</p> <p>Dieses Modul findet GPS-Tracks die zu bestimmten P\u00e4ssen f\u00fchren und ordnet sie den n\u00e4chstgelegenen Hotels zu.</p>"},{"location":"api/#biketour_planner.pass_finder-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.pass_finder.find_nearest_hotel","title":"<code>find_nearest_hotel(pass_lat, pass_lon, bookings)</code>","text":"<p>Findet das n\u00e4chstgelegene Hotel zu einem Pass.</p> <p>Parameters:</p> Name Type Description Default <code>pass_lat</code> <code>float</code> <p>Breitengrad des Passes.</p> required <code>pass_lon</code> <code>float</code> <p>L\u00e4ngengrad des Passes.</p> required <code>bookings</code> <code>list[dict]</code> <p>Liste mit Buchungs-Dictionaries.</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>N\u00e4chstgelegenes Buchungs-Dictionary oder None.</p> Source code in <code>src/biketour_planner/pass_finder.py</code> <pre><code>def find_nearest_hotel(pass_lat: float, pass_lon: float, bookings: list[dict]) -&gt; dict | None:\n    \"\"\"Findet das n\u00e4chstgelegene Hotel zu einem Pass.\n\n    Args:\n        pass_lat: Breitengrad des Passes.\n        pass_lon: L\u00e4ngengrad des Passes.\n        bookings: Liste mit Buchungs-Dictionaries.\n\n    Returns:\n        N\u00e4chstgelegenes Buchungs-Dictionary oder None.\n    \"\"\"\n    nearest_booking = None\n    min_distance = float(\"inf\")\n\n    for booking in bookings:\n        hotel_lat = booking.get(\"latitude\")\n        hotel_lon = booking.get(\"longitude\")\n\n        if hotel_lat is None or hotel_lon is None:\n            continue\n\n        distance = haversine(pass_lat, pass_lon, hotel_lat, hotel_lon)\n\n        if distance &lt; min_distance:\n            min_distance = distance\n            nearest_booking = booking\n\n    if nearest_booking:\n        logger.info(f\"N\u00e4chstes Hotel zu Pass: {nearest_booking.get('hotel_name')} ({min_distance / 1000:.1f} km entfernt)\")\n\n    return nearest_booking\n</code></pre>"},{"location":"api/#biketour_planner.pass_finder.find_pass_track","title":"<code>find_pass_track(hotel_lat, hotel_lon, pass_lat, pass_lon, gpx_dir, hotel_radius_km=None, pass_radius_km=None)</code>","text":"<p>Findet einen GPS-Track der vom Hotel zum Pass f\u00fchrt.</p> <p>Sucht nach GPX-Dateien deren: - Startpunkt im Umkreis von hotel_radius_km vom Hotel liegt - Endpunkt im Umkreis von pass_radius_km vom Pass liegt</p> <p>Parameters:</p> Name Type Description Default <code>hotel_lat</code> <code>float</code> <p>Breitengrad des Hotels.</p> required <code>hotel_lon</code> <code>float</code> <p>L\u00e4ngengrad des Hotels.</p> required <code>pass_lat</code> <code>float</code> <p>Breitengrad des Passes.</p> required <code>pass_lon</code> <code>float</code> <p>L\u00e4ngengrad des Passes.</p> required <code>gpx_dir</code> <code>Path</code> <p>Verzeichnis mit GPX-Dateien.</p> required <code>hotel_radius_km</code> <code>float | None</code> <p>Suchradius um Hotel in Kilometern. Falls None, wird config.passes.hotel_radius_km verwendet.</p> <code>None</code> <code>pass_radius_km</code> <code>float | None</code> <p>Suchradius um Pass in Kilometern. Falls None, wird config.passes.pass_radius_km verwendet.</p> <code>None</code> <p>Returns:</p> Type Description <code>Path | None</code> <p>Pfad zur GPX-Datei oder None wenn keine passende Datei gefunden.</p> Source code in <code>src/biketour_planner/pass_finder.py</code> <pre><code>def find_pass_track(\n    hotel_lat: float,\n    hotel_lon: float,\n    pass_lat: float,\n    pass_lon: float,\n    gpx_dir: Path,\n    hotel_radius_km: float | None = None,\n    pass_radius_km: float | None = None,\n) -&gt; Path | None:\n    \"\"\"Findet einen GPS-Track der vom Hotel zum Pass f\u00fchrt.\n\n    Sucht nach GPX-Dateien deren:\n    - Startpunkt im Umkreis von hotel_radius_km vom Hotel liegt\n    - Endpunkt im Umkreis von pass_radius_km vom Pass liegt\n\n    Args:\n        hotel_lat: Breitengrad des Hotels.\n        hotel_lon: L\u00e4ngengrad des Hotels.\n        pass_lat: Breitengrad des Passes.\n        pass_lon: L\u00e4ngengrad des Passes.\n        gpx_dir: Verzeichnis mit GPX-Dateien.\n        hotel_radius_km: Suchradius um Hotel in Kilometern. Falls None, wird config.passes.hotel_radius_km verwendet.\n        pass_radius_km: Suchradius um Pass in Kilometern. Falls None, wird config.passes.pass_radius_km verwendet.\n\n    Returns:\n        Pfad zur GPX-Datei oder None wenn keine passende Datei gefunden.\n    \"\"\"\n    # Lade Config f\u00fcr Defaults\n    config = get_config()\n\n    if hotel_radius_km is None:\n        hotel_radius_km = config.passes.hotel_radius_km\n\n    if pass_radius_km is None:\n        pass_radius_km = config.passes.pass_radius_km\n\n    hotel_radius_m = hotel_radius_km * 1000\n    pass_radius_m = pass_radius_km * 1000\n\n    best_track = None\n    best_score = float(\"inf\")  # Geringste Summe der Abst\u00e4nde\n\n    for gpx_file in gpx_dir.glob(\"*.gpx\"):\n        endpoints = get_gpx_endpoints(gpx_file)\n\n        if endpoints is None:\n            continue\n\n        start_lat, start_lon, end_lat, end_lon = endpoints\n\n        # Pr\u00fcfe ob Start in Hotel-N\u00e4he und Ende in Pass-N\u00e4he\n        dist_start_to_hotel = haversine(start_lat, start_lon, hotel_lat, hotel_lon)\n        dist_end_to_pass = haversine(end_lat, end_lon, pass_lat, pass_lon)\n\n        if dist_start_to_hotel &lt;= hotel_radius_m and dist_end_to_pass &lt;= pass_radius_m:\n            score = dist_start_to_hotel + dist_end_to_pass\n            if score &lt; best_score:\n                best_score = score\n                best_track = gpx_file\n                logger.debug(f\"Kandidat: {gpx_file.name} (Hotel: {dist_start_to_hotel:.0f}m, Pass: {dist_end_to_pass:.0f}m)\")\n\n        # Pr\u00fcfe auch umgekehrte Richtung (Ende bei Hotel, Start bei Pass)\n        dist_end_to_hotel = haversine(end_lat, end_lon, hotel_lat, hotel_lon)\n        dist_start_to_pass = haversine(start_lat, start_lon, pass_lat, pass_lon)\n\n        if dist_end_to_hotel &lt;= hotel_radius_m and dist_start_to_pass &lt;= pass_radius_m:\n            score = dist_end_to_hotel + dist_start_to_pass\n            if score &lt; best_score:\n                best_score = score\n                best_track = gpx_file\n                logger.debug(\n                    f\"Kandidat (reversed): {gpx_file.name} (Hotel: {dist_end_to_hotel:.0f}m, Pass: {dist_start_to_pass:.0f}m)\"\n                )\n\n    if best_track:\n        logger.info(f\"\u2705 Pass-Track gefunden: {best_track.name}\")\n    else:\n        logger.warning(\n            f\"\u26a0\ufe0f  Kein passender Track gefunden (Hotel-Radius: {hotel_radius_km}km, Pass-Radius: {pass_radius_km}km)\"\n        )\n\n    return best_track\n</code></pre>"},{"location":"api/#biketour_planner.pass_finder.get_gpx_endpoints","title":"<code>get_gpx_endpoints(gpx_file)</code>","text":"<p>Extrahiert Start- und Endpunkt aus einer GPX-Datei.</p> <p>Parameters:</p> Name Type Description Default <code>gpx_file</code> <code>Path</code> <p>Pfad zur GPX-Datei.</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float, float] | None</code> <p>Tuple (start_lat, start_lon, end_lat, end_lon) oder None bei Fehler.</p> Source code in <code>src/biketour_planner/pass_finder.py</code> <pre><code>def get_gpx_endpoints(gpx_file: Path) -&gt; tuple[float, float, float, float] | None:\n    \"\"\"Extrahiert Start- und Endpunkt aus einer GPX-Datei.\n\n    Args:\n        gpx_file: Pfad zur GPX-Datei.\n\n    Returns:\n        Tuple (start_lat, start_lon, end_lat, end_lon) oder None bei Fehler.\n    \"\"\"\n    gpx = read_gpx_file(gpx_file)\n\n    if gpx is None or not gpx.tracks:\n        return None\n\n    first_point = None\n    last_point = None\n\n    for track in gpx.tracks:\n        for segment in track.segments:\n            for point in segment.points:\n                if first_point is None:\n                    first_point = point\n                last_point = point\n\n    if first_point is None or last_point is None:\n        return None\n\n    return (\n        first_point.latitude,\n        first_point.longitude,\n        last_point.latitude,\n        last_point.longitude,\n    )\n</code></pre>"},{"location":"api/#biketour_planner.pass_finder.load_json","title":"<code>load_json(file_path)</code>","text":"<p>L\u00e4dt eine JSON-Datei mit Error-Handling.</p> <p>Die Funktion sucht die Datei relativ zum 'src/data/' Verzeichnis.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>Path oder String zur JSON-Datei (relativ zu src/data/).</p> required <p>Returns:</p> Type Description <code>JsonData</code> <p>Dictionary oder Liste mit den JSON-Daten.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Wenn die JSON-Datei nicht existiert.</p> <code>JSONDecodeError</code> <p>Wenn das JSON-Format ung\u00fcltig ist.</p> Example <p>data = load_json(\"german_cities.json\") Loaded JSON from german_cities.json print(type(data))  Source code in <code>src/biketour_planner/pass_finder.py</code> <pre><code>def load_json(file_path: Path | str) -&gt; JsonData:\n    \"\"\"L\u00e4dt eine JSON-Datei mit Error-Handling.\n\n    Die Funktion sucht die Datei relativ zum 'src/data/' Verzeichnis.\n\n    Args:\n        file_path: Path oder String zur JSON-Datei (relativ zu src/data/).\n\n    Returns:\n        Dictionary oder Liste mit den JSON-Daten.\n\n    Raises:\n        FileNotFoundError: Wenn die JSON-Datei nicht existiert.\n        json.JSONDecodeError: Wenn das JSON-Format ung\u00fcltig ist.\n\n    Example:\n        &gt;&gt;&gt; data = load_json(\"german_cities.json\")\n        Loaded JSON from german_cities.json\n        &gt;&gt;&gt; print(type(data))\n        &lt;class 'list'&gt;\n    \"\"\"\n    try:\n        with open(file_path, encoding=\"utf-8\") as f:\n            data = json.load(f)\n        print(f\"Loaded JSON from {file_path.name}\")\n        return data\n    except Exception as e:\n        print(f\"Error loading JSON {file_path}: {e}\")\n        raise\n</code></pre>"},{"location":"api/#biketour_planner.pass_finder.process_passes","title":"<code>process_passes(passes_json_path, gpx_dir, bookings, hotel_radius_km=None, pass_radius_km=None)</code>","text":"<p>Verarbeitet alle P\u00e4sse und ordnet GPS-Tracks zu Hotels zu.</p> <p>F\u00fcr jeden Pass in passes.json: 1. Geocodiert den Passnamen 2. Findet das n\u00e4chstgelegene Hotel 3. Sucht einen GPS-Track vom Hotel zum Pass 4. Berechnet Statistiken f\u00fcr den Pass-Track 5. F\u00fcgt den Track zum Buchungs-Dictionary hinzu</p> <p>Parameters:</p> Name Type Description Default <code>passes_json_path</code> <code>Path</code> <p>Pfad zur passes.json Datei.</p> required <code>gpx_dir</code> <code>Path</code> <p>Verzeichnis mit GPX-Dateien.</p> required <code>bookings</code> <code>list[dict]</code> <p>Liste mit Buchungs-Dictionaries (wird modifiziert).</p> required <code>hotel_radius_km</code> <code>float | None</code> <p>Suchradius um Hotel in Kilometern. Falls None, wird config.passes.hotel_radius_km verwendet.</p> <code>None</code> <code>pass_radius_km</code> <code>float | None</code> <p>Suchradius um Pass in Kilometern. Falls None, wird config.passes.pass_radius_km verwendet.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>Modifizierte bookings-Liste mit \"paesse_tracks\" Keys.</p> Example <p>bookings = process_passes( ...     Path(\"gpx/Paesse.json\"), ...     Path(\"gpx/\"), ...     bookings ... ) print(bookings[0].get(\"paesse_tracks\")) [{\"file\": \"Sveti_Jure.gpx\", \"passname\": \"Sveti Jure\", \"total_ascent_m\": 1234, \"total_descent_m\": 567}]</p> Source code in <code>src/biketour_planner/pass_finder.py</code> <pre><code>def process_passes(\n    passes_json_path: Path,\n    gpx_dir: Path,\n    bookings: list[dict],\n    hotel_radius_km: float | None = None,\n    pass_radius_km: float | None = None,\n) -&gt; list[dict]:\n    \"\"\"Verarbeitet alle P\u00e4sse und ordnet GPS-Tracks zu Hotels zu.\n\n    F\u00fcr jeden Pass in passes.json:\n    1. Geocodiert den Passnamen\n    2. Findet das n\u00e4chstgelegene Hotel\n    3. Sucht einen GPS-Track vom Hotel zum Pass\n    4. Berechnet Statistiken f\u00fcr den Pass-Track\n    5. F\u00fcgt den Track zum Buchungs-Dictionary hinzu\n\n    Args:\n        passes_json_path: Pfad zur passes.json Datei.\n        gpx_dir: Verzeichnis mit GPX-Dateien.\n        bookings: Liste mit Buchungs-Dictionaries (wird modifiziert).\n        hotel_radius_km: Suchradius um Hotel in Kilometern. Falls None, wird config.passes.hotel_radius_km verwendet.\n        pass_radius_km: Suchradius um Pass in Kilometern. Falls None, wird config.passes.pass_radius_km verwendet.\n\n    Returns:\n        Modifizierte bookings-Liste mit \"paesse_tracks\" Keys.\n\n    Example:\n        &gt;&gt;&gt; bookings = process_passes(\n        ...     Path(\"gpx/Paesse.json\"),\n        ...     Path(\"gpx/\"),\n        ...     bookings\n        ... )\n        &gt;&gt;&gt; print(bookings[0].get(\"paesse_tracks\"))\n        [{\"file\": \"Sveti_Jure.gpx\", \"passname\": \"Sveti Jure\", \"total_ascent_m\": 1234, \"total_descent_m\": 567}]\n    \"\"\"\n    # Lade Config f\u00fcr Defaults\n    config = get_config()\n\n    if hotel_radius_km is None:\n        hotel_radius_km = config.passes.hotel_radius_km\n\n    if pass_radius_km is None:\n        pass_radius_km = config.passes.pass_radius_km\n\n    if not passes_json_path.exists():\n        logger.warning(f\"Keine P\u00e4sse-Datei gefunden: {passes_json_path}\")\n        return bookings\n\n    # Lade P\u00e4sse\n    passes = load_json(passes_json_path)\n\n    if not passes:\n        logger.info(\"Keine P\u00e4sse in der JSON-Datei\")\n        return bookings\n\n    logger.info(f\"\\n{'=' * 80}\")\n    logger.info(f\"Verarbeite {len(passes)} Pass/P\u00e4sse\")\n    logger.info(f\"{'=' * 80}\\n\")\n\n    # Initialisiere paesse_tracks f\u00fcr alle Buchungen\n    for booking in bookings:\n        if \"paesse_tracks\" not in booking:\n            booking[\"paesse_tracks\"] = []\n\n    # Verarbeite jeden Pass\n    for pass_info in passes:\n        passname = pass_info.get(\"passname\")\n\n        if not passname:\n            logger.warning(\"Pass ohne Namen gefunden, \u00fcberspringe\")\n            continue\n\n        logger.info(f\"\\n\ud83c\udfd4\ufe0f  Verarbeite Pass: {passname}\")\n\n        # Geocodiere Pass\n        try:\n            pass_lat, pass_lon = geocode_address(passname)\n            logger.info(f\"   Koordinaten: {pass_lat:.6f}, {pass_lon:.6f}\")\n        except ValueError as e:\n            logger.error(f\"   \u274c Geocoding fehlgeschlagen: {e}\")\n            continue\n\n        # Finde n\u00e4chstes Hotel\n        nearest_hotel = find_nearest_hotel(pass_lat, pass_lon, bookings)\n\n        if nearest_hotel is None:\n            logger.warning(f\"   \u26a0\ufe0f  Kein Hotel gefunden f\u00fcr {passname}\")\n            continue\n\n        hotel_lat = nearest_hotel[\"latitude\"]\n        hotel_lon = nearest_hotel[\"longitude\"]\n        hotel_name = nearest_hotel.get(\"hotel_name\", \"Unbekannt\")\n\n        logger.info(f\"   \ud83c\udfe8 N\u00e4chstes Hotel: {hotel_name}\")\n\n        # Finde GPS-Track\n        track_file = find_pass_track(hotel_lat, hotel_lon, pass_lat, pass_lon, gpx_dir, hotel_radius_km, pass_radius_km)\n\n        if track_file:\n            # Berechne Statistiken f\u00fcr Pass-Track\n            gpx = read_gpx_file(track_file)\n\n            if gpx and gpx.tracks:\n                max_elevation, total_distance, total_ascent, total_descent = get_statistics4track(gpx)\n\n                # F\u00fcge Track zum Buchungs-Dictionary hinzu mit Statistiken\n                pass_track_entry = {\n                    \"file\": track_file.name,\n                    \"passname\": passname,\n                    \"latitude\": pass_lat,\n                    \"longitude\": pass_lon,\n                    \"total_distance_km\": round(total_distance / 1000, 2),\n                    \"total_ascent_m\": int(round(total_ascent)),\n                    \"total_descent_m\": int(round(total_descent)),\n                    \"max_elevation_m\": int(round(max_elevation)) if max_elevation != float(\"-inf\") else None,\n                }\n\n                nearest_hotel[\"paesse_tracks\"].append(pass_track_entry)\n\n                logger.info(f\"   \u2705 Track zugeordnet: {track_file.name} \u2192 {hotel_name}\")\n                logger.info(\n                    f\"      Statistiken: {total_distance / 1000:.1f} km, {int(total_ascent)} hm\u2191, {int(total_descent)} hm\u2193\"\n                )\n            else:\n                logger.warning(f\"   \u26a0\ufe0f  Konnte GPX-Datei {track_file.name} nicht lesen\")\n        else:\n            logger.warning(f\"   \u26a0\ufe0f  Kein passender GPS-Track f\u00fcr {passname} gefunden\")\n\n    # Zusammenfassung\n    total_pass_tracks = sum(len(b.get(\"paesse_tracks\", [])) for b in bookings)\n    logger.info(f\"\\n{'=' * 80}\")\n    logger.info(f\"\u2705 {total_pass_tracks} Pass-Track(s) zugeordnet\")\n    logger.info(f\"{'=' * 80}\\n\")\n\n    return bookings\n</code></pre>"},{"location":"api/#biketour_planner.models","title":"<code>biketour_planner.models</code>","text":"<p>Data models for the Bike Tour Planner.</p>"},{"location":"api/#biketour_planner.models-classes","title":"Classes","text":""},{"location":"api/#biketour_planner.models.Booking","title":"<code>Booking</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Validated booking model representing an accommodation and associated route data.</p> <p>Attributes:</p> Name Type Description <code>hotel_name</code> <code>str</code> <p>Name of the accommodation.</p> <code>arrival_date</code> <code>date</code> <p>Date of arrival.</p> <code>departure_date</code> <code>date</code> <p>Date of departure.</p> <code>latitude</code> <code>float</code> <p>Latitude of the accommodation.</p> <code>longitude</code> <code>float</code> <p>Longitude of the accommodation.</p> <code>address</code> <code>str | None</code> <p>Full address.</p> <code>phone</code> <code>str | None</code> <p>Contact phone number.</p> <code>city_name</code> <code>str | None</code> <p>Name of the city.</p> <code>country_name</code> <code>str | None</code> <p>Name of the country.</p> <code>has_kitchen</code> <code>bool</code> <p>Whether the accommodation has a kitchen.</p> <code>has_washing_machine</code> <code>bool</code> <p>Whether the accommodation has a washing machine.</p> <code>has_breakfast</code> <code>bool</code> <p>Whether breakfast is included.</p> <code>total_price</code> <code>float | None</code> <p>Total cost of the stay.</p> <code>free_cancel_until</code> <code>date | None</code> <p>Last date for free cancellation.</p> <code>tourist_sights</code> <code>dict[str, Any] | None</code> <p>Nearby tourist sights discovered.</p> <code>gpx_files</code> <code>list[dict[str, Any]]</code> <p>List of GPX segments for the route to this booking.</p> <code>gpx_track_final</code> <code>str | None</code> <p>Filename of the merged final GPX track.</p> <code>total_distance_km</code> <code>float | None</code> <p>Total distance for the daily route in km.</p> <code>total_ascent_m</code> <code>int | None</code> <p>Total ascent for the daily route in meters.</p> <code>total_descent_m</code> <code>int | None</code> <p>Total descent for the daily route in meters.</p> <code>max_elevation_m</code> <code>int | None</code> <p>Maximum elevation reached on the route in meters.</p> <code>last_gpx_file</code> <code>dict[str, Any] | None</code> <p>Internal state for chaining routes to the next day.</p> Source code in <code>src/biketour_planner/models.py</code> <pre><code>class Booking(BaseModel):\n    \"\"\"Validated booking model representing an accommodation and associated route data.\n\n    Attributes:\n        hotel_name: Name of the accommodation.\n        arrival_date: Date of arrival.\n        departure_date: Date of departure.\n        latitude: Latitude of the accommodation.\n        longitude: Longitude of the accommodation.\n        address: Full address.\n        phone: Contact phone number.\n        city_name: Name of the city.\n        country_name: Name of the country.\n        has_kitchen: Whether the accommodation has a kitchen.\n        has_washing_machine: Whether the accommodation has a washing machine.\n        has_breakfast: Whether breakfast is included.\n        total_price: Total cost of the stay.\n        free_cancel_until: Last date for free cancellation.\n        tourist_sights: Nearby tourist sights discovered.\n        gpx_files: List of GPX segments for the route to this booking.\n        gpx_track_final: Filename of the merged final GPX track.\n        total_distance_km: Total distance for the daily route in km.\n        total_ascent_m: Total ascent for the daily route in meters.\n        total_descent_m: Total descent for the daily route in meters.\n        max_elevation_m: Maximum elevation reached on the route in meters.\n        last_gpx_file: Internal state for chaining routes to the next day.\n    \"\"\"\n\n    hotel_name: str = Field(..., min_length=1)\n    arrival_date: date\n    departure_date: date\n    latitude: float = Field(..., ge=-90, le=90)\n    longitude: float = Field(..., ge=-180, le=180)\n\n    address: str | None = None\n    phone: str | None = None\n    city_name: str | None = None\n    country_name: str | None = None\n\n    has_kitchen: bool = False\n    has_washing_machine: bool = False\n    has_breakfast: bool = False\n\n    total_price: float | None = Field(None, ge=0)\n    free_cancel_until: date | None = None\n\n    tourist_sights: dict[str, Any] | None = None\n    gpx_files: list[dict[str, Any]] = Field(default_factory=list)\n    gpx_track_final: str | None = None\n\n    total_distance_km: float | None = Field(None, ge=0)\n    total_ascent_m: int | None = Field(None, ge=0)\n    total_descent_m: int | None = Field(None, ge=0)\n    max_elevation_m: int | None = None\n\n    # Internal state for routing\n    last_gpx_file: dict[str, Any] | None = Field(None, alias=\"_last_gpx_file\")\n\n    @field_validator(\"departure_date\")\n    @classmethod\n    def departure_after_arrival(cls, v: date, info: Any) -&gt; date:\n        \"\"\"Validates that departure date is after arrival date.\n\n        Args:\n            v: Departure date.\n            info: Validation context.\n\n        Returns:\n            The validated departure date.\n\n        Raises:\n            ValueError: If departure is not after arrival.\n        \"\"\"\n        if \"arrival_date\" in info.data and v &lt;= info.data[\"arrival_date\"]:\n            raise ValueError(\"Departure must be after arrival\")\n        return v\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n    )\n</code></pre>"},{"location":"api/#biketour_planner.models.Booking-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.models.Booking.departure_after_arrival","title":"<code>departure_after_arrival(v, info)</code>  <code>classmethod</code>","text":"<p>Validates that departure date is after arrival date.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>date</code> <p>Departure date.</p> required <code>info</code> <code>Any</code> <p>Validation context.</p> required <p>Returns:</p> Type Description <code>date</code> <p>The validated departure date.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If departure is not after arrival.</p> Source code in <code>src/biketour_planner/models.py</code> <pre><code>@field_validator(\"departure_date\")\n@classmethod\ndef departure_after_arrival(cls, v: date, info: Any) -&gt; date:\n    \"\"\"Validates that departure date is after arrival date.\n\n    Args:\n        v: Departure date.\n        info: Validation context.\n\n    Returns:\n        The validated departure date.\n\n    Raises:\n        ValueError: If departure is not after arrival.\n    \"\"\"\n    if \"arrival_date\" in info.data and v &lt;= info.data[\"arrival_date\"]:\n        raise ValueError(\"Departure must be after arrival\")\n    return v\n</code></pre>"},{"location":"api/#biketour_planner.models.RouteContext","title":"<code>RouteContext</code>  <code>dataclass</code>","text":"<p>Context for route iteration.</p> <p>Attributes:</p> Name Type Description <code>iteration</code> <code>int</code> <p>Current iteration index.</p> <code>target</code> <code>RoutePosition</code> <p>The target RoutePosition we are heading towards.</p> <code>visited</code> <code>set[str]</code> <p>Set of filenames already visited.</p> <code>used_base_files</code> <code>set[str]</code> <p>Set of base filenames already used.</p> <code>route_files</code> <code>list[dict[str, Any]]</code> <p>List of GPX segments forming the route.</p> <code>force_direction</code> <code>str | None</code> <p>Direction to force for the first segment ('forward' or 'backward').</p> Source code in <code>src/biketour_planner/models.py</code> <pre><code>@dataclass\nclass RouteContext:\n    \"\"\"Context for route iteration.\n\n    Attributes:\n        iteration: Current iteration index.\n        target: The target RoutePosition we are heading towards.\n        visited: Set of filenames already visited.\n        used_base_files: Set of base filenames already used.\n        route_files: List of GPX segments forming the route.\n        force_direction: Direction to force for the first segment ('forward' or 'backward').\n    \"\"\"\n\n    iteration: int\n    target: RoutePosition\n    visited: set[str] = field(default_factory=set)\n    used_base_files: set[str] = field(default_factory=set)\n    route_files: list[dict[str, Any]] = field(default_factory=list)\n    force_direction: str | None = None\n</code></pre>"},{"location":"api/#biketour_planner.models.RoutePosition","title":"<code>RoutePosition</code>  <code>dataclass</code>","text":"<p>Current position in route calculation.</p> <p>Attributes:</p> Name Type Description <code>file</code> <code>str</code> <p>Name of the GPX file.</p> <code>index</code> <code>int</code> <p>Index of the point within the GPX track.</p> <code>lat</code> <code>float</code> <p>Latitude of the point.</p> <code>lon</code> <code>float</code> <p>Longitude of the point.</p> Source code in <code>src/biketour_planner/models.py</code> <pre><code>@dataclass\nclass RoutePosition:\n    \"\"\"Current position in route calculation.\n\n    Attributes:\n        file: Name of the GPX file.\n        index: Index of the point within the GPX track.\n        lat: Latitude of the point.\n        lon: Longitude of the point.\n    \"\"\"\n\n    file: str\n    index: int\n    lat: float\n    lon: float\n</code></pre>"},{"location":"api/#biketour_planner.models.RouteStatistics","title":"<code>RouteStatistics</code>  <code>dataclass</code>","text":"<p>Accumulated route statistics.</p> <p>Attributes:</p> Name Type Description <code>max_elevation</code> <code>float</code> <p>Maximum elevation reached in meters.</p> <code>total_distance</code> <code>float</code> <p>Total distance traveled in meters.</p> <code>total_ascent</code> <code>float</code> <p>Total ascent in meters.</p> <code>total_descent</code> <code>float</code> <p>Total descent in meters.</p> Source code in <code>src/biketour_planner/models.py</code> <pre><code>@dataclass\nclass RouteStatistics:\n    \"\"\"Accumulated route statistics.\n\n    Attributes:\n        max_elevation: Maximum elevation reached in meters.\n        total_distance: Total distance traveled in meters.\n        total_ascent: Total ascent in meters.\n        total_descent: Total descent in meters.\n    \"\"\"\n\n    max_elevation: float = 0.0\n    total_distance: float = 0.0\n    total_ascent: float = 0.0\n    total_descent: float = 0.0\n\n    def update(self, other: RouteStatistics) -&gt; None:\n        \"\"\"Update statistics with another statistics object.\n\n        Args:\n            other: Another RouteStatistics object to merge.\n        \"\"\"\n        self.max_elevation = max(self.max_elevation, other.max_elevation)\n        self.total_distance += other.total_distance\n        self.total_ascent += other.total_ascent\n        self.total_descent += other.total_descent\n</code></pre>"},{"location":"api/#biketour_planner.models.RouteStatistics-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.models.RouteStatistics.update","title":"<code>update(other)</code>","text":"<p>Update statistics with another statistics object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>RouteStatistics</code> <p>Another RouteStatistics object to merge.</p> required Source code in <code>src/biketour_planner/models.py</code> <pre><code>def update(self, other: RouteStatistics) -&gt; None:\n    \"\"\"Update statistics with another statistics object.\n\n    Args:\n        other: Another RouteStatistics object to merge.\n    \"\"\"\n    self.max_elevation = max(self.max_elevation, other.max_elevation)\n    self.total_distance += other.total_distance\n    self.total_ascent += other.total_ascent\n    self.total_descent += other.total_descent\n</code></pre>"},{"location":"api/#biketour_planner.config","title":"<code>biketour_planner.config</code>","text":"<p>Configuration management for the Bike Tour Planner.</p> <p>Loads configuration from a YAML file with fallback to default values.</p>"},{"location":"api/#biketour_planner.config-classes","title":"Classes","text":""},{"location":"api/#biketour_planner.config.Config","title":"<code>Config</code>","text":"<p>Central configuration class.</p> <p>Loads configuration from config.yaml or uses defaults.</p> Example <p>config = Config() print(config.get(\"routing.max_connection_distance_m\")) 1000 print(config.directories.gpx) PosixPath('../2026_Croatia/gpx')</p> Source code in <code>src/biketour_planner/config.py</code> <pre><code>class Config:\n    \"\"\"Central configuration class.\n\n    Loads configuration from config.yaml or uses defaults.\n\n    Example:\n        &gt;&gt;&gt; config = Config()\n        &gt;&gt;&gt; print(config.get(\"routing.max_connection_distance_m\"))\n        1000\n        &gt;&gt;&gt; print(config.directories.gpx)\n        PosixPath('../2026_Croatia/gpx')\n    \"\"\"\n\n    DEFAULT_CONFIG = {\n        \"directories\": {\"booking\": \"../bookings\", \"gpx\": \"../gpx\", \"output\": \"../output\"},\n        \"routing\": {\n            \"brouter_url\": \"http://localhost:17777\",\n            \"max_connection_distance_m\": 1000,\n            \"max_chain_length\": 20,\n            \"start_search_radius_km\": 3.0,\n            \"target_search_radius_km\": 10.0,\n        },\n        \"passes\": {\"hotel_radius_km\": 5.0, \"pass_radius_km\": 5.0, \"passes_file\": \"Paesse.json\"},\n        \"geoapify\": {\"search_radius_m\": 5000, \"max_pois\": 2},\n        \"export\": {\"title\": \"Bike Tour\", \"excel_info_file\": \"Reiseplanung_Fahrrad.xlsx\"},\n        \"logging\": {\"level\": \"INFO\", \"file\": \"logs/app.log\"},\n    }\n\n    def __init__(self, config_path: Path = Path(\"config.yaml\")):\n        \"\"\"Initializes configuration.\n\n        Args:\n            config_path: Path to the YAML configuration file (Default: config.yaml).\n        \"\"\"\n        self._config = self.DEFAULT_CONFIG.copy()\n\n        if config_path.exists():\n            with open(config_path, encoding=\"utf-8\") as f:\n                user_config = yaml.safe_load(f)\n                self._merge_config(user_config)\n        else:\n            print(f\"\u26a0\ufe0f  No {config_path} found, using default configuration\")\n\n    def _merge_config(self, user_config: dict[str, Any]) -&gt; None:\n        \"\"\"Merges user config with defaults (Deep Merge).\n\n        Args:\n            user_config: Dictionary containing user-defined configuration values.\n        \"\"\"\n\n        def deep_merge(base: dict, override: dict) -&gt; dict:\n            \"\"\"Recursively merges two dictionaries.\"\"\"\n            result = base.copy()\n            for key, value in override.items():\n                if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n                    result[key] = deep_merge(result[key], value)\n                else:\n                    result[key] = value\n            return result\n\n        self._config = deep_merge(self._config, user_config)\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        \"\"\"Gets a configuration value using dot notation.\n\n        Args:\n            key: Configuration key in dot notation (e.g., \"routing.max_connection_distance_m\").\n            default: Return value if the key does not exist.\n\n        Returns:\n            The configuration value or the default.\n\n        Example:\n            &gt;&gt;&gt; config = Config()\n            &gt;&gt;&gt; config.get(\"routing.brouter_url\")\n            'http://localhost:17777'\n        \"\"\"\n        keys = key.split(\".\")\n        value = self._config\n\n        for k in keys:\n            if isinstance(value, dict) and k in value:\n                value = value[k]\n            else:\n                return default\n\n        return value\n\n    @property\n    def directories(self) -&gt; \"DirectoriesConfig\":\n        \"\"\"Access directory configuration.\"\"\"\n        return DirectoriesConfig(self._config[\"directories\"])\n\n    @property\n    def routing(self) -&gt; \"RoutingConfig\":\n        \"\"\"Access routing configuration.\"\"\"\n        return RoutingConfig(self._config[\"routing\"])\n\n    @property\n    def passes(self) -&gt; \"PassesConfig\":\n        \"\"\"Access mountain pass finder configuration.\"\"\"\n        return PassesConfig(self._config[\"passes\"])\n\n    @property\n    def geoapify(self) -&gt; \"GeoapifyConfig\":\n        \"\"\"Access Geoapify configuration.\"\"\"\n        return GeoapifyConfig(self._config[\"geoapify\"])\n\n    @property\n    def export(self) -&gt; \"ExportConfig\":\n        \"\"\"Access export configuration.\"\"\"\n        return ExportConfig(self._config[\"export\"])\n\n    @property\n    def logging(self) -&gt; \"LoggingConfig\":\n        \"\"\"Access logging configuration.\"\"\"\n        return LoggingConfig(self._config[\"logging\"])\n</code></pre>"},{"location":"api/#biketour_planner.config.Config-attributes","title":"Attributes","text":""},{"location":"api/#biketour_planner.config.Config.directories","title":"<code>directories</code>  <code>property</code>","text":"<p>Access directory configuration.</p>"},{"location":"api/#biketour_planner.config.Config.export","title":"<code>export</code>  <code>property</code>","text":"<p>Access export configuration.</p>"},{"location":"api/#biketour_planner.config.Config.geoapify","title":"<code>geoapify</code>  <code>property</code>","text":"<p>Access Geoapify configuration.</p>"},{"location":"api/#biketour_planner.config.Config.logging","title":"<code>logging</code>  <code>property</code>","text":"<p>Access logging configuration.</p>"},{"location":"api/#biketour_planner.config.Config.passes","title":"<code>passes</code>  <code>property</code>","text":"<p>Access mountain pass finder configuration.</p>"},{"location":"api/#biketour_planner.config.Config.routing","title":"<code>routing</code>  <code>property</code>","text":"<p>Access routing configuration.</p>"},{"location":"api/#biketour_planner.config.Config-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.config.Config.__init__","title":"<code>__init__(config_path=Path('config.yaml'))</code>","text":"<p>Initializes configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Path</code> <p>Path to the YAML configuration file (Default: config.yaml).</p> <code>Path('config.yaml')</code> Source code in <code>src/biketour_planner/config.py</code> <pre><code>def __init__(self, config_path: Path = Path(\"config.yaml\")):\n    \"\"\"Initializes configuration.\n\n    Args:\n        config_path: Path to the YAML configuration file (Default: config.yaml).\n    \"\"\"\n    self._config = self.DEFAULT_CONFIG.copy()\n\n    if config_path.exists():\n        with open(config_path, encoding=\"utf-8\") as f:\n            user_config = yaml.safe_load(f)\n            self._merge_config(user_config)\n    else:\n        print(f\"\u26a0\ufe0f  No {config_path} found, using default configuration\")\n</code></pre>"},{"location":"api/#biketour_planner.config.Config.get","title":"<code>get(key, default=None)</code>","text":"<p>Gets a configuration value using dot notation.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Configuration key in dot notation (e.g., \"routing.max_connection_distance_m\").</p> required <code>default</code> <code>Any</code> <p>Return value if the key does not exist.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The configuration value or the default.</p> Example <p>config = Config() config.get(\"routing.brouter_url\") 'http://localhost:17777'</p> Source code in <code>src/biketour_planner/config.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"Gets a configuration value using dot notation.\n\n    Args:\n        key: Configuration key in dot notation (e.g., \"routing.max_connection_distance_m\").\n        default: Return value if the key does not exist.\n\n    Returns:\n        The configuration value or the default.\n\n    Example:\n        &gt;&gt;&gt; config = Config()\n        &gt;&gt;&gt; config.get(\"routing.brouter_url\")\n        'http://localhost:17777'\n    \"\"\"\n    keys = key.split(\".\")\n    value = self._config\n\n    for k in keys:\n        if isinstance(value, dict) and k in value:\n            value = value[k]\n        else:\n            return default\n\n    return value\n</code></pre>"},{"location":"api/#biketour_planner.config.DirectoriesConfig","title":"<code>DirectoriesConfig</code>","text":"<p>Helper class for directory configuration access.</p> Source code in <code>src/biketour_planner/config.py</code> <pre><code>class DirectoriesConfig:\n    \"\"\"Helper class for directory configuration access.\"\"\"\n\n    def __init__(self, config: dict):\n        \"\"\"Initializes DirectoriesConfig.\n\n        Args:\n            config: Dictionary containing directory settings.\n        \"\"\"\n        self._config = config\n\n    @property\n    def booking(self) -&gt; Path:\n        \"\"\"Path to booking HTML files.\"\"\"\n        return Path(self._config[\"booking\"])\n\n    @property\n    def gpx(self) -&gt; Path:\n        \"\"\"Path to original GPX files.\"\"\"\n        return Path(self._config[\"gpx\"])\n\n    @property\n    def output(self) -&gt; Path:\n        \"\"\"Path for generated output files.\"\"\"\n        return Path(self._config[\"output\"])\n</code></pre>"},{"location":"api/#biketour_planner.config.DirectoriesConfig-attributes","title":"Attributes","text":""},{"location":"api/#biketour_planner.config.DirectoriesConfig.booking","title":"<code>booking</code>  <code>property</code>","text":"<p>Path to booking HTML files.</p>"},{"location":"api/#biketour_planner.config.DirectoriesConfig.gpx","title":"<code>gpx</code>  <code>property</code>","text":"<p>Path to original GPX files.</p>"},{"location":"api/#biketour_planner.config.DirectoriesConfig.output","title":"<code>output</code>  <code>property</code>","text":"<p>Path for generated output files.</p>"},{"location":"api/#biketour_planner.config.DirectoriesConfig-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.config.DirectoriesConfig.__init__","title":"<code>__init__(config)</code>","text":"<p>Initializes DirectoriesConfig.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>Dictionary containing directory settings.</p> required Source code in <code>src/biketour_planner/config.py</code> <pre><code>def __init__(self, config: dict):\n    \"\"\"Initializes DirectoriesConfig.\n\n    Args:\n        config: Dictionary containing directory settings.\n    \"\"\"\n    self._config = config\n</code></pre>"},{"location":"api/#biketour_planner.config.ExportConfig","title":"<code>ExportConfig</code>","text":"<p>Helper class for export parameters.</p> Source code in <code>src/biketour_planner/config.py</code> <pre><code>class ExportConfig:\n    \"\"\"Helper class for export parameters.\"\"\"\n\n    def __init__(self, config: dict):\n        \"\"\"Initializes ExportConfig.\n\n        Args:\n            config: Dictionary containing export settings.\n        \"\"\"\n        self._config = config\n\n    @property\n    def title(self) -&gt; str:\n        \"\"\"Title of the generated report.\"\"\"\n        return self._config[\"title\"]\n\n    @property\n    def excel_info_file(self) -&gt; str:\n        \"\"\"Filename of the additional trip info Excel file.\"\"\"\n        return self._config[\"excel_info_file\"]\n</code></pre>"},{"location":"api/#biketour_planner.config.ExportConfig-attributes","title":"Attributes","text":""},{"location":"api/#biketour_planner.config.ExportConfig.excel_info_file","title":"<code>excel_info_file</code>  <code>property</code>","text":"<p>Filename of the additional trip info Excel file.</p>"},{"location":"api/#biketour_planner.config.ExportConfig.title","title":"<code>title</code>  <code>property</code>","text":"<p>Title of the generated report.</p>"},{"location":"api/#biketour_planner.config.ExportConfig-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.config.ExportConfig.__init__","title":"<code>__init__(config)</code>","text":"<p>Initializes ExportConfig.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>Dictionary containing export settings.</p> required Source code in <code>src/biketour_planner/config.py</code> <pre><code>def __init__(self, config: dict):\n    \"\"\"Initializes ExportConfig.\n\n    Args:\n        config: Dictionary containing export settings.\n    \"\"\"\n    self._config = config\n</code></pre>"},{"location":"api/#biketour_planner.config.GeoapifyConfig","title":"<code>GeoapifyConfig</code>","text":"<p>Helper class for Geoapify parameters.</p> Source code in <code>src/biketour_planner/config.py</code> <pre><code>class GeoapifyConfig:\n    \"\"\"Helper class for Geoapify parameters.\"\"\"\n\n    def __init__(self, config: dict):\n        \"\"\"Initializes GeoapifyConfig.\n\n        Args:\n            config: Dictionary containing Geoapify settings.\n        \"\"\"\n        self._config = config\n\n    @property\n    def search_radius_m(self) -&gt; int:\n        \"\"\"Search radius for tourist attractions in meters.\"\"\"\n        return int(self._config[\"search_radius_m\"])\n\n    @property\n    def max_pois(self) -&gt; int:\n        \"\"\"Maximum number of tourist attractions to discover.\"\"\"\n        return int(self._config[\"max_pois\"])\n</code></pre>"},{"location":"api/#biketour_planner.config.GeoapifyConfig-attributes","title":"Attributes","text":""},{"location":"api/#biketour_planner.config.GeoapifyConfig.max_pois","title":"<code>max_pois</code>  <code>property</code>","text":"<p>Maximum number of tourist attractions to discover.</p>"},{"location":"api/#biketour_planner.config.GeoapifyConfig.search_radius_m","title":"<code>search_radius_m</code>  <code>property</code>","text":"<p>Search radius for tourist attractions in meters.</p>"},{"location":"api/#biketour_planner.config.GeoapifyConfig-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.config.GeoapifyConfig.__init__","title":"<code>__init__(config)</code>","text":"<p>Initializes GeoapifyConfig.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>Dictionary containing Geoapify settings.</p> required Source code in <code>src/biketour_planner/config.py</code> <pre><code>def __init__(self, config: dict):\n    \"\"\"Initializes GeoapifyConfig.\n\n    Args:\n        config: Dictionary containing Geoapify settings.\n    \"\"\"\n    self._config = config\n</code></pre>"},{"location":"api/#biketour_planner.config.LoggingConfig","title":"<code>LoggingConfig</code>","text":"<p>Helper class for logging parameters.</p> Source code in <code>src/biketour_planner/config.py</code> <pre><code>class LoggingConfig:\n    \"\"\"Helper class for logging parameters.\"\"\"\n\n    def __init__(self, config: dict):\n        \"\"\"Initializes LoggingConfig.\n\n        Args:\n            config: Dictionary containing logging settings.\n        \"\"\"\n        self._config = config\n\n    @property\n    def level(self) -&gt; str:\n        \"\"\"Logging level (e.g., 'INFO', 'DEBUG').\"\"\"\n        return self._config[\"level\"]\n\n    @property\n    def file(self) -&gt; str:\n        \"\"\"Path to the log file.\"\"\"\n        return self._config[\"file\"]\n</code></pre>"},{"location":"api/#biketour_planner.config.LoggingConfig-attributes","title":"Attributes","text":""},{"location":"api/#biketour_planner.config.LoggingConfig.file","title":"<code>file</code>  <code>property</code>","text":"<p>Path to the log file.</p>"},{"location":"api/#biketour_planner.config.LoggingConfig.level","title":"<code>level</code>  <code>property</code>","text":"<p>Logging level (e.g., 'INFO', 'DEBUG').</p>"},{"location":"api/#biketour_planner.config.LoggingConfig-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.config.LoggingConfig.__init__","title":"<code>__init__(config)</code>","text":"<p>Initializes LoggingConfig.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>Dictionary containing logging settings.</p> required Source code in <code>src/biketour_planner/config.py</code> <pre><code>def __init__(self, config: dict):\n    \"\"\"Initializes LoggingConfig.\n\n    Args:\n        config: Dictionary containing logging settings.\n    \"\"\"\n    self._config = config\n</code></pre>"},{"location":"api/#biketour_planner.config.PassesConfig","title":"<code>PassesConfig</code>","text":"<p>Helper class for mountain pass finder parameters.</p> Source code in <code>src/biketour_planner/config.py</code> <pre><code>class PassesConfig:\n    \"\"\"Helper class for mountain pass finder parameters.\"\"\"\n\n    def __init__(self, config: dict):\n        \"\"\"Initializes PassesConfig.\n\n        Args:\n            config: Dictionary containing pass finder settings.\n        \"\"\"\n        self._config = config\n\n    @property\n    def hotel_radius_km(self) -&gt; float:\n        \"\"\"Search radius around hotels for passes in kilometers.\"\"\"\n        return float(self._config[\"hotel_radius_km\"])\n\n    @property\n    def pass_radius_km(self) -&gt; float:\n        \"\"\"Search radius around pass summits in kilometers.\"\"\"\n        return float(self._config[\"pass_radius_km\"])\n\n    @property\n    def passes_file(self) -&gt; str:\n        \"\"\"Filename of the JSON pass database.\"\"\"\n        return self._config[\"passes_file\"]\n</code></pre>"},{"location":"api/#biketour_planner.config.PassesConfig-attributes","title":"Attributes","text":""},{"location":"api/#biketour_planner.config.PassesConfig.hotel_radius_km","title":"<code>hotel_radius_km</code>  <code>property</code>","text":"<p>Search radius around hotels for passes in kilometers.</p>"},{"location":"api/#biketour_planner.config.PassesConfig.pass_radius_km","title":"<code>pass_radius_km</code>  <code>property</code>","text":"<p>Search radius around pass summits in kilometers.</p>"},{"location":"api/#biketour_planner.config.PassesConfig.passes_file","title":"<code>passes_file</code>  <code>property</code>","text":"<p>Filename of the JSON pass database.</p>"},{"location":"api/#biketour_planner.config.PassesConfig-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.config.PassesConfig.__init__","title":"<code>__init__(config)</code>","text":"<p>Initializes PassesConfig.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>Dictionary containing pass finder settings.</p> required Source code in <code>src/biketour_planner/config.py</code> <pre><code>def __init__(self, config: dict):\n    \"\"\"Initializes PassesConfig.\n\n    Args:\n        config: Dictionary containing pass finder settings.\n    \"\"\"\n    self._config = config\n</code></pre>"},{"location":"api/#biketour_planner.config.RoutingConfig","title":"<code>RoutingConfig</code>","text":"<p>Helper class for routing parameters.</p> Source code in <code>src/biketour_planner/config.py</code> <pre><code>class RoutingConfig:\n    \"\"\"Helper class for routing parameters.\"\"\"\n\n    def __init__(self, config: dict):\n        \"\"\"Initializes RoutingConfig.\n\n        Args:\n            config: Dictionary containing routing settings.\n        \"\"\"\n        self._config = config\n\n    @property\n    def brouter_url(self) -&gt; str:\n        \"\"\"URL of the BRouter engine.\"\"\"\n        return self._config[\"brouter_url\"]\n\n    @property\n    def max_connection_distance_m(self) -&gt; float:\n        \"\"\"Maximum distance for automatic track chaining in meters.\"\"\"\n        return float(self._config[\"max_connection_distance_m\"])\n\n    @property\n    def max_chain_length(self) -&gt; int:\n        \"\"\"Maximum number of tracks to chain.\"\"\"\n        return int(self._config[\"max_chain_length\"])\n\n    @property\n    def start_search_radius_km(self) -&gt; float:\n        \"\"\"Search radius for the start track in kilometers.\"\"\"\n        return float(self._config[\"start_search_radius_km\"])\n\n    @property\n    def target_search_radius_km(self) -&gt; float:\n        \"\"\"Search radius for the target track in kilometers.\"\"\"\n        return float(self._config.get(\"target_search_radius_km\", 10.0))\n</code></pre>"},{"location":"api/#biketour_planner.config.RoutingConfig-attributes","title":"Attributes","text":""},{"location":"api/#biketour_planner.config.RoutingConfig.brouter_url","title":"<code>brouter_url</code>  <code>property</code>","text":"<p>URL of the BRouter engine.</p>"},{"location":"api/#biketour_planner.config.RoutingConfig.max_chain_length","title":"<code>max_chain_length</code>  <code>property</code>","text":"<p>Maximum number of tracks to chain.</p>"},{"location":"api/#biketour_planner.config.RoutingConfig.max_connection_distance_m","title":"<code>max_connection_distance_m</code>  <code>property</code>","text":"<p>Maximum distance for automatic track chaining in meters.</p>"},{"location":"api/#biketour_planner.config.RoutingConfig.start_search_radius_km","title":"<code>start_search_radius_km</code>  <code>property</code>","text":"<p>Search radius for the start track in kilometers.</p>"},{"location":"api/#biketour_planner.config.RoutingConfig.target_search_radius_km","title":"<code>target_search_radius_km</code>  <code>property</code>","text":"<p>Search radius for the target track in kilometers.</p>"},{"location":"api/#biketour_planner.config.RoutingConfig-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.config.RoutingConfig.__init__","title":"<code>__init__(config)</code>","text":"<p>Initializes RoutingConfig.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>Dictionary containing routing settings.</p> required Source code in <code>src/biketour_planner/config.py</code> <pre><code>def __init__(self, config: dict):\n    \"\"\"Initializes RoutingConfig.\n\n    Args:\n        config: Dictionary containing routing settings.\n    \"\"\"\n    self._config = config\n</code></pre>"},{"location":"api/#biketour_planner.config-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.config.get_config","title":"<code>get_config()</code>","text":"<p>Gets the global configuration instance (Singleton).</p> <p>Returns:</p> Type Description <code>Config</code> <p>The Config instance.</p> Source code in <code>src/biketour_planner/config.py</code> <pre><code>def get_config() -&gt; Config:\n    \"\"\"Gets the global configuration instance (Singleton).\n\n    Returns:\n        The Config instance.\n    \"\"\"\n    global _global_config\n    if _global_config is None:\n        _global_config = Config()\n    return _global_config\n</code></pre>"},{"location":"api/#biketour_planner.exceptions","title":"<code>biketour_planner.exceptions</code>","text":"<p>Custom exceptions for Bike Tour Planner.</p>"},{"location":"api/#biketour_planner.exceptions-classes","title":"Classes","text":""},{"location":"api/#biketour_planner.exceptions.BikeTourPlannerError","title":"<code>BikeTourPlannerError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all application errors.</p> Source code in <code>src/biketour_planner/exceptions.py</code> <pre><code>class BikeTourPlannerError(Exception):\n    \"\"\"Base exception for all application errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/#biketour_planner.exceptions.ExternalServiceError","title":"<code>ExternalServiceError</code>","text":"<p>               Bases: <code>BikeTourPlannerError</code>, <code>ValueError</code></p> <p>Raised when an external service is unavailable or returns an error.</p> <p>Attributes:</p> Name Type Description <code>service</code> <p>Name of the external service.</p> <code>details</code> <p>Detailed error message.</p> Source code in <code>src/biketour_planner/exceptions.py</code> <pre><code>class ExternalServiceError(BikeTourPlannerError, ValueError):\n    \"\"\"Raised when an external service is unavailable or returns an error.\n\n    Attributes:\n        service: Name of the external service.\n        details: Detailed error message.\n    \"\"\"\n\n    def __init__(self, service: str, details: str):\n        \"\"\"Initializes ExternalServiceError.\n\n        Args:\n            service: Name of the external service.\n            details: Detailed error message.\n        \"\"\"\n        self.service = service\n        self.details = details\n        # Inherit from ValueError to maintain compatibility with existing tests\n        super().__init__(f\"{service} error: {details}\")\n</code></pre>"},{"location":"api/#biketour_planner.exceptions.ExternalServiceError-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.exceptions.ExternalServiceError.__init__","title":"<code>__init__(service, details)</code>","text":"<p>Initializes ExternalServiceError.</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>Name of the external service.</p> required <code>details</code> <code>str</code> <p>Detailed error message.</p> required Source code in <code>src/biketour_planner/exceptions.py</code> <pre><code>def __init__(self, service: str, details: str):\n    \"\"\"Initializes ExternalServiceError.\n\n    Args:\n        service: Name of the external service.\n        details: Detailed error message.\n    \"\"\"\n    self.service = service\n    self.details = details\n    # Inherit from ValueError to maintain compatibility with existing tests\n    super().__init__(f\"{service} error: {details}\")\n</code></pre>"},{"location":"api/#biketour_planner.exceptions.GeocodingError","title":"<code>GeocodingError</code>","text":"<p>               Bases: <code>ExternalServiceError</code></p> <p>Geocoding service error.</p> Source code in <code>src/biketour_planner/exceptions.py</code> <pre><code>class GeocodingError(ExternalServiceError):\n    \"\"\"Geocoding service error.\"\"\"\n\n    def __init__(self, address: str, details: str):\n        \"\"\"Initializes GeocodingError.\n\n        Args:\n            address: The address that failed to geocode.\n            details: Error details.\n        \"\"\"\n        super().__init__(\"Geocoding\", f\"Failed to geocode '{address}': {details}\")\n</code></pre>"},{"location":"api/#biketour_planner.exceptions.GeocodingError-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.exceptions.GeocodingError.__init__","title":"<code>__init__(address, details)</code>","text":"<p>Initializes GeocodingError.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The address that failed to geocode.</p> required <code>details</code> <code>str</code> <p>Error details.</p> required Source code in <code>src/biketour_planner/exceptions.py</code> <pre><code>def __init__(self, address: str, details: str):\n    \"\"\"Initializes GeocodingError.\n\n    Args:\n        address: The address that failed to geocode.\n        details: Error details.\n    \"\"\"\n    super().__init__(\"Geocoding\", f\"Failed to geocode '{address}': {details}\")\n</code></pre>"},{"location":"api/#biketour_planner.exceptions.ParsingError","title":"<code>ParsingError</code>","text":"<p>               Bases: <code>BikeTourPlannerError</code>, <code>ValueError</code></p> <p>Raised when input data (HTML, GPX) cannot be parsed.</p> Source code in <code>src/biketour_planner/exceptions.py</code> <pre><code>class ParsingError(BikeTourPlannerError, ValueError):\n    \"\"\"Raised when input data (HTML, GPX) cannot be parsed.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/#biketour_planner.exceptions.RoutingError","title":"<code>RoutingError</code>","text":"<p>               Bases: <code>ExternalServiceError</code></p> <p>Routing service error.</p> Source code in <code>src/biketour_planner/exceptions.py</code> <pre><code>class RoutingError(ExternalServiceError):\n    \"\"\"Routing service error.\"\"\"\n\n    def __init__(self, details: str):\n        \"\"\"Initializes RoutingError.\n\n        Args:\n            details: Error details.\n        \"\"\"\n        super().__init__(\"Routing\", details)\n</code></pre>"},{"location":"api/#biketour_planner.exceptions.RoutingError-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.exceptions.RoutingError.__init__","title":"<code>__init__(details)</code>","text":"<p>Initializes RoutingError.</p> <p>Parameters:</p> Name Type Description Default <code>details</code> <code>str</code> <p>Error details.</p> required Source code in <code>src/biketour_planner/exceptions.py</code> <pre><code>def __init__(self, details: str):\n    \"\"\"Initializes RoutingError.\n\n    Args:\n        details: Error details.\n    \"\"\"\n    super().__init__(\"Routing\", details)\n</code></pre>"},{"location":"api/#biketour_planner.logger","title":"<code>biketour_planner.logger</code>","text":"<p>Zentrales Logging-Modul f\u00fcr Bike Tour Planner.</p> <p>Dieses Modul stellt einen konfigurierbaren Logger bereit, der sowohl auf die Konsole als auch in Dateien schreiben kann.</p>"},{"location":"api/#biketour_planner.logger-functions","title":"Functions","text":""},{"location":"api/#biketour_planner.logger.get_logger","title":"<code>get_logger(name='biketour_planner')</code>","text":"<p>Gibt einen existierenden Logger zur\u00fcck oder erstellt einen neuen.</p> <p>Diese Funktion ist f\u00fcr Module gedacht, die den bereits konfigurierten Logger verwenden m\u00f6chten.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name des Loggers (Default: \"biketour_planner\").</p> <code>'biketour_planner'</code> <p>Returns:</p> Type Description <code>Logger</code> <p>Logger-Instanz.</p> Example <p>from biketour_planner.logger import get_logger logger = get_logger() logger.info(\"Nachricht\")</p> Source code in <code>src/biketour_planner/logger.py</code> <pre><code>def get_logger(name: str = \"biketour_planner\") -&gt; logging.Logger:\n    \"\"\"Gibt einen existierenden Logger zur\u00fcck oder erstellt einen neuen.\n\n    Diese Funktion ist f\u00fcr Module gedacht, die den bereits konfigurierten\n    Logger verwenden m\u00f6chten.\n\n    Args:\n        name: Name des Loggers (Default: \"biketour_planner\").\n\n    Returns:\n        Logger-Instanz.\n\n    Example:\n        &gt;&gt;&gt; from biketour_planner.logger import get_logger\n        &gt;&gt;&gt; logger = get_logger()\n        &gt;&gt;&gt; logger.info(\"Nachricht\")\n    \"\"\"\n    logger = logging.getLogger(name)\n\n    # Wenn Logger noch keine Handler hat, initialisiere mit Config-Werten\n    if not logger.handlers:\n        logger = setup_logger(name)  # level und log_file werden aus Config geladen\n\n    return logger\n</code></pre>"},{"location":"api/#biketour_planner.logger.setup_logger","title":"<code>setup_logger(name='biketour_planner', level=None, log_file=None, console_output=True)</code>","text":"<p>Konfiguriert und gibt einen Logger zur\u00fcck.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name des Loggers (Default: \"biketour_planner\").</p> <code>'biketour_planner'</code> <code>level</code> <code>int</code> <p>Logging-Level. Falls None, wird config.logging.level verwendet.    M\u00f6gliche Werte: logging.DEBUG, logging.INFO, logging.WARNING,    logging.ERROR, logging.CRITICAL.</p> <code>None</code> <code>log_file</code> <code>Path | None</code> <p>Optional. Pfad zur Log-Datei. Falls None, wird      config.logging.file verwendet.</p> <code>None</code> <code>console_output</code> <code>bool</code> <p>Wenn True, wird zus\u00e4tzlich auf die Konsole geloggt.</p> <code>True</code> <p>Returns:</p> Type Description <code>Logger</code> <p>Konfigurierter Logger.</p> Example <p>logger = setup_logger() logger.info(\"Starte Anwendung\")</p> Source code in <code>src/biketour_planner/logger.py</code> <pre><code>def setup_logger(\n    name: str = \"biketour_planner\",\n    level: int = None,  # Ge\u00e4ndert von logging.INFO\n    log_file: Path | None = None,\n    console_output: bool = True,\n) -&gt; logging.Logger:\n    \"\"\"Konfiguriert und gibt einen Logger zur\u00fcck.\n\n    Args:\n        name: Name des Loggers (Default: \"biketour_planner\").\n        level: Logging-Level. Falls None, wird config.logging.level verwendet.\n               M\u00f6gliche Werte: logging.DEBUG, logging.INFO, logging.WARNING,\n               logging.ERROR, logging.CRITICAL.\n        log_file: Optional. Pfad zur Log-Datei. Falls None, wird\n                 config.logging.file verwendet.\n        console_output: Wenn True, wird zus\u00e4tzlich auf die Konsole geloggt.\n\n    Returns:\n        Konfigurierter Logger.\n\n    Example:\n        &gt;&gt;&gt; logger = setup_logger()\n        &gt;&gt;&gt; logger.info(\"Starte Anwendung\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Mit Datei-Logging\n        &gt;&gt;&gt; logger = setup_logger(log_file=Path(\"logs/app.log\"))\n        &gt;&gt;&gt; logger.debug(\"Debug-Information\")\n    \"\"\"\n    # Lade Config f\u00fcr Defaults (nur wenn ben\u00f6tigt)\n    if level is None or log_file is None:\n        from .config import get_config\n\n        config = get_config()\n\n        if level is None:\n            # Konvertiere String zu logging Level\n            level_str = config.logging.level.upper()\n            level = getattr(logging, level_str, logging.INFO)\n\n        if log_file is None:\n            # Verwende Config-Pfad mit Timestamp\n            base_log_path = Path(config.logging.file)\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M\")\n            log_file = base_log_path.parent / f\"{base_log_path.stem}_{timestamp}.log\"\n\n    logger = logging.getLogger(name)\n    logger.setLevel(level)\n\n    # Verhindere doppelte Handler wenn Logger mehrfach aufgerufen wird\n    if logger.handlers:\n        return logger\n\n    # Format f\u00fcr Log-Nachrichten\n    formatter = logging.Formatter(\n        fmt=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n        datefmt=\"%Y-%m-%d %H:%M:%S\",\n    )\n\n    # Console Handler\n    if console_output:\n        console_handler = logging.StreamHandler(sys.stdout)\n        console_handler.setLevel(logging.WARNING)\n        console_handler.setFormatter(formatter)\n        logger.addHandler(console_handler)\n\n    # File Handler\n    if log_file:\n        # Erstelle Log-Verzeichnis falls nicht vorhanden\n        log_file.parent.mkdir(parents=True, exist_ok=True)\n\n        file_handler = logging.FileHandler(log_file, encoding=\"utf-8\")\n        file_handler.setLevel(level)\n        file_handler.setFormatter(formatter)\n        logger.addHandler(file_handler)\n\n    return logger\n</code></pre>"},{"location":"api/#biketour_planner.logger.setup_logger--mit-datei-logging","title":"Mit Datei-Logging","text":"<p>logger = setup_logger(log_file=Path(\"logs/app.log\")) logger.debug(\"Debug-Information\")</p>"},{"location":"api/#biketour_planner.constants","title":"<code>biketour_planner.constants</code>","text":"<p>Centralized constants for the Bike Tour Planner.</p>"},{"location":"architecture/","title":"Architektur-\u00dcbersicht","text":""},{"location":"architecture/#systemkomponenten","title":"Systemkomponenten","text":"<p>Das System besteht aus mehreren Modulen, die zusammenarbeiten, um aus Buchungsbest\u00e4tigungen und GPX-Tracks einen vollst\u00e4ndigen Reiseplan zu erstellen.</p> graph TD     A[HTML-Buchungen] --&gt; B[parse_booking]     C[GPX-Tracks] --&gt; D[GPXRouteManager]     B --&gt; E[Buchungsdaten]     E --&gt; F[geocode]     F --&gt; E     E --&gt; G[geoapify]     G --&gt; E     D --&gt; H[Routendaten]     E --&gt; I[pass_finder]     H --&gt; I     I --&gt; J[Erweiterte Buchungsdaten]     J --&gt; K[pdf_export]     J --&gt; L[excel_export]     J --&gt; M[ics_export]"},{"location":"architecture/#datenfluss-diagramm","title":"Datenfluss-Diagramm","text":"<p>Der Datenfluss folgt einem sequentiellen Prozess von der Extraktion bis zum Export.</p> sequenceDiagram     participant U as User     participant P as Parser     participant G as Geocoder     participant RM as Route Manager     participant B as BRouter     participant E as Exporter      U-&gt;&gt;P: HTML-Dateien bereitstellen     P-&gt;&gt;P: Daten extrahieren     P-&gt;&gt;G: Adressen senden     G--&gt;&gt;P: Koordinaten empfangen     P-&gt;&gt;RM: Buchungen + GPX-Ordner     RM-&gt;&gt;RM: Tracks analysieren     RM-&gt;&gt;B: Routing-Anfrage (L\u00fccken f\u00fcllen)     B--&gt;&gt;RM: GPX-Segmente     RM-&gt;&gt;RM: GPX zusammenf\u00fchren     RM--&gt;&gt;E: Angereicherte Daten     E-&gt;&gt;U: PDF/Excel/ICS Berichte"},{"location":"architecture/#prozess-lebenszyklus","title":"Prozess-Lebenszyklus","text":"stateDiagram-v2     [*] --&gt; Initialisierung: Lade Konfiguration     Initialisierung --&gt; Parsing: Lese HTML-Buchungen     Parsing --&gt; Geokodierung: Adressen zu Koordinaten     Geokodierung --&gt; POISuche: Suche Sehensw\u00fcrdigkeiten     POISuche --&gt; Routenplanung: Verbinde GPX-Tracks     Routenplanung --&gt; BRouter: Routing zu Hotels     BRouter --&gt; PassSuche: Identifiziere Gebirgsp\u00e4sse     PassSuche --&gt; Export: Generiere Berichte     Export --&gt; [*]"},{"location":"architecture/#kernabstraktionen","title":"Kernabstraktionen","text":"<ul> <li>Booking: Pydantic-Modell, das eine Unterkunft mit Daten, Ort und Ausstattung darstellt.</li> <li>RoutePosition: Dataklasse, die einen Punkt in einem GPX-Track darstellt (Datei und Index).</li> <li>RouteStatistics: Dataklasse zur Akkumulation von Distanz- und H\u00f6hendaten.</li> <li>RouteContext: Dataklasse zur Verwaltung des Zustands w\u00e4hrend der Routensuche.</li> <li>Pass: Gebirgspass mit zugeh\u00f6rigen Track-Daten.</li> </ul>"},{"location":"development/docstrings/","title":"Google-Style Docstrings","text":"<p>Dieses Projekt verwendet den Google-Stil f\u00fcr Python-Docstrings. Alle \u00f6ffentlichen APIs (Module, Klassen, Methoden, Funktionen) m\u00fcssen dokumentiert werden.</p>"},{"location":"development/docstrings/#beispiel","title":"Beispiel","text":"<pre><code>def berechne_distanz(lat1: float, lon1: float, lat2: float, lon2: float) -&gt; float:\n    \"\"\"\n    Berechnet die Haversine-Distanz zwischen zwei Koordinaten.\n\n    Args:\n        lat1 (float): Breitengrad des ersten Punktes.\n        lon1 (float): L\u00e4ngengrad des ersten Punktes.\n        lat2 (float): Breitengrad des zweiten Punktes.\n        lon2 (float): L\u00e4ngengrad des zweiten Punktes.\n\n    Returns:\n        float: Distanz in Metern.\n\n    Raises:\n        ValueError: Wenn die Koordinaten au\u00dferhalb des g\u00fcltigen Bereichs liegen.\n    \"\"\"\n</code></pre>"},{"location":"development/docstrings/#prufung","title":"Pr\u00fcfung","text":"<p>Die Dokumentationsabdeckung wird mit <code>interrogate</code> gepr\u00fcft. Das Ziel ist eine Abdeckung von &gt; 95 %.</p> <pre><code>interrogate src\n</code></pre>"},{"location":"development/metrics/","title":"Dokumentationsmetriken","text":"<p>Hier werden die Qualit\u00e4tsmetriken der Dokumentation verfolgt.</p>"},{"location":"development/metrics/#api-abdeckung","title":"API-Abdeckung","text":"<p>Die aktuelle Abdeckung der Docstrings kann lokal mit folgendem Befehl gepr\u00fcft werden:</p> <pre><code>interrogate -v src\n</code></pre>"},{"location":"development/metrics/#build-status","title":"Build-Status","text":"<p>Die Dokumentation wird automatisch \u00fcber GitHub Actions gebaut und ver\u00f6ffentlicht.</p>"},{"location":"development/metrics/#link-prufung","title":"Link-Pr\u00fcfung","text":"<p>Regelm\u00e4\u00dfige Pr\u00fcfungen auf defekte Links werden im CI-Prozess durchgef\u00fchrt.</p>"},{"location":"development/release/","title":"Release-Workflow","text":"<p>Dieses Projekt verwendet Conventional Commits und git-cliff f\u00fcr automatisierte Changelog-Generierung.</p>"},{"location":"development/release/#commit-konventionen","title":"Commit-Konventionen","text":"<p>Commits sollten dem folgenden Format folgen:</p> <ul> <li><code>feat: ...</code> f\u00fcr neue Funktionen.</li> <li><code>fix: ...</code> f\u00fcr Fehlerbehebungen.</li> <li><code>docs: ...</code> f\u00fcr Dokumentations\u00e4nderungen.</li> <li><code>style: ...</code> f\u00fcr Formatierungs\u00e4nderungen.</li> <li><code>refactor: ...</code> f\u00fcr Code-Refactoring.</li> <li><code>test: ...</code> f\u00fcr Tests.</li> <li><code>chore: ...</code> f\u00fcr Wartungsaufgaben.</li> </ul>"},{"location":"development/release/#changelog-generieren","title":"Changelog generieren","text":"<p>Das Changelog kann manuell mit folgendem Befehl aktualisiert werden:</p> <pre><code>git-cliff -o CHANGELOG.md\n</code></pre>"},{"location":"development/release/#neuen-release-erstellen","title":"Neuen Release erstellen","text":"<ol> <li>Version in <code>pyproject.toml</code> erh\u00f6hen.</li> <li>Changelog aktualisieren: <code>git-cliff -o CHANGELOG.md</code>.</li> <li>\u00c4nderungen committen: <code>git commit -am \"chore(release): prepare for vX.Y.Z\"</code>.</li> <li>Tag erstellen: <code>git tag vX.Y.Z</code>.</li> <li>Pushen: <code>git push &amp;&amp; git push --tags</code>.</li> </ol>"},{"location":"development/testing/","title":"Tests","text":"<p>Dieses Projekt verwendet <code>pytest</code> f\u00fcr automatisierte Tests.</p>"},{"location":"development/testing/#tests-ausfuhren","title":"Tests ausf\u00fchren","text":"<p>F\u00fchren Sie alle Tests aus dem Projektstamm aus:</p> <pre><code>export PYTHONPATH=$(pwd)/src\npytest\n</code></pre>"},{"location":"development/testing/#test-struktur","title":"Test-Struktur","text":"<ul> <li><code>tests/unit/</code>: Unit-Tests f\u00fcr einzelne Module.</li> <li><code>tests/integration/</code>: Integrationstests, die das Zusammenspiel mehrerer Komponenten pr\u00fcfen.</li> </ul>"},{"location":"development/testing/#abdeckung-coverage","title":"Abdeckung (Coverage)","text":"<p>Um einen Abdeckungsbericht zu generieren:</p> <pre><code>pytest --cov=src --cov-report=html\n</code></pre> <p>Der Bericht wird in <code>htmlcov/index.html</code> verf\u00fcgbar sein.</p>"},{"location":"development/testing/#cicd","title":"CI/CD","text":"<p>Tests werden automatisch bei jedem Push und Pull Request \u00fcber GitHub Actions ausgef\u00fchrt.</p>"},{"location":"en/#overview","title":"Overview","text":"<p>Bike Tour Planner is a Python-based toolchain for planning long-distance bike tours by combining:</p> <ul> <li>real-world accommodation data (Booking.com &amp; Airbnb HTML confirmations),</li> <li>existing GPX tracks of your planned or ridden tour,</li> <li>offline bicycle routing using BRouter,</li> <li>tourist attractions discovery via Geoapify API,</li> <li>and automated mountain pass detection.</li> </ul> <p>The main goal is to automatically extend and connect GPX routes so that they lead precisely to booked accommodations, while also collecting useful tour statistics such as distance, elevation gain, and highest point. The planner generates professional PDF reports with elevation profiles, clickable maps, and comprehensive tour information.</p>"},{"location":"en/#key-features","title":"Key Features","text":"<ul> <li>\ud83d\udcc4 Parse Booking.com &amp; Airbnb confirmations (HTML)</li> <li>\ud83c\udf0d Smart Geocoding</li> <li>\ud83d\uddfa\ufe0f Advanced GPX Route Management</li> <li>\ud83d\udeb4 Offline Bicycle Routing with BRouter</li> <li>\ud83c\udfd4\ufe0f Mountain Pass Integration</li> <li>\ud83c\udfaf Tourist Sights Discovery</li> <li>\ud83d\udcca Professional Export Options</li> </ul>"},{"location":"en/#installation","title":"Installation","text":"<p>See Installation and Getting Started.</p>"},{"location":"en/#typical-workflow","title":"Typical Workflow","text":""},{"location":"en/#1-prepare-your-data","title":"1. Prepare Your Data","text":"<pre><code>biketour_planner/\n\u251c\u2500\u2500 booking/                    # Place Booking.com/Airbnb HTML files here\n\u251c\u2500\u2500 gpx/                        # Place your GPX route files here\n</code></pre>"},{"location":"en/#2-configure-mainpy-or-configyaml","title":"2. Configure <code>main.py</code> or <code>config.yaml</code>","text":"<p>See Configuration.</p>"},{"location":"en/#3-run-the-planner","title":"3. Run the Planner","text":"<pre><code>python main.py\n</code></pre>"},{"location":"en/#documentation","title":"Documentation","text":"<ul> <li>Architecture</li> <li>API Reference</li> <li>Testing</li> <li>Troubleshooting</li> </ul>"},{"location":"en/#license","title":"License","text":"<p>This project is licensed under the MIT License. See <code>LICENSE</code> for details.</p>"},{"location":"en/configuration/","title":"Configuration","text":"<p>Configuration is managed via a <code>config.yaml</code> file in the project root. If no file is present, default values are used.</p>"},{"location":"en/configuration/#example-configyaml","title":"Example <code>config.yaml</code>","text":"<pre><code>directories:\n  booking: \"../2026_Croatia/booking\"\n  gpx: \"../2026_Croatia/gpx\"\n  output: \"../2026_Croatia/output\"\n\nrouting:\n  brouter_url: \"http://localhost:17777\"\n  max_connection_distance_m: 1000\n  max_chain_length: 20\n  start_search_radius_km: 3.0\n  target_search_radius_km: 10.0\n\npasses:\n  hotel_radius_km: 5.0\n  pass_radius_km: 5.0\n  passes_file: \"Paesse.json\"\n\ngeoapify:\n  search_radius_m: 5000\n  max_pois: 2\n\nexport:\n  title: \"Croatia Bike Tour 2026\"\n  excel_info_file: \"Reiseplanung_Fahrrad.xlsx\"\n\nlogging:\n  level: \"INFO\"\n  file: \"logs/app.log\"\n</code></pre>"},{"location":"en/configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"en/configuration/#directories-directories","title":"Directories (<code>directories</code>)","text":"<ul> <li><code>booking</code>: Path to HTML booking confirmations.</li> <li><code>gpx</code>: Path to original GPX tracks.</li> <li><code>output</code>: Path for generated files (PDF, merged GPX).</li> </ul>"},{"location":"en/configuration/#routing-routing","title":"Routing (<code>routing</code>)","text":"<ul> <li><code>brouter_url</code>: URL of the BRouter server.</li> <li><code>max_connection_distance_m</code>: Maximum distance between two tracks for automatic chaining.</li> <li><code>max_chain_length</code>: Maximum number of tracks to chain for a daily route.</li> <li><code>start_search_radius_km</code>: Search radius around the starting point to find the first track.</li> <li><code>target_search_radius_km</code>: Search radius around the accommodation to find the target track.</li> </ul>"},{"location":"en/configuration/#mountain-passes-passes","title":"Mountain Passes (<code>passes</code>)","text":"<ul> <li><code>hotel_radius_km</code>: Search radius around hotels for passes.</li> <li><code>pass_radius_km</code>: Search radius around the pass summit.</li> <li><code>passes_file</code>: Name of the JSON file containing passes in the GPX directory.</li> </ul>"},{"location":"en/configuration/#geoapify-geoapify","title":"Geoapify (<code>geoapify</code>)","text":"<ul> <li><code>search_radius_m</code>: Search radius for tourist attractions in meters.</li> <li><code>max_pois</code>: Maximum number of attractions per accommodation.</li> </ul>"},{"location":"en/configuration/#export-export","title":"Export (<code>export</code>)","text":"<ul> <li><code>title</code>: Title of the PDF report.</li> <li><code>excel_info_file</code>: Name of an optional Excel file with additional trip info.</li> </ul>"},{"location":"en/configuration/#secrets-secretsenv","title":"Secrets (<code>secrets.env</code>)","text":"<p>For API keys, create a <code>secrets.env</code> file:</p> <pre><code>GEOAPIFY_API_KEY=your_api_key_here\n</code></pre>"},{"location":"en/getting-started/","title":"Quick Start (5 Minutes)","text":""},{"location":"en/getting-started/#2-start-brouter","title":"2\ufe0f\u20e3 Start BRouter","text":"<pre><code># Download routing data for your region (e.g., Europe)\nmkdir -p brouter_data\ncd brouter_data\nwget https://brouter.de/brouter/segments4/E10_N45.rd5  # Example: Alps\n\n# Start BRouter\ndocker run -d -p 17777:17777 \\\n  -v $(pwd):/segments4 \\\n  --name brouter \\\n  brouter/brouter:latest\n</code></pre> <p>The file <code>start_brouter.bat</code> is available to start the Docker container on Windows. Docker must be running before executing it.</p>"},{"location":"en/getting-started/#3-run-example-tour","title":"3\ufe0f\u20e3 Run Example Tour","text":"<pre><code># Create directory structure\nmkdir -p my_tour/booking my_tour/gpx\n\n# Place your Booking.com HTML confirmations in my_tour/booking/\n# Place your GPX tracks in my_tour/gpx/\n\n# Run the planner\npython main.py \\\n  --booking-dir my_tour/booking \\\n  --gpx-dir my_tour/gpx \\\n  --output-dir my_tour/output\n\n# Open the generated PDF\nopen my_tour/output/Reiseplanung_*.pdf\n</code></pre>"},{"location":"en/getting-started/#next-steps","title":"\ud83c\udfaf Next Steps","text":"<ul> <li>Add Mountain Passes: Create <code>my_tour/gpx/Paesse.json</code> with pass names.</li> <li>Tourist Sights: Add <code>GEOAPIFY_API_KEY</code> to <code>secrets.env</code>.</li> <li>Additional Info: Create <code>my_tour/booking/Reiseplanung_Fahrrad.xlsx</code>.</li> </ul> <p>See the Workflow Documentation for details.</p>"},{"location":"en/installation/#option-1-pip","title":"Option 1: pip","text":"<pre><code># Clone repository\ngit clone https://github.com/dgaida/biketour_planner.git\ncd biketour_planner\n\n# Install dependencies\npip install -r requirements.txt\n\n# Install package in editable mode\npip install -e .\n</code></pre>"},{"location":"en/installation/#option-2-conda-mamba","title":"Option 2: Conda / Mamba","text":"<pre><code># Clone repository\ngit clone https://github.com/dgaida/biketour_planner.git\ncd biketour_planner\n\n# Create and activate environment\nconda env create -f environment.yml\nconda activate biketour_planner\n</code></pre>"},{"location":"en/installation/#requirements","title":"Requirements","text":"<p>Python 3.9 or newer is required.</p>"},{"location":"en/installation/#optional-enable-tourist-sights-discovery","title":"Optional: Enable Tourist Sights Discovery","text":"<p>To use the Geoapify integration for finding tourist attractions:</p> <ol> <li>Create a free account at https://www.geoapify.com</li> <li>Get your API key (free tier: 3,000 requests/day)</li> <li>Create a <code>secrets.env</code> file in the project root:</li> </ol> <pre><code>GEOAPIFY_API_KEY=your_api_key_here\n</code></pre>"},{"location":"en/installation/#brouter-setup-required","title":"BRouter Setup (Required)","text":"<p>Bike Tour Planner relies on BRouter for offline bicycle routing.</p> <p>BRouter is an open-source routing engine developed by Arne Brenschede: \ud83d\udc49 https://github.com/abrensch/brouter</p>"},{"location":"en/installation/#1-download-routing-data-rd5-files","title":"1. Download routing data (<code>.rd5</code> files)","text":"<p>BRouter uses preprocessed OpenStreetMap data split into 5\u00b0 \u00d7 5\u00b0 tiles.</p> <p>Download the required <code>.rd5</code> files from:</p> <pre><code>https://brouter.de/brouter/segments4/\n</code></pre> <p>Place them in a local directory, for example:</p> <pre><code>C:/brouter/segments4/\n</code></pre> <p>Make sure to download all tiles covering your tour area.</p>"},{"location":"en/installation/#2-start-brouter-via-docker","title":"2. Start BRouter via Docker","text":"<p>A running BRouter HTTP server is required.</p>"},{"location":"en/installation/#using-docker-recommended","title":"Using Docker (recommended):","text":"<pre><code>docker run --rm -p 17777:17777 \\\n  -v C:/brouter/segments4:/segments4 \\\n  brouter\n</code></pre>"},{"location":"en/installation/#or-build-from-provided-dockerfile","title":"Or build from provided Dockerfile:","text":"<pre><code>cd brouter_docker\ndocker build -t brouter .\ndocker run --rm -p 17777:17777 \\\n  -v C:/brouter/segments4:/segments4 \\\n  brouter\n</code></pre> <p>The service will be available at:</p> <pre><code>http://localhost:17777\n</code></pre> <p>You can test it with:</p> <pre><code>curl \"http://localhost:17777/brouter?lonlats=16.44,43.51|18.09,42.65&amp;profile=trekking&amp;format=gpx\"\n</code></pre>"},{"location":"en/troubleshooting/","title":"Troubleshooting","text":""},{"location":"en/troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"en/troubleshooting/#brouter-unreachable","title":"BRouter Unreachable","text":"<p>Symptom: Error message regarding connection to <code>localhost:17777</code>.</p> <p>Solution: 1. Ensure the BRouter Docker container is running: <code>docker ps</code>. 2. Check if port 17777 is correctly mapped. 3. Verify that the required <code>.rd5</code> tiles are present in the mounted directory.</p>"},{"location":"en/troubleshooting/#geocoding-fails","title":"Geocoding Fails","text":"<p>Symptom: Accommodation has no coordinates (0.0, 0.0) or error during address search.</p> <p>Solution: 1. Check the address in the HTML file. Sometimes accommodation names in confirmation emails are not unique enough. 2. Try testing the address manually in <code>geocode.py</code> or adjust it in the source file.</p>"},{"location":"en/troubleshooting/#gpx-tracks-not-chained","title":"GPX Tracks Not Chained","text":"<p>Symptom: Routes between accommodations are missing or incomplete.</p> <p>Solution: 1. Check the <code>max_connection_distance_m</code> parameter in the configuration. If your tracks are too far apart, they won't be chained automatically. 2. Ensure all GPX files are in the configured directory. 3. Check logs for \"No tracks found within radius\".</p>"},{"location":"en/troubleshooting/#viewing-logs","title":"Viewing Logs","text":"<p>Logs are written to the <code>logs/</code> folder by default. Increase the log level in the configuration to <code>DEBUG</code> for more detailed information.</p>"},{"location":"en/api/","title":"API Reference","text":"<p>This documentation is automatically generated from the source code's docstrings.</p>"},{"location":"en/api/#core-modules","title":"Core Modules","text":""},{"location":"en/api/#utility-modules","title":"Utility Modules","text":""},{"location":"en/architecture/","title":"Architecture Overview","text":""},{"location":"en/architecture/#system-components","title":"System Components","text":"<p>The system consists of several modules working together to create a complete travel plan from booking confirmations and GPX tracks.</p> graph TD     A[HTML Bookings] --&gt; B[parse_booking]     C[GPX Tracks] --&gt; D[GPXRouteManager]     B --&gt; E[Booking Data]     E --&gt; F[geocode]     F --&gt; E     E --&gt; G[geoapify]     G --&gt; E     D --&gt; H[Route Data]     E --&gt; I[pass_finder]     H --&gt; I     I --&gt; J[Enhanced Booking Data]     J --&gt; K[pdf_export]     J --&gt; L[excel_export]     J --&gt; M[ics_export]"},{"location":"en/architecture/#data-flow-diagram","title":"Data Flow Diagram","text":"<p>Data flow follows a sequential process from extraction to export.</p> sequenceDiagram     participant U as User     participant P as Parser     participant G as Geocoder     participant RM as Route Manager     participant B as BRouter     participant E as Exporter      U-&gt;&gt;P: Provide HTML files     P-&gt;&gt;P: Extract data     P-&gt;&gt;G: Send addresses     G--&gt;&gt;P: Receive coordinates     P-&gt;&gt;RM: Bookings + GPX folder     RM-&gt;&gt;RM: Analyze tracks     RM-&gt;&gt;B: Routing request (fill gaps)     B--&gt;&gt;RM: GPX segments     RM-&gt;&gt;RM: Merge GPX     RM--&gt;&gt;E: Enriched data     E-&gt;&gt;U: PDF/Excel/ICS reports"},{"location":"en/architecture/#process-lifecycle","title":"Process Lifecycle","text":"stateDiagram-v2     [*] --&gt; Initialization: Load Configuration     Initialization --&gt; Parsing: Read HTML Bookings     Parsing --&gt; Geocoding: Addresses to Coordinates     Geocoding --&gt; POISearch: Search Tourist Attractions     POISearch --&gt; RoutePlanning: Chain GPX Tracks     RoutePlanning --&gt; BRouter: Routing to Hotels     BRouter --&gt; PassSearch: Identify Mountain Passes     PassSearch --&gt; Export: Generate Reports     Export --&gt; [*]"},{"location":"en/architecture/#key-abstractions","title":"Key Abstractions","text":"<ul> <li>Booking: Pydantic model representing an accommodation with dates, location, and amenities.</li> <li>RoutePosition: Dataclass representing a point in a GPX track (file and index).</li> <li>RouteStatistics: Dataclass for accumulating distance and elevation data.</li> <li>RouteContext: Dataclass for managing state during route discovery.</li> <li>Pass: Mountain pass with associated track data.</li> </ul>"},{"location":"en/development/docstrings/","title":"Google-Style Docstrings","text":"<p>This project uses the Google style for Python docstrings. All public APIs (modules, classes, methods, functions) must be documented.</p>"},{"location":"en/development/docstrings/#example","title":"Example","text":"<pre><code>def calculate_distance(lat1: float, lon1: float, lat2: float, lon2: float) -&gt; float:\n    \"\"\"\n    Calculates the haversine distance between two coordinates.\n\n    Args:\n        lat1 (float): Latitude of the first point.\n        lon1 (float): Longitude of the first point.\n        lat2 (float): Latitude of the second point.\n        lon2 (float): Longitude of the second point.\n\n    Returns:\n        float: Distance in meters.\n\n    Raises:\n        ValueError: If coordinates are out of valid range.\n    \"\"\"\n</code></pre>"},{"location":"en/development/docstrings/#enforcement","title":"Enforcement","text":"<p>Documentation coverage is measured using <code>interrogate</code>. The goal is a coverage of &gt; 95%.</p> <pre><code>interrogate src\n</code></pre>"},{"location":"en/development/metrics/","title":"Documentation Metrics","text":"<p>Documentation quality metrics are tracked here.</p>"},{"location":"en/development/metrics/#api-coverage","title":"API Coverage","text":"<p>Current docstring coverage can be checked locally with:</p> <pre><code>interrogate -v src\n</code></pre>"},{"location":"en/development/metrics/#build-status","title":"Build Status","text":"<p>Documentation is automatically built and published via GitHub Actions.</p>"},{"location":"en/development/metrics/#link-checking","title":"Link Checking","text":"<p>Regular checks for broken links are performed during the CI process.</p>"},{"location":"en/development/release/","title":"Release Workflow","text":"<p>This project uses Conventional Commits and git-cliff for automated changelog generation.</p>"},{"location":"en/development/release/#commit-conventions","title":"Commit Conventions","text":"<p>Commits should follow this format:</p> <ul> <li><code>feat: ...</code> for new features.</li> <li><code>fix: ...</code> for bug fixes.</li> <li><code>docs: ...</code> for documentation changes.</li> <li><code>style: ...</code> for styling changes.</li> <li><code>refactor: ...</code> for code refactoring.</li> <li><code>test: ...</code> for tests.</li> <li><code>chore: ...</code> for maintenance tasks.</li> </ul>"},{"location":"en/development/release/#generating-changelog","title":"Generating Changelog","text":"<p>The changelog can be manually updated with the following command:</p> <pre><code>git-cliff -o CHANGELOG.md\n</code></pre>"},{"location":"en/development/release/#creating-a-new-release","title":"Creating a New Release","text":"<ol> <li>Bump the version in <code>pyproject.toml</code>.</li> <li>Update the changelog: <code>git-cliff -o CHANGELOG.md</code>.</li> <li>Commit changes: <code>git commit -am \"chore(release): prepare for vX.Y.Z\"</code>.</li> <li>Create a tag: <code>git tag vX.Y.Z</code>.</li> <li>Push: <code>git push &amp;&amp; git push --tags</code>.</li> </ol>"},{"location":"en/development/testing/","title":"Testing","text":"<p>This project uses <code>pytest</code> for automated testing.</p>"},{"location":"en/development/testing/#running-tests","title":"Running Tests","text":"<p>Run all tests from the project root:</p> <pre><code>export PYTHONPATH=$(pwd)/src\npytest\n</code></pre>"},{"location":"en/development/testing/#test-structure","title":"Test Structure","text":"<ul> <li><code>tests/unit/</code>: Unit tests for individual modules.</li> <li><code>tests/integration/</code>: Integration tests checking the interaction between components.</li> </ul>"},{"location":"en/development/testing/#coverage","title":"Coverage","text":"<p>To generate a coverage report:</p> <pre><code>pytest --cov=src --cov-report=html\n</code></pre> <p>The report will be available in <code>htmlcov/index.html</code>.</p>"},{"location":"en/development/testing/#cicd","title":"CI/CD","text":"<p>Tests are automatically executed on every push and pull request via GitHub Actions.</p>"}]}